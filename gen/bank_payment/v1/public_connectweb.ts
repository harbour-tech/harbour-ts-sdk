// @generated by protoc-gen-connect-web v0.9.1 with parameter "target=ts"
// @generated from file bank_payment/v1/public.proto (package bank_payment.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import {
  AddBeneficiaryConfirmRequest,
  AddBeneficiaryConfirmResponse,
  AddBeneficiaryRequest,
  AddBeneficiaryResponse,
  GetBeneficiariesRequest,
  GetBeneficiariesResponse,
  MakePaymentRequest,
  MakePaymentResponse,
  PingRequest,
  PingResponse,
} from "./public_pb";
import { MethodKind } from "@bufbuild/protobuf";

/**
 * @generated from service bank_payment.v1.PingService
 */
export const PingService = {
  typeName: "bank_payment.v1.PingService",
  methods: {
    /**
     * @generated from rpc bank_payment.v1.PingService.Ping
     */
    ping: {
      name: "Ping",
      I: PingRequest,
      O: PingResponse,
      kind: MethodKind.Unary,
    },
  },
} as const;

/**
 * @generated from service bank_payment.v1.BeneficiaryService
 */
export const BeneficiaryService = {
  typeName: "bank_payment.v1.BeneficiaryService",
  methods: {
    /**
     * Returns all of a user's beneficiaries for a certain bank scheme. Requires an authenticated user.
     *
     * @generated from rpc bank_payment.v1.BeneficiaryService.GetBeneficiaries
     */
    getBeneficiaries: {
      name: "GetBeneficiaries",
      I: GetBeneficiariesRequest,
      O: GetBeneficiariesResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Adding a beneficiary consist of the two steps: adding a beneficiary and then confirming via OTP.
     * Note: there is no restriction on creating duplicate beneficiaries, but the backend will generate a UUID for each.
     * Returns a code invalid argument in case of missing mandatory fields, or invalid char length.
     * Returns an error enum for validations to be shown to the user.
     * Requires an authenticated user.
     *
     * @generated from rpc bank_payment.v1.BeneficiaryService.AddBeneficiary
     */
    addBeneficiary: {
      name: "AddBeneficiary",
      I: AddBeneficiaryRequest,
      O: AddBeneficiaryResponse,
      kind: MethodKind.Unary,
    },
    /**
     * To be invoked after AddBeneficiary with a valid OTP.
     * Requires an authenticated user.
     *
     * @generated from rpc bank_payment.v1.BeneficiaryService.AddBeneficiaryConfirm
     */
    addBeneficiaryConfirm: {
      name: "AddBeneficiaryConfirm",
      I: AddBeneficiaryConfirmRequest,
      O: AddBeneficiaryConfirmResponse,
      kind: MethodKind.Unary,
    },
  },
} as const;

/**
 * Single RPC for executing any bank payment for any of the supported schemes.
 * Please note that the payment processing is asynchronous: after basic validation, the backend will run a workflow
 * made of several steps to process it. The first step consists in persisting the payment as "INITIALISED" in the user
 * bank wallet. It will then be processed through different stages such as "PENDING" and then finally either CLEARED
 * or FAILED/REJECTED.
 * Before showing a success screen to the user, after a successful MakePaymentResponse, the client should poll the
 * wallet service every few seconds to check whether the payment is present in the wallet (regardless of its status).
 * The transaction can be identified as its ID is precisely the submitted idempotency key.
 * After 12 seconds, the client should give up and tell the user that something went wrong and please try later.
 * Note for backend engineers: the backend will set a 10-second expiry on the payment, so there's no risk of
 * processing the payment after having shown a failure message to the customer.
 *
 * @generated from service bank_payment.v1.PaymentService
 */
export const PaymentService = {
  typeName: "bank_payment.v1.PaymentService",
  methods: {
    /**
     * The whole point of this complex mechanism is to solve a typical eventual consistency problem in distributed systems.
     * If we show a success message to the user upon a successful response, there is no guarantee that the workflow will
     * ever start processing it. Example: a bug in interpreting an event, or a mis-configuration of a queue, or our
     * workflow software being down. So the user might come back to the wallet screen and be confused as they see no payment
     * even after receiving a success message. The risk is not just confusion, but also the user attempting to send the
     * same payment again. If the messages are eventually picked up, they might result in several duplicate payments,
     * which is why we need a timeout on the message, and which is why the client needs to look for signs of the message
     * being processed by polling the wallet for at least 10 seconds + 2 seconds buffer.
     * This ensures that the user will only ever see a success message if a transaction has already been stored on the wallet,
     * and also ensures that no payment gets processed if the user can't see the transaction on the wallet within 10 seconds.
     *
     * Final note: by "success" here we mean that we successfully started processing the payment.
     * It is not a guarantee of the payment leaving our system and reaching the intended destination.
     * In most cases a payment will be cleared within a few seconds and the client will receive a push notification.
     * In some cases, the payment might fail because of invalid coordinates, or because of potential fraud detection.
     * In other causes, the payment might remain PENDING for a long time, for fraud checks on our end.
     * Finally, in some cases the payment might be CLEARED, only to bounce a few days later as an entirely new inbound
     * payment, which happens when the destination bank rejects the payment. Typically because the account number does not
     * exist or the payee name does not match, or fraud is suspected. It is important to note that in this case the user
     * will see a successful payment (eg: -100 EUR) and a few days later an inbound payment of opposite amount (100 EUR).
     *
     * @generated from rpc bank_payment.v1.PaymentService.MakePayment
     */
    makePayment: {
      name: "MakePayment",
      I: MakePaymentRequest,
      O: MakePaymentResponse,
      kind: MethodKind.Unary,
    },
  },
} as const;
