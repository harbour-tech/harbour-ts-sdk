// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file bank_payment/v1/public.proto (package bank_payment.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum bank_payment.v1.Scheme
 */
export enum Scheme {
  /**
   * @generated from enum value: SCHEME_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * use for UK domestic payments
   *
   * @generated from enum value: SCHEME_SCAN = 1;
   */
  SCAN = 1,

  /**
   * use for EUR international and domestic payments
   *
   * @generated from enum value: SCHEME_SEPA = 2;
   */
  SEPA = 2,

  /**
   * use for non-EUR international payments
   *
   * @generated from enum value: SCHEME_SWIFT = 3;
   */
  SWIFT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Scheme)
proto3.util.setEnumType(Scheme, "bank_payment.v1.Scheme", [
  { no: 0, name: "SCHEME_UNSPECIFIED" },
  { no: 1, name: "SCHEME_SCAN" },
  { no: 2, name: "SCHEME_SEPA" },
  { no: 3, name: "SCHEME_SWIFT" },
]);

/**
 * @generated from message bank_payment.v1.PingRequest
 */
export class PingRequest extends Message<PingRequest> {
  constructor(data?: PartialMessage<PingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.PingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): PingRequest {
    return new PingRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): PingRequest {
    return new PingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): PingRequest {
    return new PingRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: PingRequest | PlainMessage<PingRequest> | undefined,
    b: PingRequest | PlainMessage<PingRequest> | undefined
  ): boolean {
    return proto3.util.equals(PingRequest, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.PingResponse
 */
export class PingResponse extends Message<PingResponse> {
  /**
   * @generated from field: string message = 10;
   */
  message = "";

  constructor(data?: PartialMessage<PingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.PingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): PingResponse {
    return new PingResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): PingResponse {
    return new PingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): PingResponse {
    return new PingResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: PingResponse | PlainMessage<PingResponse> | undefined,
    b: PingResponse | PlainMessage<PingResponse> | undefined
  ): boolean {
    return proto3.util.equals(PingResponse, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.GetBeneficiariesRequest
 */
export class GetBeneficiariesRequest extends Message<GetBeneficiariesRequest> {
  /**
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * scheme - optional parameter, if specified, the endpoint returns only the beneficiaries for a certain scheme
   *
   * @generated from field: optional bank_payment.v1.Scheme scheme = 20;
   */
  scheme?: Scheme;

  constructor(data?: PartialMessage<GetBeneficiariesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.GetBeneficiariesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "scheme",
      kind: "enum",
      T: proto3.getEnumType(Scheme),
      opt: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBeneficiariesRequest {
    return new GetBeneficiariesRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBeneficiariesRequest {
    return new GetBeneficiariesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBeneficiariesRequest {
    return new GetBeneficiariesRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetBeneficiariesRequest
      | PlainMessage<GetBeneficiariesRequest>
      | undefined,
    b:
      | GetBeneficiariesRequest
      | PlainMessage<GetBeneficiariesRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(GetBeneficiariesRequest, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.GetBeneficiariesResponse
 */
export class GetBeneficiariesResponse extends Message<GetBeneficiariesResponse> {
  /**
   * beneficiaries are sorted by last name, created_at
   *
   * @generated from field: repeated bank_payment.v1.Beneficiary entries = 10;
   */
  entries: Beneficiary[] = [];

  constructor(data?: PartialMessage<GetBeneficiariesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.GetBeneficiariesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "entries",
      kind: "message",
      T: Beneficiary,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBeneficiariesResponse {
    return new GetBeneficiariesResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBeneficiariesResponse {
    return new GetBeneficiariesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBeneficiariesResponse {
    return new GetBeneficiariesResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetBeneficiariesResponse
      | PlainMessage<GetBeneficiariesResponse>
      | undefined,
    b:
      | GetBeneficiariesResponse
      | PlainMessage<GetBeneficiariesResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(GetBeneficiariesResponse, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.Beneficiary
 */
export class Beneficiary extends Message<Beneficiary> {
  /**
   * server-generated UUID, omit when requesting beneficiary addition
   *
   * @generated from field: string id = 10;
   */
  id = "";

  /**
   * mandatory
   *
   * @generated from field: bank_payment.v1.Scheme scheme = 20;
   */
  scheme = Scheme.UNSPECIFIED;

  /**
   * mandatory max length 50 chars, should be used as beneficiary name when showing in a list, if customer chooses no alias it's recommended submit the beneficiary name
   *
   * @generated from field: string alias = 30;
   */
  alias = "";

  /**
   * @generated from oneof bank_payment.v1.Beneficiary.beneficiary
   */
  beneficiary:
    | {
        /**
         * @generated from field: bank_payment.v1.IndividualBeneficiary individual = 40;
         */
        value: IndividualBeneficiary;
        case: "individual";
      }
    | {
        /**
         * @generated from field: bank_payment.v1.BusinessBeneficiary business = 50;
         */
        value: BusinessBeneficiary;
        case: "business";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from oneof bank_payment.v1.Beneficiary.coordinates
   */
  coordinates:
    | {
        /**
         * only for scheme SCAN
         *
         * @generated from field: bank_payment.v1.ScanCoordinates scan_coord = 60;
         */
        value: ScanCoordinates;
        case: "scanCoord";
      }
    | {
        /**
         * for both SEPA and SWIFT schemes
         *
         * @generated from field: bank_payment.v1.IbanCoordinates iban_coord = 70;
         */
        value: IbanCoordinates;
        case: "ibanCoord";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Beneficiary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.Beneficiary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "scheme", kind: "enum", T: proto3.getEnumType(Scheme) },
    { no: 30, name: "alias", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 40,
      name: "individual",
      kind: "message",
      T: IndividualBeneficiary,
      oneof: "beneficiary",
    },
    {
      no: 50,
      name: "business",
      kind: "message",
      T: BusinessBeneficiary,
      oneof: "beneficiary",
    },
    {
      no: 60,
      name: "scan_coord",
      kind: "message",
      T: ScanCoordinates,
      oneof: "coordinates",
    },
    {
      no: 70,
      name: "iban_coord",
      kind: "message",
      T: IbanCoordinates,
      oneof: "coordinates",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): Beneficiary {
    return new Beneficiary().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): Beneficiary {
    return new Beneficiary().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Beneficiary {
    return new Beneficiary().fromJsonString(jsonString, options);
  }

  static equals(
    a: Beneficiary | PlainMessage<Beneficiary> | undefined,
    b: Beneficiary | PlainMessage<Beneficiary> | undefined
  ): boolean {
    return proto3.util.equals(Beneficiary, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.IndividualBeneficiary
 */
export class IndividualBeneficiary extends Message<IndividualBeneficiary> {
  /**
   * note: all fields must contain just A-Z a-z 0-9 - . / (and spaces)
   * you can use the following regexp: ^[A-Za-z0-9&\-./ ]+$
   *
   * mandatory max length 30 chars
   *
   * @generated from field: string first_name = 10;
   */
  firstName = "";

  /**
   * mandatory max length 30 chars
   *
   * @generated from field: string last_name = 20;
   */
  lastName = "";

  constructor(data?: PartialMessage<IndividualBeneficiary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.IndividualBeneficiary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "first_name",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 20, name: "last_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): IndividualBeneficiary {
    return new IndividualBeneficiary().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): IndividualBeneficiary {
    return new IndividualBeneficiary().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): IndividualBeneficiary {
    return new IndividualBeneficiary().fromJsonString(jsonString, options);
  }

  static equals(
    a: IndividualBeneficiary | PlainMessage<IndividualBeneficiary> | undefined,
    b: IndividualBeneficiary | PlainMessage<IndividualBeneficiary> | undefined
  ): boolean {
    return proto3.util.equals(IndividualBeneficiary, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.BusinessBeneficiary
 */
export class BusinessBeneficiary extends Message<BusinessBeneficiary> {
  /**
   * note: all fields must contain just A-Z a-z 0-9 - . / (and spaces)
   *
   * mandatory max length 50 chars
   *
   * @generated from field: string business_name = 10;
   */
  businessName = "";

  constructor(data?: PartialMessage<BusinessBeneficiary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.BusinessBeneficiary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "business_name",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): BusinessBeneficiary {
    return new BusinessBeneficiary().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): BusinessBeneficiary {
    return new BusinessBeneficiary().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): BusinessBeneficiary {
    return new BusinessBeneficiary().fromJsonString(jsonString, options);
  }

  static equals(
    a: BusinessBeneficiary | PlainMessage<BusinessBeneficiary> | undefined,
    b: BusinessBeneficiary | PlainMessage<BusinessBeneficiary> | undefined
  ): boolean {
    return proto3.util.equals(BusinessBeneficiary, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.ScanCoordinates
 */
export class ScanCoordinates extends Message<ScanCoordinates> {
  /**
   * always 8 digits
   *
   * @generated from field: string account_number = 10;
   */
  accountNumber = "";

  /**
   * always 6 digits (if using an input mask such as ##-##-##, remove the dashes before submitting)
   *
   * @generated from field: string sort_code = 20;
   */
  sortCode = "";

  constructor(data?: PartialMessage<ScanCoordinates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.ScanCoordinates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "account_number",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 20, name: "sort_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): ScanCoordinates {
    return new ScanCoordinates().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): ScanCoordinates {
    return new ScanCoordinates().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): ScanCoordinates {
    return new ScanCoordinates().fromJsonString(jsonString, options);
  }

  static equals(
    a: ScanCoordinates | PlainMessage<ScanCoordinates> | undefined,
    b: ScanCoordinates | PlainMessage<ScanCoordinates> | undefined
  ): boolean {
    return proto3.util.equals(ScanCoordinates, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.IbanCoordinates
 */
export class IbanCoordinates extends Message<IbanCoordinates> {
  /**
   * up to 34 characters (please submit them all uppercase) and numbers
   *
   * @generated from field: string iban = 10;
   */
  iban = "";

  /**
   * not required (only for international payments),
   * either 8 or 11 characters (please submit them all uppercase) and numbers
   *
   * @generated from field: string bic = 20;
   */
  bic = "";

  constructor(data?: PartialMessage<IbanCoordinates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.IbanCoordinates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "iban", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "bic", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): IbanCoordinates {
    return new IbanCoordinates().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): IbanCoordinates {
    return new IbanCoordinates().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): IbanCoordinates {
    return new IbanCoordinates().fromJsonString(jsonString, options);
  }

  static equals(
    a: IbanCoordinates | PlainMessage<IbanCoordinates> | undefined,
    b: IbanCoordinates | PlainMessage<IbanCoordinates> | undefined
  ): boolean {
    return proto3.util.equals(IbanCoordinates, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.AddBeneficiaryRequest
 */
export class AddBeneficiaryRequest extends Message<AddBeneficiaryRequest> {
  /**
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * Only in non-prod environments, certain beneficiaries will impact the lifecycle of any payment sent to them,
   * to facilitate testing frontend logic, based on the beneficiary first and last name.
   * Lord Sauron: the payment will be accepted, but will time out without ever appearing on the transaction list
   * Lord Saruman: the payment will be accepted, only to fail a few instants later with insufficient funds
   * Lord Voldemort: the payment will be accepted, only to fail a few instants later with a limit exceeded error
   * Lord Thanos: the payment will be accepted, only to fail a few instants later with a server error
   * Note: make sure the account number / sort code combination is still valid, to pass beneficiary validation
   *
   * @generated from field: bank_payment.v1.Beneficiary beneficiary = 20;
   */
  beneficiary?: Beneficiary;

  /**
   * Set dry run to true to invoke the RPC without actually creating the beneficiary.
   * Useful to perform validation on input parameters.
   *
   * @generated from field: bool dry_run = 30;
   */
  dryRun = false;

  constructor(data?: PartialMessage<AddBeneficiaryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.AddBeneficiaryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "beneficiary", kind: "message", T: Beneficiary },
    { no: 30, name: "dry_run", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AddBeneficiaryRequest {
    return new AddBeneficiaryRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AddBeneficiaryRequest {
    return new AddBeneficiaryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AddBeneficiaryRequest {
    return new AddBeneficiaryRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: AddBeneficiaryRequest | PlainMessage<AddBeneficiaryRequest> | undefined,
    b: AddBeneficiaryRequest | PlainMessage<AddBeneficiaryRequest> | undefined
  ): boolean {
    return proto3.util.equals(AddBeneficiaryRequest, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.AddBeneficiaryResponse
 */
export class AddBeneficiaryResponse extends Message<AddBeneficiaryResponse> {
  /**
   * @generated from oneof bank_payment.v1.AddBeneficiaryResponse.result
   */
  result:
    | {
        /**
         * @generated from field: bank_payment.v1.AddBeneficiaryResponse.Error error = 1;
         */
        value: AddBeneficiaryResponse_Error;
        case: "error";
      }
    | {
        /**
         * @generated from field: string token = 2;
         */
        value: string;
        case: "token";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AddBeneficiaryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.AddBeneficiaryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(AddBeneficiaryResponse_Error),
      oneof: "result",
    },
    {
      no: 2,
      name: "token",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AddBeneficiaryResponse {
    return new AddBeneficiaryResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AddBeneficiaryResponse {
    return new AddBeneficiaryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AddBeneficiaryResponse {
    return new AddBeneficiaryResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | AddBeneficiaryResponse
      | PlainMessage<AddBeneficiaryResponse>
      | undefined,
    b: AddBeneficiaryResponse | PlainMessage<AddBeneficiaryResponse> | undefined
  ): boolean {
    return proto3.util.equals(AddBeneficiaryResponse, a, b);
  }
}

/**
 * @generated from enum bank_payment.v1.AddBeneficiaryResponse.Error
 */
export enum AddBeneficiaryResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Returned when the routing code is wrong (eg: sort code for UK and BIC for ibans).
   * Note: the client still needs to perform basic validation, such as guaranteeing that the sort code is exactly 6 digits,
   * else it won't even get this response and just get a code invalid argument.
   * However, the backend will perform more advanced validation, such as checking that the sort code exists, in which
   * case it will return this error.
   *
   * @generated from enum value: ERROR_BANK_CODE_INVALID = 1;
   */
  BANK_CODE_INVALID = 1,

  /**
   * Same as above, but for the account number (eg: account number for UK and IBAN for ibans).
   * In case of UK account numbers, the account number is validated against the sort code, to determine whether it's
   * valid according to the destination bank.
   * In case of IBAN, basic mathematical checks will be performed, according to the IBAN standard, to verify its validity.
   *
   * @generated from enum value: ERROR_BANK_NUMBER_INVALID = 2;
   */
  BANK_NUMBER_INVALID = 2,

  /**
   * Returned when the combination of bank code and bank number is invalid.
   *
   * @generated from enum value: ERROR_CODE_AND_NUMBER_INVALID = 3;
   */
  CODE_AND_NUMBER_INVALID = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AddBeneficiaryResponse_Error)
proto3.util.setEnumType(
  AddBeneficiaryResponse_Error,
  "bank_payment.v1.AddBeneficiaryResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_BANK_CODE_INVALID" },
    { no: 2, name: "ERROR_BANK_NUMBER_INVALID" },
    { no: 3, name: "ERROR_CODE_AND_NUMBER_INVALID" },
  ]
);

/**
 * @generated from message bank_payment.v1.AddBeneficiaryConfirmRequest
 */
export class AddBeneficiaryConfirmRequest extends Message<AddBeneficiaryConfirmRequest> {
  /**
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * @generated from field: string otp = 20;
   */
  otp = "";

  /**
   * @generated from field: string token = 30;
   */
  token = "";

  constructor(data?: PartialMessage<AddBeneficiaryConfirmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.AddBeneficiaryConfirmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "otp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AddBeneficiaryConfirmRequest {
    return new AddBeneficiaryConfirmRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AddBeneficiaryConfirmRequest {
    return new AddBeneficiaryConfirmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AddBeneficiaryConfirmRequest {
    return new AddBeneficiaryConfirmRequest().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | AddBeneficiaryConfirmRequest
      | PlainMessage<AddBeneficiaryConfirmRequest>
      | undefined,
    b:
      | AddBeneficiaryConfirmRequest
      | PlainMessage<AddBeneficiaryConfirmRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(AddBeneficiaryConfirmRequest, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.AddBeneficiaryConfirmResponse
 */
export class AddBeneficiaryConfirmResponse extends Message<AddBeneficiaryConfirmResponse> {
  /**
   * @generated from oneof bank_payment.v1.AddBeneficiaryConfirmResponse.result
   */
  result:
    | {
        /**
         * @generated from field: bank_payment.v1.AddBeneficiaryConfirmResponse.Error error = 10;
         */
        value: AddBeneficiaryConfirmResponse_Error;
        case: "error";
      }
    | {
        /**
         * server-generated UUID for this beneficiary
         *
         * @generated from field: string beneficiary_id = 20;
         */
        value: string;
        case: "beneficiaryId";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AddBeneficiaryConfirmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.AddBeneficiaryConfirmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(AddBeneficiaryConfirmResponse_Error),
      oneof: "result",
    },
    {
      no: 20,
      name: "beneficiary_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AddBeneficiaryConfirmResponse {
    return new AddBeneficiaryConfirmResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AddBeneficiaryConfirmResponse {
    return new AddBeneficiaryConfirmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AddBeneficiaryConfirmResponse {
    return new AddBeneficiaryConfirmResponse().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | AddBeneficiaryConfirmResponse
      | PlainMessage<AddBeneficiaryConfirmResponse>
      | undefined,
    b:
      | AddBeneficiaryConfirmResponse
      | PlainMessage<AddBeneficiaryConfirmResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(AddBeneficiaryConfirmResponse, a, b);
  }
}

/**
 * @generated from enum bank_payment.v1.AddBeneficiaryConfirmResponse.Error
 */
export enum AddBeneficiaryConfirmResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ERROR_OTP_INVALID = 1;
   */
  OTP_INVALID = 1,

  /**
   * @generated from enum value: ERROR_OTP_EXPIRED = 2;
   */
  OTP_EXPIRED = 2,

  /**
   * @generated from enum value: ERROR_OTP_ALREADY_USED = 3;
   */
  OTP_ALREADY_USED = 3,

  /**
   * @generated from enum value: ERROR_TOKEN_INVALID = 4;
   */
  TOKEN_INVALID = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(AddBeneficiaryConfirmResponse_Error)
proto3.util.setEnumType(
  AddBeneficiaryConfirmResponse_Error,
  "bank_payment.v1.AddBeneficiaryConfirmResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_OTP_INVALID" },
    { no: 2, name: "ERROR_OTP_EXPIRED" },
    { no: 3, name: "ERROR_OTP_ALREADY_USED" },
    { no: 4, name: "ERROR_TOKEN_INVALID" },
  ]
);

/**
 * @generated from message bank_payment.v1.MakePaymentRequest
 */
export class MakePaymentRequest extends Message<MakePaymentRequest> {
  /**
   * Mandatory, user executing the payment
   *
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * Mandatory, account from which to take the payment - also determines payment currency
   *
   * @generated from field: string account_id = 20;
   */
  accountId = "";

  /**
   * Mandatory, beneficiary to which to send the payment.
   * The payment scheme is inferred by the beneficiary.
   *
   * @generated from field: string beneficiary_id = 30;
   */
  beneficiaryId = "";

  /**
   * Mandatory, how much the beneficiary should receive, represented as a floating point decimal in the currency's main
   * unit. Eg: 100.20 for 100 euros and 20 cent. Must be a positive number.
   * There is no fee at the moment, but can easily be added later
   * Min-max amount per scheme:
   * SCAN: 0.01 - 1M
   *
   * @generated from field: string net_amount = 40;
   */
  netAmount = "";

  /**
   * Mandatory reference for the payment (eg: "pay energy bill")
   * Min-max length per scheme (after trimming any leading/trailing whitespace):
   * SCAN: 6-18
   * Allowed characters per scheme (spaces are always allowed, but any leading/trailing will be trimmed by backend):
   * SCAN: A-Z a-z 0-9 - . / (and spaces)
   *
   * @generated from field: string reference = 50;
   */
  reference = "";

  /**
   * This flag can be used to validate all the parameters without actually making any payment.
   * At the moment all field validation can be performed by the client, so there's no use for this flag.
   * The client can simply validate all the fields, invoke the RPC, and see if there's a non-zero error enum.
   *
   * @generated from field: bool dry_run = 60;
   */
  dryRun = false;

  /**
   * Idempotency key to avoid double spend. It has to be a UUID (36 chars). It's recommended to generate a v4 UUID.
   * This serves as protection in case the request times out, and the user taps the send button again.
   * However, the UUID should be re-generated if the user changes any of the input parameters, as it is effectively a
   * different payment. Required.
   *
   * @generated from field: string idempotency_key = 70;
   */
  idempotencyKey = "";

  /**
   * Standard jwt with vendor_device_id claim and strict expiry, same as when authenticating
   * note: if this is built incorrectly you'll get a grpc code invalid argument
   *
   * @generated from field: string signature = 80;
   */
  signature = "";

  constructor(data?: PartialMessage<MakePaymentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.MakePaymentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "account_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 30,
      name: "beneficiary_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 40,
      name: "net_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 50, name: "reference", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 60, name: "dry_run", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    {
      no: 70,
      name: "idempotency_key",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 80, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): MakePaymentRequest {
    return new MakePaymentRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): MakePaymentRequest {
    return new MakePaymentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): MakePaymentRequest {
    return new MakePaymentRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: MakePaymentRequest | PlainMessage<MakePaymentRequest> | undefined,
    b: MakePaymentRequest | PlainMessage<MakePaymentRequest> | undefined
  ): boolean {
    return proto3.util.equals(MakePaymentRequest, a, b);
  }
}

/**
 * @generated from message bank_payment.v1.MakePaymentResponse
 */
export class MakePaymentResponse extends Message<MakePaymentResponse> {
  /**
   * @generated from oneof bank_payment.v1.MakePaymentResponse.result
   */
  result:
    | {
        /**
         * @generated from field: bank_payment.v1.MakePaymentResponse.Error error = 10;
         */
        value: MakePaymentResponse_Error;
        case: "error";
      }
    | {
        /**
         * @generated from field: bank_payment.v1.MakePaymentResponse.Payment payment = 20;
         */
        value: MakePaymentResponse_Payment;
        case: "payment";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MakePaymentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.MakePaymentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(MakePaymentResponse_Error),
      oneof: "result",
    },
    {
      no: 20,
      name: "payment",
      kind: "message",
      T: MakePaymentResponse_Payment,
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): MakePaymentResponse {
    return new MakePaymentResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): MakePaymentResponse {
    return new MakePaymentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): MakePaymentResponse {
    return new MakePaymentResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: MakePaymentResponse | PlainMessage<MakePaymentResponse> | undefined,
    b: MakePaymentResponse | PlainMessage<MakePaymentResponse> | undefined
  ): boolean {
    return proto3.util.equals(MakePaymentResponse, a, b);
  }
}

/**
 * @generated from enum bank_payment.v1.MakePaymentResponse.Error
 */
export enum MakePaymentResponse_Error {
  /**
   * Request is valid, no error
   *
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Invalid beneficiary ID. In theory the client should pick a valid beneficiary, but in extremely unlikely and
   * purely theoretical cases, another device might have deleted the beneficiary in the meantime, so it's best to handle
   * this error on the client and display a meaningful error message to the user.
   *
   * @generated from enum value: ERROR_INVALID_BENEFICIARY_ID = 1;
   */
  INVALID_BENEFICIARY_ID = 1,

  /**
   * Insufficient funds on the account to withdraw.
   *
   * @generated from enum value: ERROR_INSUFFICIENT_BALANCE = 2;
   */
  INSUFFICIENT_BALANCE = 2,

  /**
   * Every user might have different limits per single transaction, or daily/monthly.
   * These might be unknown to the client, so the backend will perform this check and the client should display
   * a meaningful error message to the user.
   *
   * @generated from enum value: ERROR_LIMITS_EXCEED = 3;
   */
  LIMITS_EXCEED = 3,

  /**
   * Account is blocked (possibly temporarily) from sending assets out of Harbor.
   *
   * @generated from enum value: ERROR_BLOCKED = 4;
   */
  BLOCKED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(MakePaymentResponse_Error)
proto3.util.setEnumType(
  MakePaymentResponse_Error,
  "bank_payment.v1.MakePaymentResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_INVALID_BENEFICIARY_ID" },
    { no: 2, name: "ERROR_INSUFFICIENT_BALANCE" },
    { no: 3, name: "ERROR_LIMITS_EXCEED" },
    { no: 4, name: "ERROR_BLOCKED" },
  ]
);

/**
 * @generated from message bank_payment.v1.MakePaymentResponse.Payment
 */
export class MakePaymentResponse_Payment extends Message<MakePaymentResponse_Payment> {
  /**
   * @generated from field: string payment_id = 10;
   */
  paymentId = "";

  constructor(data?: PartialMessage<MakePaymentResponse_Payment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "bank_payment.v1.MakePaymentResponse.Payment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "payment_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): MakePaymentResponse_Payment {
    return new MakePaymentResponse_Payment().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): MakePaymentResponse_Payment {
    return new MakePaymentResponse_Payment().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): MakePaymentResponse_Payment {
    return new MakePaymentResponse_Payment().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | MakePaymentResponse_Payment
      | PlainMessage<MakePaymentResponse_Payment>
      | undefined,
    b:
      | MakePaymentResponse_Payment
      | PlainMessage<MakePaymentResponse_Payment>
      | undefined
  ): boolean {
    return proto3.util.equals(MakePaymentResponse_Payment, a, b);
  }
}
