// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file wallet/v1/public_api.proto (package wallet.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { CryptoAccount, CryptoTransaction } from "./public_data_crypto_pb";
import { BankAccount, BankTransaction } from "./public_data_bank_pb";

/**
 * @generated from message wallet.v1.PingRequest
 */
export class PingRequest extends Message<PingRequest> {
  constructor(data?: PartialMessage<PingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.PingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): PingRequest {
    return new PingRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): PingRequest {
    return new PingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): PingRequest {
    return new PingRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: PingRequest | PlainMessage<PingRequest> | undefined,
    b: PingRequest | PlainMessage<PingRequest> | undefined
  ): boolean {
    return proto3.util.equals(PingRequest, a, b);
  }
}

/**
 * @generated from message wallet.v1.PingResponse
 */
export class PingResponse extends Message<PingResponse> {
  /**
   * @generated from field: string message = 10;
   */
  message = "";

  constructor(data?: PartialMessage<PingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.PingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): PingResponse {
    return new PingResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): PingResponse {
    return new PingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): PingResponse {
    return new PingResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: PingResponse | PlainMessage<PingResponse> | undefined,
    b: PingResponse | PlainMessage<PingResponse> | undefined
  ): boolean {
    return proto3.util.equals(PingResponse, a, b);
  }
}

/**
 * @generated from message wallet.v1.CreateCryptoAccountRequest
 */
export class CreateCryptoAccountRequest extends Message<CreateCryptoAccountRequest> {
  /**
   * mandatory
   *
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * mandatory
   *
   * @generated from field: string asset_id = 20;
   */
  assetId = "";

  constructor(data?: PartialMessage<CreateCryptoAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.CreateCryptoAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "asset_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): CreateCryptoAccountRequest {
    return new CreateCryptoAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): CreateCryptoAccountRequest {
    return new CreateCryptoAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CreateCryptoAccountRequest {
    return new CreateCryptoAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | CreateCryptoAccountRequest
      | PlainMessage<CreateCryptoAccountRequest>
      | undefined,
    b:
      | CreateCryptoAccountRequest
      | PlainMessage<CreateCryptoAccountRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(CreateCryptoAccountRequest, a, b);
  }
}

/**
 * @generated from message wallet.v1.CreateCryptoAccountResponse
 */
export class CreateCryptoAccountResponse extends Message<CreateCryptoAccountResponse> {
  /**
   * @generated from field: wallet.v1.CryptoAccount account = 10;
   */
  account?: CryptoAccount;

  constructor(data?: PartialMessage<CreateCryptoAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.CreateCryptoAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "account", kind: "message", T: CryptoAccount },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): CreateCryptoAccountResponse {
    return new CreateCryptoAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): CreateCryptoAccountResponse {
    return new CreateCryptoAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CreateCryptoAccountResponse {
    return new CreateCryptoAccountResponse().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | CreateCryptoAccountResponse
      | PlainMessage<CreateCryptoAccountResponse>
      | undefined,
    b:
      | CreateCryptoAccountResponse
      | PlainMessage<CreateCryptoAccountResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(CreateCryptoAccountResponse, a, b);
  }
}

/**
 * Get N bank transactions in reverse postedTime order, either starting from the most recent or,
 * if `before_id` is present, starting from the transaction immediately before the specified id.
 * The timeline ends whenever a request returns less than N, or 0 transactions.
 *
 * @generated from message wallet.v1.GetBankTransactionsRequest
 */
export class GetBankTransactionsRequest extends Message<GetBankTransactionsRequest> {
  /**
   * mandatory
   *
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * mandatory
   *
   * @generated from field: string account_id = 20;
   */
  accountId = "";

  /**
   * @generated from field: google.protobuf.Timestamp from = 40;
   */
  from?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp to = 50;
   */
  to?: Timestamp;

  /**
   * max 100
   *
   * @generated from field: int32 limit = 60;
   */
  limit = 0;

  constructor(data?: PartialMessage<GetBankTransactionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetBankTransactionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "account_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 40, name: "from", kind: "message", T: Timestamp },
    { no: 50, name: "to", kind: "message", T: Timestamp },
    { no: 60, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBankTransactionsRequest {
    return new GetBankTransactionsRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionsRequest {
    return new GetBankTransactionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionsRequest {
    return new GetBankTransactionsRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetBankTransactionsRequest
      | PlainMessage<GetBankTransactionsRequest>
      | undefined,
    b:
      | GetBankTransactionsRequest
      | PlainMessage<GetBankTransactionsRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(GetBankTransactionsRequest, a, b);
  }
}

/**
 * @generated from message wallet.v1.GetBankTransactionsResponse
 */
export class GetBankTransactionsResponse extends Message<GetBankTransactionsResponse> {
  /**
   * @generated from field: repeated wallet.v1.BankTransaction transactions = 10;
   */
  transactions: BankTransaction[] = [];

  constructor(data?: PartialMessage<GetBankTransactionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetBankTransactionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "transactions",
      kind: "message",
      T: BankTransaction,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBankTransactionsResponse {
    return new GetBankTransactionsResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionsResponse {
    return new GetBankTransactionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionsResponse {
    return new GetBankTransactionsResponse().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | GetBankTransactionsResponse
      | PlainMessage<GetBankTransactionsResponse>
      | undefined,
    b:
      | GetBankTransactionsResponse
      | PlainMessage<GetBankTransactionsResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(GetBankTransactionsResponse, a, b);
  }
}

/**
 * @generated from message wallet.v1.GetBankAccountsRequest
 */
export class GetBankAccountsRequest extends Message<GetBankAccountsRequest> {
  /**
   * @generated from field: string user_id = 10;
   */
  userId = "";

  constructor(data?: PartialMessage<GetBankAccountsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetBankAccountsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBankAccountsRequest {
    return new GetBankAccountsRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBankAccountsRequest {
    return new GetBankAccountsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBankAccountsRequest {
    return new GetBankAccountsRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetBankAccountsRequest
      | PlainMessage<GetBankAccountsRequest>
      | undefined,
    b: GetBankAccountsRequest | PlainMessage<GetBankAccountsRequest> | undefined
  ): boolean {
    return proto3.util.equals(GetBankAccountsRequest, a, b);
  }
}

/**
 * At the moment, you can expect a user to have a single account per currency.
 * However, it is important to store data on the client based on the id of the BankAccount, not the currency,
 * as in the future we might break the above rule.
 *
 * @generated from message wallet.v1.GetBankAccountsResponse
 */
export class GetBankAccountsResponse extends Message<GetBankAccountsResponse> {
  /**
   * @generated from field: repeated wallet.v1.BankAccount accounts = 10;
   */
  accounts: BankAccount[] = [];

  constructor(data?: PartialMessage<GetBankAccountsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetBankAccountsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "accounts",
      kind: "message",
      T: BankAccount,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBankAccountsResponse {
    return new GetBankAccountsResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBankAccountsResponse {
    return new GetBankAccountsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBankAccountsResponse {
    return new GetBankAccountsResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetBankAccountsResponse
      | PlainMessage<GetBankAccountsResponse>
      | undefined,
    b:
      | GetBankAccountsResponse
      | PlainMessage<GetBankAccountsResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(GetBankAccountsResponse, a, b);
  }
}

/**
 * @generated from message wallet.v1.GetBankAccountRequest
 */
export class GetBankAccountRequest extends Message<GetBankAccountRequest> {
  /**
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * @generated from field: string account_id = 20;
   */
  accountId = "";

  constructor(data?: PartialMessage<GetBankAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetBankAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "account_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBankAccountRequest {
    return new GetBankAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBankAccountRequest {
    return new GetBankAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBankAccountRequest {
    return new GetBankAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetBankAccountRequest | PlainMessage<GetBankAccountRequest> | undefined,
    b: GetBankAccountRequest | PlainMessage<GetBankAccountRequest> | undefined
  ): boolean {
    return proto3.util.equals(GetBankAccountRequest, a, b);
  }
}

/**
 * @generated from message wallet.v1.GetBankAccountResponse
 */
export class GetBankAccountResponse extends Message<GetBankAccountResponse> {
  /**
   * @generated from field: wallet.v1.BankAccount account = 10;
   */
  account?: BankAccount;

  constructor(data?: PartialMessage<GetBankAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetBankAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "account", kind: "message", T: BankAccount },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBankAccountResponse {
    return new GetBankAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBankAccountResponse {
    return new GetBankAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBankAccountResponse {
    return new GetBankAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetBankAccountResponse
      | PlainMessage<GetBankAccountResponse>
      | undefined,
    b: GetBankAccountResponse | PlainMessage<GetBankAccountResponse> | undefined
  ): boolean {
    return proto3.util.equals(GetBankAccountResponse, a, b);
  }
}

/**
 * @generated from message wallet.v1.GetCryptoAccountsRequest
 */
export class GetCryptoAccountsRequest extends Message<GetCryptoAccountsRequest> {
  /**
   * @generated from field: string user_id = 10;
   */
  userId = "";

  constructor(data?: PartialMessage<GetCryptoAccountsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetCryptoAccountsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetCryptoAccountsRequest {
    return new GetCryptoAccountsRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetCryptoAccountsRequest {
    return new GetCryptoAccountsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetCryptoAccountsRequest {
    return new GetCryptoAccountsRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetCryptoAccountsRequest
      | PlainMessage<GetCryptoAccountsRequest>
      | undefined,
    b:
      | GetCryptoAccountsRequest
      | PlainMessage<GetCryptoAccountsRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(GetCryptoAccountsRequest, a, b);
  }
}

/**
 * No error returned here, however keep in mind that an unauthorized code is returned
 * if the request's user id does not match the auth token holder.
 * At the moment, we keep a single balance per cryptocurrency.
 * However, it is important to store data on the client based on the id of the CryptoAccount, not the currency,
 * as in the future we might break the above rule.
 *
 * @generated from message wallet.v1.GetCryptoAccountsResponse
 */
export class GetCryptoAccountsResponse extends Message<GetCryptoAccountsResponse> {
  /**
   * @generated from field: repeated wallet.v1.CryptoAccount accounts = 10;
   */
  accounts: CryptoAccount[] = [];

  constructor(data?: PartialMessage<GetCryptoAccountsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetCryptoAccountsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "accounts",
      kind: "message",
      T: CryptoAccount,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetCryptoAccountsResponse {
    return new GetCryptoAccountsResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetCryptoAccountsResponse {
    return new GetCryptoAccountsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetCryptoAccountsResponse {
    return new GetCryptoAccountsResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetCryptoAccountsResponse
      | PlainMessage<GetCryptoAccountsResponse>
      | undefined,
    b:
      | GetCryptoAccountsResponse
      | PlainMessage<GetCryptoAccountsResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(GetCryptoAccountsResponse, a, b);
  }
}

/**
 * @generated from message wallet.v1.GetCryptoAccountRequest
 */
export class GetCryptoAccountRequest extends Message<GetCryptoAccountRequest> {
  /**
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * @generated from field: string account_id = 20;
   */
  accountId = "";

  constructor(data?: PartialMessage<GetCryptoAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetCryptoAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "account_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetCryptoAccountRequest {
    return new GetCryptoAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetCryptoAccountRequest {
    return new GetCryptoAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetCryptoAccountRequest {
    return new GetCryptoAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetCryptoAccountRequest
      | PlainMessage<GetCryptoAccountRequest>
      | undefined,
    b:
      | GetCryptoAccountRequest
      | PlainMessage<GetCryptoAccountRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(GetCryptoAccountRequest, a, b);
  }
}

/**
 * @generated from message wallet.v1.GetCryptoAccountResponse
 */
export class GetCryptoAccountResponse extends Message<GetCryptoAccountResponse> {
  /**
   * @generated from field: wallet.v1.CryptoAccount account = 10;
   */
  account?: CryptoAccount;

  constructor(data?: PartialMessage<GetCryptoAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetCryptoAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "account", kind: "message", T: CryptoAccount },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetCryptoAccountResponse {
    return new GetCryptoAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetCryptoAccountResponse {
    return new GetCryptoAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetCryptoAccountResponse {
    return new GetCryptoAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetCryptoAccountResponse
      | PlainMessage<GetCryptoAccountResponse>
      | undefined,
    b:
      | GetCryptoAccountResponse
      | PlainMessage<GetCryptoAccountResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(GetCryptoAccountResponse, a, b);
  }
}

/**
 * Get N crypto transactions in reverse postedTime order, either starting from the most recent or,
 * if `before_id` is present, starting from the transaction immediately before the specified id.
 * Eg: first response for N=3 is txId100, txId99, txId98. To keep scrolling in the past, the next request
 * should be with before_id = "txId98" and will return txId97, txId96, txId95.
 * The timeline ends whenever a request returns less than N, or 0 transactions.
 *
 * @generated from message wallet.v1.GetCryptoTransactionTimelineRequest
 */
export class GetCryptoTransactionTimelineRequest extends Message<GetCryptoTransactionTimelineRequest> {
  /**
   * mandatory
   *
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * mandatory
   *
   * @generated from field: string account_id = 20;
   */
  accountId = "";

  /**
   * @generated from field: string before_id = 40;
   */
  beforeId = "";

  /**
   * max 100
   *
   * @generated from field: int32 limit = 50;
   */
  limit = 0;

  constructor(data?: PartialMessage<GetCryptoTransactionTimelineRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetCryptoTransactionTimelineRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "account_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 40, name: "before_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 50, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetCryptoTransactionTimelineRequest {
    return new GetCryptoTransactionTimelineRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetCryptoTransactionTimelineRequest {
    return new GetCryptoTransactionTimelineRequest().fromJson(
      jsonValue,
      options
    );
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetCryptoTransactionTimelineRequest {
    return new GetCryptoTransactionTimelineRequest().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | GetCryptoTransactionTimelineRequest
      | PlainMessage<GetCryptoTransactionTimelineRequest>
      | undefined,
    b:
      | GetCryptoTransactionTimelineRequest
      | PlainMessage<GetCryptoTransactionTimelineRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(GetCryptoTransactionTimelineRequest, a, b);
  }
}

/**
 * @generated from message wallet.v1.GetCryptoTransactionTimelineResponse
 */
export class GetCryptoTransactionTimelineResponse extends Message<GetCryptoTransactionTimelineResponse> {
  /**
   * @generated from field: repeated wallet.v1.CryptoTransaction transactions = 10;
   */
  transactions: CryptoTransaction[] = [];

  constructor(data?: PartialMessage<GetCryptoTransactionTimelineResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetCryptoTransactionTimelineResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "transactions",
      kind: "message",
      T: CryptoTransaction,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetCryptoTransactionTimelineResponse {
    return new GetCryptoTransactionTimelineResponse().fromBinary(
      bytes,
      options
    );
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetCryptoTransactionTimelineResponse {
    return new GetCryptoTransactionTimelineResponse().fromJson(
      jsonValue,
      options
    );
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetCryptoTransactionTimelineResponse {
    return new GetCryptoTransactionTimelineResponse().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | GetCryptoTransactionTimelineResponse
      | PlainMessage<GetCryptoTransactionTimelineResponse>
      | undefined,
    b:
      | GetCryptoTransactionTimelineResponse
      | PlainMessage<GetCryptoTransactionTimelineResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(GetCryptoTransactionTimelineResponse, a, b);
  }
}

/**
 * Get N bank transactions in reverse postedTime order, either starting from the most recent or,
 * if `before_id` is present, starting from the transaction immediately before the specified id.
 * The timeline ends whenever a request returns less than N, or 0 transactions.
 *
 * @generated from message wallet.v1.GetBankTransactionTimelineRequest
 */
export class GetBankTransactionTimelineRequest extends Message<GetBankTransactionTimelineRequest> {
  /**
   * mandatory
   *
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * mandatory
   *
   * @generated from field: string account_id = 20;
   */
  accountId = "";

  /**
   * @generated from field: string before_id = 40;
   */
  beforeId = "";

  /**
   * max 100
   *
   * @generated from field: int32 limit = 50;
   */
  limit = 0;

  constructor(data?: PartialMessage<GetBankTransactionTimelineRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetBankTransactionTimelineRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "account_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 40, name: "before_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 50, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBankTransactionTimelineRequest {
    return new GetBankTransactionTimelineRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionTimelineRequest {
    return new GetBankTransactionTimelineRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionTimelineRequest {
    return new GetBankTransactionTimelineRequest().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | GetBankTransactionTimelineRequest
      | PlainMessage<GetBankTransactionTimelineRequest>
      | undefined,
    b:
      | GetBankTransactionTimelineRequest
      | PlainMessage<GetBankTransactionTimelineRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(GetBankTransactionTimelineRequest, a, b);
  }
}

/**
 * @generated from message wallet.v1.GetBankTransactionTimelineResponse
 */
export class GetBankTransactionTimelineResponse extends Message<GetBankTransactionTimelineResponse> {
  /**
   * @generated from field: repeated wallet.v1.BankTransaction transactions = 10;
   */
  transactions: BankTransaction[] = [];

  constructor(data?: PartialMessage<GetBankTransactionTimelineResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetBankTransactionTimelineResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "transactions",
      kind: "message",
      T: BankTransaction,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBankTransactionTimelineResponse {
    return new GetBankTransactionTimelineResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionTimelineResponse {
    return new GetBankTransactionTimelineResponse().fromJson(
      jsonValue,
      options
    );
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionTimelineResponse {
    return new GetBankTransactionTimelineResponse().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | GetBankTransactionTimelineResponse
      | PlainMessage<GetBankTransactionTimelineResponse>
      | undefined,
    b:
      | GetBankTransactionTimelineResponse
      | PlainMessage<GetBankTransactionTimelineResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(GetBankTransactionTimelineResponse, a, b);
  }
}

/**
 * Get N transaction updates in the order they were processed in our backend.
 * Or queues do not have any ordering guarantees, to ensure maximum performance.
 * This means that, occasionally, a transaction event will be out of order.
 * For any given transaction, there might be multiple events, such as multiple state transitions.
 * When updating your local transaction data, don't forget to use the updatedTime to determine
 * whether the information you already have is newer and should not be overwritten.
 * Transactions carry a lot of information, typically only state and amount will change, but we thought it's
 * best if each event carries the whole snapshot of a transaction, rather than just a diff, so clients
 * only need to overwrite their records.
 *
 * If after_id is empty, it will return up to N events from when the account was created, or at least the oldest data
 * we keep on record. From that point, the client can keep iterating through events until present time, by passing
 * the after_id parameter. When starting from a fresh app install, it's advisable to make a timeline call first,
 * populate your local database with some recent transactions, and then start consuming events from the most recent
 * transaction's event ID. And only consume older timelines if the user scrolls down.
 *
 * Example of how this works: first request with N=3 returns txEvt01, txEvt02, txEvt03.
 * Second request should have after_id="txEvt03" and will return txEvt04, txEvt05, txEvt06.
 * An empty response means there has been no event since the last on the client synced.
 *
 * @generated from message wallet.v1.GetCryptoTransactionEventsRequest
 */
export class GetCryptoTransactionEventsRequest extends Message<GetCryptoTransactionEventsRequest> {
  /**
   * mandatory
   *
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * optional, fetch events after the given event id
   *
   * @generated from field: string after_id = 20;
   */
  afterId = "";

  /**
   * max 1000
   *
   * @generated from field: int32 limit = 30;
   */
  limit = 0;

  constructor(data?: PartialMessage<GetCryptoTransactionEventsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetCryptoTransactionEventsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "after_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetCryptoTransactionEventsRequest {
    return new GetCryptoTransactionEventsRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetCryptoTransactionEventsRequest {
    return new GetCryptoTransactionEventsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetCryptoTransactionEventsRequest {
    return new GetCryptoTransactionEventsRequest().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | GetCryptoTransactionEventsRequest
      | PlainMessage<GetCryptoTransactionEventsRequest>
      | undefined,
    b:
      | GetCryptoTransactionEventsRequest
      | PlainMessage<GetCryptoTransactionEventsRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(GetCryptoTransactionEventsRequest, a, b);
  }
}

/**
 * @generated from message wallet.v1.GetCryptoTransactionEventsResponse
 */
export class GetCryptoTransactionEventsResponse extends Message<GetCryptoTransactionEventsResponse> {
  /**
   * @generated from field: repeated wallet.v1.CryptoTransaction transactions = 10;
   */
  transactions: CryptoTransaction[] = [];

  constructor(data?: PartialMessage<GetCryptoTransactionEventsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetCryptoTransactionEventsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "transactions",
      kind: "message",
      T: CryptoTransaction,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetCryptoTransactionEventsResponse {
    return new GetCryptoTransactionEventsResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetCryptoTransactionEventsResponse {
    return new GetCryptoTransactionEventsResponse().fromJson(
      jsonValue,
      options
    );
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetCryptoTransactionEventsResponse {
    return new GetCryptoTransactionEventsResponse().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | GetCryptoTransactionEventsResponse
      | PlainMessage<GetCryptoTransactionEventsResponse>
      | undefined,
    b:
      | GetCryptoTransactionEventsResponse
      | PlainMessage<GetCryptoTransactionEventsResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(GetCryptoTransactionEventsResponse, a, b);
  }
}

/**
 * An empty response means there has been no event since the last on the client synced.
 *
 * @generated from message wallet.v1.GetBankTransactionEventsRequest
 */
export class GetBankTransactionEventsRequest extends Message<GetBankTransactionEventsRequest> {
  /**
   * mandatory
   *
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * optional, fetch events after the given event id
   *
   * @generated from field: string after_id = 20;
   */
  afterId = "";

  /**
   * max 1000
   *
   * @generated from field: int32 limit = 30;
   */
  limit = 0;

  constructor(data?: PartialMessage<GetBankTransactionEventsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetBankTransactionEventsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "after_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBankTransactionEventsRequest {
    return new GetBankTransactionEventsRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionEventsRequest {
    return new GetBankTransactionEventsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionEventsRequest {
    return new GetBankTransactionEventsRequest().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | GetBankTransactionEventsRequest
      | PlainMessage<GetBankTransactionEventsRequest>
      | undefined,
    b:
      | GetBankTransactionEventsRequest
      | PlainMessage<GetBankTransactionEventsRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(GetBankTransactionEventsRequest, a, b);
  }
}

/**
 * @generated from message wallet.v1.GetBankTransactionEventsResponse
 */
export class GetBankTransactionEventsResponse extends Message<GetBankTransactionEventsResponse> {
  /**
   * @generated from field: repeated wallet.v1.BankTransaction transactions = 10;
   */
  transactions: BankTransaction[] = [];

  constructor(data?: PartialMessage<GetBankTransactionEventsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.GetBankTransactionEventsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "transactions",
      kind: "message",
      T: BankTransaction,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetBankTransactionEventsResponse {
    return new GetBankTransactionEventsResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionEventsResponse {
    return new GetBankTransactionEventsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetBankTransactionEventsResponse {
    return new GetBankTransactionEventsResponse().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | GetBankTransactionEventsResponse
      | PlainMessage<GetBankTransactionEventsResponse>
      | undefined,
    b:
      | GetBankTransactionEventsResponse
      | PlainMessage<GetBankTransactionEventsResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(GetBankTransactionEventsResponse, a, b);
  }
}
