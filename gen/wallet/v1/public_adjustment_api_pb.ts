// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file wallet/v1/public_adjustment_api.proto (package wallet.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Empty, Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message wallet.v1.AdjustBalanceRequest
 */
export class AdjustBalanceRequest extends Message<AdjustBalanceRequest> {
  /**
   * the password is required to prevent accidental calls to this API
   *
   * @generated from field: string password = 10;
   */
  password = "";

  /**
   * this key is also used as transaction_id in the ledger API
   *
   * @generated from field: string idempotency_key = 20;
   */
  idempotencyKey = "";

  /**
   * @generated from field: string reason = 30;
   */
  reason = "";

  /**
   * @generated from field: string description = 40;
   */
  description = "";

  /**
   * List of entries part of this transaction, the sum of which needs to be zero.
   *
   * @generated from field: repeated wallet.v1.EntryInput entries = 50;
   */
  entries: EntryInput[] = [];

  constructor(data?: PartialMessage<AdjustBalanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.AdjustBalanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "idempotency_key",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 30, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 40,
      name: "description",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 50, name: "entries", kind: "message", T: EntryInput, repeated: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AdjustBalanceRequest {
    return new AdjustBalanceRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AdjustBalanceRequest {
    return new AdjustBalanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AdjustBalanceRequest {
    return new AdjustBalanceRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: AdjustBalanceRequest | PlainMessage<AdjustBalanceRequest> | undefined,
    b: AdjustBalanceRequest | PlainMessage<AdjustBalanceRequest> | undefined
  ): boolean {
    return proto3.util.equals(AdjustBalanceRequest, a, b);
  }
}

/**
 * @generated from message wallet.v1.EntryInput
 */
export class EntryInput extends Message<EntryInput> {
  /**
   * The account on which this entry is debited/credited
   *
   * @generated from field: wallet.v1.AccountID account_id = 10;
   */
  accountId?: AccountID;

  /**
   * Amount debited/credited to the account, represented as a floating-point string (eg: -12.3)
   *
   * @generated from field: string amount = 20;
   */
  amount = "";

  /**
   * If any of these is present and violated, the entry will be rejected
   *
   * @generated from field: wallet.v1.BalanceConstraints balance_constraints = 30;
   */
  balanceConstraints?: BalanceConstraints;

  /**
   * whether to add this entry to the user's timeline or not
   *
   * @generated from field: bool add_to_timeline = 40;
   */
  addToTimeline = false;

  /**
   * Set this to true to only append the transaction to the ledger if the account exists.
   * This is a great protection against typo's in the account name.
   *
   * @generated from field: bool must_exist = 60;
   */
  mustExist = false;

  constructor(data?: PartialMessage<EntryInput>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.EntryInput";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "account_id", kind: "message", T: AccountID },
    { no: 20, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 30,
      name: "balance_constraints",
      kind: "message",
      T: BalanceConstraints,
    },
    {
      no: 40,
      name: "add_to_timeline",
      kind: "scalar",
      T: 8 /* ScalarType.BOOL */,
    },
    { no: 60, name: "must_exist", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): EntryInput {
    return new EntryInput().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): EntryInput {
    return new EntryInput().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): EntryInput {
    return new EntryInput().fromJsonString(jsonString, options);
  }

  static equals(
    a: EntryInput | PlainMessage<EntryInput> | undefined,
    b: EntryInput | PlainMessage<EntryInput> | undefined
  ): boolean {
    return proto3.util.equals(EntryInput, a, b);
  }
}

/**
 * @generated from message wallet.v1.BalanceConstraints
 */
export class BalanceConstraints extends Message<BalanceConstraints> {
  /**
   * @generated from field: optional string min_bal = 10;
   */
  minBal?: string;

  /**
   * @generated from field: optional string max_bal = 20;
   */
  maxBal?: string;

  constructor(data?: PartialMessage<BalanceConstraints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.BalanceConstraints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "min_bal",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      opt: true,
    },
    {
      no: 20,
      name: "max_bal",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      opt: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): BalanceConstraints {
    return new BalanceConstraints().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): BalanceConstraints {
    return new BalanceConstraints().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): BalanceConstraints {
    return new BalanceConstraints().fromJsonString(jsonString, options);
  }

  static equals(
    a: BalanceConstraints | PlainMessage<BalanceConstraints> | undefined,
    b: BalanceConstraints | PlainMessage<BalanceConstraints> | undefined
  ): boolean {
    return proto3.util.equals(BalanceConstraints, a, b);
  }
}

/**
 * Uniquely identifies an account.
 * Eg: user/
 *
 * @generated from message wallet.v1.AccountID
 */
export class AccountID extends Message<AccountID> {
  /**
   * Account owner is either user (identified by their ID) or system.
   *
   * @generated from oneof wallet.v1.AccountID.owner
   */
  owner:
    | {
        /**
         * @generated from field: string user_id = 10;
         */
        value: string;
        case: "userId";
      }
    | {
        /**
         * @generated from field: google.protobuf.Empty system = 20;
         */
        value: Empty;
        case: "system";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * A string representation of the account_type enum from the ledger API.
   *
   * @generated from field: string account_type = 30;
   */
  accountType = "";

  /**
   * The account name is just a way of differentiating multiple accounts of the same asset, for the same owner.
   * This might be true for users, who might potentially have multiple GBP accounts, but also for system accounts,
   * as we might need multiple crypto withdrawals wallets.
   * An empty name is allowed in absence of a use case for multiple accounts, and they can always be added later by
   * introducing sequential numbers or UUIDs or anything else, to distinguish them.
   *
   * @generated from field: string account_name = 40;
   */
  accountName = "";

  /**
   * @generated from field: string asset_id = 50;
   */
  assetId = "";

  constructor(data?: PartialMessage<AccountID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.AccountID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "user_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      oneof: "owner",
    },
    { no: 20, name: "system", kind: "message", T: Empty, oneof: "owner" },
    {
      no: 30,
      name: "account_type",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 40,
      name: "account_name",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 50, name: "asset_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AccountID {
    return new AccountID().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AccountID {
    return new AccountID().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AccountID {
    return new AccountID().fromJsonString(jsonString, options);
  }

  static equals(
    a: AccountID | PlainMessage<AccountID> | undefined,
    b: AccountID | PlainMessage<AccountID> | undefined
  ): boolean {
    return proto3.util.equals(AccountID, a, b);
  }
}

/**
 * @generated from message wallet.v1.AdjustBalanceResponse
 */
export class AdjustBalanceResponse extends Message<AdjustBalanceResponse> {
  constructor(data?: PartialMessage<AdjustBalanceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.AdjustBalanceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AdjustBalanceResponse {
    return new AdjustBalanceResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AdjustBalanceResponse {
    return new AdjustBalanceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AdjustBalanceResponse {
    return new AdjustBalanceResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: AdjustBalanceResponse | PlainMessage<AdjustBalanceResponse> | undefined,
    b: AdjustBalanceResponse | PlainMessage<AdjustBalanceResponse> | undefined
  ): boolean {
    return proto3.util.equals(AdjustBalanceResponse, a, b);
  }
}
