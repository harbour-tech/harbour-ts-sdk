// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file wallet/v1/public_data_bank.proto (package wallet.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Empty, Message, proto3 } from "@bufbuild/protobuf";
import {
  Balance,
  CardTransactionDetails,
  TransactionTime,
} from "./public_data_common_pb";
import {
  BankPaymentDetails,
  BankTransactionFailReason,
  BankTransactionState,
  BankTransactionType,
  IBANAccountIdentifier,
  UkAccountIdentifier,
} from "./bank_common_pb";

/**
 * @generated from enum wallet.v1.DirectDebitRoute
 */
export enum DirectDebitRoute {
  /**
   * @generated from enum value: DIRECT_DEBIT_ROUTE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * uk direct debits
   *
   * @generated from enum value: DIRECT_DEBIT_ROUTE_UK_DD = 1;
   */
  UK_DD = 1,

  /**
   * sepa direct debit
   *
   * @generated from enum value: DIRECT_DEBIT_ROUTE_SEPA_DD = 2;
   */
  SEPA_DD = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(DirectDebitRoute)
proto3.util.setEnumType(DirectDebitRoute, "wallet.v1.DirectDebitRoute", [
  { no: 0, name: "DIRECT_DEBIT_ROUTE_UNSPECIFIED" },
  { no: 1, name: "DIRECT_DEBIT_ROUTE_UK_DD" },
  { no: 2, name: "DIRECT_DEBIT_ROUTE_SEPA_DD" },
]);

/**
 * This is a fiat money account.
 * There's a bunch of different types of accounts in a traditional bank: current accounts, savings accounts, etc.
 * For the time being we only have current accounts.
 *
 * @generated from message wallet.v1.BankAccount
 */
export class BankAccount extends Message<BankAccount> {
  /**
   * @generated from field: string id = 10;
   */
  id = "";

  /**
   * The name of the account.
   * Allows to distinguish multiple accounts of the same currency.
   * A customer's main account is always called "default".
   *
   * @generated from field: string name = 11;
   */
  name = "";

  /**
   * @generated from field: wallet.v1.Balance balance = 20;
   */
  balance?: Balance;

  /**
   * Three letter ISO-4217 currency code, see https://en.wikipedia.org/wiki/ISO_4217
   * The client is responsible for picking a library that exposes decimal precision for the given currency.
   *
   * @generated from field: string currency = 30;
   */
  currency = "";

  /**
   * Example: $ or € or £
   *
   * @generated from field: string currency_symbol = 31;
   */
  currencySymbol = "";

  /**
   * Identifier for domestic UK payments in GBP, always present on all GBP accounts
   *
   * @generated from field: wallet.v1.UkAccountIdentifier uk_local_id = 40;
   */
  ukLocalId?: UkAccountIdentifier;

  /**
   * Identifier for international SWIFT payments, present on all accounts.
   *
   * @generated from field: wallet.v1.IBANAccountIdentifier international_id = 50;
   */
  internationalId?: IBANAccountIdentifier;

  /**
   * Identifier for euro-zone SEPA payments, only present in EUR accounts,
   * likely, but not necessarily, the same as international_id.
   *
   * @generated from field: wallet.v1.IBANAccountIdentifier sepa_id = 60;
   */
  sepaId?: IBANAccountIdentifier;

  constructor(data?: PartialMessage<BankAccount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.BankAccount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "balance", kind: "message", T: Balance },
    { no: 30, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 31,
      name: "currency_symbol",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 40, name: "uk_local_id", kind: "message", T: UkAccountIdentifier },
    {
      no: 50,
      name: "international_id",
      kind: "message",
      T: IBANAccountIdentifier,
    },
    { no: 60, name: "sepa_id", kind: "message", T: IBANAccountIdentifier },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): BankAccount {
    return new BankAccount().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): BankAccount {
    return new BankAccount().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): BankAccount {
    return new BankAccount().fromJsonString(jsonString, options);
  }

  static equals(
    a: BankAccount | PlainMessage<BankAccount> | undefined,
    b: BankAccount | PlainMessage<BankAccount> | undefined
  ): boolean {
    return proto3.util.equals(BankAccount, a, b);
  }
}

/**
 * @generated from message wallet.v1.BankTransaction
 */
export class BankTransaction extends Message<BankTransaction> {
  /**
   * @generated from field: string id = 10;
   */
  id = "";

  /**
   * Client needs to know which account this transaction belongs to, as our endpoints support
   * returning transactions for all accounts.
   * Specifying the currency won't be necessary, as the client can infer from the account.
   * It's best to always synchronize transactions right after having synchronized accounts,
   * to avoid ending up with a tx referencing an unknown account_id.
   *
   * @generated from field: string account_id = 11;
   */
  accountId = "";

  /**
   * @generated from field: string event_id = 12;
   */
  eventId = "";

  /**
   * eg: 500 net amount, 1 fee amount = 501 total
   *
   * @generated from field: string total_amount = 20;
   */
  totalAmount = "";

  /**
   * @generated from field: string net_amount = 21;
   */
  netAmount = "";

  /**
   * @generated from field: string fee_amount = 22;
   */
  feeAmount = "";

  /**
   * if this is an exchange transaction, the following fields will contain the exchanged amount and asset
   *
   * @generated from field: string exchange_amount = 24;
   */
  exchangeAmount = "";

  /**
   * @generated from field: string exchange_asset = 25;
   */
  exchangeAsset = "";

  /**
   * @generated from field: wallet.v1.BankTransactionState state = 30;
   */
  state = BankTransactionState.UNSPECIFIED;

  /**
   * check this enum if state = REJECTED or FAILED
   *
   * @generated from field: wallet.v1.BankTransactionFailReason fail_reason = 31;
   */
  failReason = BankTransactionFailReason.UNSPECIFIED;

  /**
   * @generated from field: wallet.v1.BankTransactionType type = 40;
   */
  type = BankTransactionType.UNSPECIFIED;

  /**
   * This will contain the merchant name for card spends, the beneficiary name for outgoing payments and direct debits,
   * the payer name for incoming payments, the counterparty account name for transfers/FX, or some description
   * about the ATM or cash operation.
   * At the moment there are no guarantees in length, make sure to truncate on clients when displaying.
   *
   * @generated from field: string description = 60;
   */
  description = "";

  /**
   * @generated from field: wallet.v1.TransactionTime time = 70;
   */
  time?: TransactionTime;

  /**
   * @generated from oneof wallet.v1.BankTransaction.details
   */
  details:
    | {
        /**
         * in case it's none of the below
         *
         * @generated from field: google.protobuf.Empty empty_details = 99;
         */
        value: Empty;
        case: "emptyDetails";
      }
    | {
        /**
         * only present if type=BANK_TRANSACTION_TYPE_PAYMENT or =BANK_TRANSACTION_TYPE_TRANSFER
         *
         * @generated from field: wallet.v1.BankPaymentDetails bank_payment_details = 100;
         */
        value: BankPaymentDetails;
        case: "bankPaymentDetails";
      }
    | {
        /**
         * only present if it's a card transaction
         *
         * @generated from field: wallet.v1.CardTransactionDetails card_tx_details = 110;
         */
        value: CardTransactionDetails;
        case: "cardTxDetails";
      }
    | {
        /**
         * only present if it's a direct debit
         *
         * @generated from field: wallet.v1.DirectDebitDetails direct_debit_details = 120;
         */
        value: DirectDebitDetails;
        case: "directDebitDetails";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BankTransaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.BankTransaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 11,
      name: "account_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 12, name: "event_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "total_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 21,
      name: "net_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 22,
      name: "fee_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 24,
      name: "exchange_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 25,
      name: "exchange_asset",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 30,
      name: "state",
      kind: "enum",
      T: proto3.getEnumType(BankTransactionState),
    },
    {
      no: 31,
      name: "fail_reason",
      kind: "enum",
      T: proto3.getEnumType(BankTransactionFailReason),
    },
    {
      no: 40,
      name: "type",
      kind: "enum",
      T: proto3.getEnumType(BankTransactionType),
    },
    {
      no: 60,
      name: "description",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 70, name: "time", kind: "message", T: TransactionTime },
    {
      no: 99,
      name: "empty_details",
      kind: "message",
      T: Empty,
      oneof: "details",
    },
    {
      no: 100,
      name: "bank_payment_details",
      kind: "message",
      T: BankPaymentDetails,
      oneof: "details",
    },
    {
      no: 110,
      name: "card_tx_details",
      kind: "message",
      T: CardTransactionDetails,
      oneof: "details",
    },
    {
      no: 120,
      name: "direct_debit_details",
      kind: "message",
      T: DirectDebitDetails,
      oneof: "details",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): BankTransaction {
    return new BankTransaction().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): BankTransaction {
    return new BankTransaction().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): BankTransaction {
    return new BankTransaction().fromJsonString(jsonString, options);
  }

  static equals(
    a: BankTransaction | PlainMessage<BankTransaction> | undefined,
    b: BankTransaction | PlainMessage<BankTransaction> | undefined
  ): boolean {
    return proto3.util.equals(BankTransaction, a, b);
  }
}

/**
 * not much use for backend, mainly used to facilitate client code
 *
 * @generated from message wallet.v1.BankTransactions
 */
export class BankTransactions extends Message<BankTransactions> {
  /**
   * @generated from field: repeated wallet.v1.BankTransaction transactions = 1;
   */
  transactions: BankTransaction[] = [];

  constructor(data?: PartialMessage<BankTransactions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.BankTransactions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "transactions",
      kind: "message",
      T: BankTransaction,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): BankTransactions {
    return new BankTransactions().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): BankTransactions {
    return new BankTransactions().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): BankTransactions {
    return new BankTransactions().fromJsonString(jsonString, options);
  }

  static equals(
    a: BankTransactions | PlainMessage<BankTransactions> | undefined,
    b: BankTransactions | PlainMessage<BankTransactions> | undefined
  ): boolean {
    return proto3.util.equals(BankTransactions, a, b);
  }
}

/**
 * @generated from message wallet.v1.DirectDebitDetails
 */
export class DirectDebitDetails extends Message<DirectDebitDetails> {
  /**
   * not sure if there's any additional info we can show, probably not
   *
   * @generated from field: wallet.v1.DirectDebitRoute route = 10;
   */
  route = DirectDebitRoute.UNSPECIFIED;

  constructor(data?: PartialMessage<DirectDebitDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.DirectDebitDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "route",
      kind: "enum",
      T: proto3.getEnumType(DirectDebitRoute),
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): DirectDebitDetails {
    return new DirectDebitDetails().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): DirectDebitDetails {
    return new DirectDebitDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): DirectDebitDetails {
    return new DirectDebitDetails().fromJsonString(jsonString, options);
  }

  static equals(
    a: DirectDebitDetails | PlainMessage<DirectDebitDetails> | undefined,
    b: DirectDebitDetails | PlainMessage<DirectDebitDetails> | undefined
  ): boolean {
    return proto3.util.equals(DirectDebitDetails, a, b);
  }
}
