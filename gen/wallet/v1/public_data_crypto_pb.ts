// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file wallet/v1/public_data_crypto.proto (package wallet.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Empty, Message, proto3 } from "@bufbuild/protobuf";
import {
  Balance,
  CardTransactionDetails,
  TransactionTime,
} from "./public_data_common_pb";

/**
 * @generated from enum wallet.v1.CryptoTransactionState
 */
export enum CryptoTransactionState {
  /**
   * @generated from enum value: CRYPTO_TRANSACTION_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Only happens for payments initiated by the client.
   * State is initialised as soon as it is submitted, but might be later rejected for many reasons
   * (insufficient funds, compliance, fraud, velocity limits).
   * Probably best not to show on customer UI until it transitions to PENDING
   *
   * @generated from enum value: CRYPTO_TRANSACTION_STATE_INITIALISED = 10;
   */
  INITIALISED = 10,

  /**
   * This is a transaction that passed initial validation and is now pending to be processed.
   * It is important to note that these transactions are an abstraction layer built for the end-user and
   * do not map 1:1 with on-chain or ledger transactions.
   * For instance, satisfying a withdrawal request might require an internal ledger transfer plus an on-chain transaction.
   * So this PENDING state is a generic intermediate state which can run from a few instants to several hours
   * depending on the underlying operations and speed of broadcasting on the blockchain.
   *
   * @generated from enum value: CRYPTO_TRANSACTION_STATE_PENDING = 20;
   */
  PENDING = 20,

  /**
   * All actions required for clearing this transaction have been performed and, if on-chain transactions were involved,
   * the counterparty should have confirmed funds.
   *
   * @generated from enum value: CRYPTO_TRANSACTION_STATE_CLEARED = 30;
   */
  CLEARED = 30,

  /**
   * Transaction was rejected, typically insufficient balance, fraud or velocity limits. Also a final state.
   * Again, should never be altered once rejected, but do allow overwrites just in case.
   *
   * @generated from enum value: CRYPTO_TRANSACTION_STATE_REJECTED = 40;
   */
  REJECTED = 40,

  /**
   * A transaction failed for technical reasons rather than being rejected. Also a final state.
   * Again, should never be altered once rejected, but do allow overwrites just in case.
   *
   * @generated from enum value: CRYPTO_TRANSACTION_STATE_FAILED = 50;
   */
  FAILED = 50,

  /**
   * A card authorisation was cancelled. This is a final state.
   * This happens when a card authorisation is fully reversed.
   *
   * @generated from enum value: CRYPTO_TRANSACTION_STATE_CANCELLED = 60;
   */
  CANCELLED = 60,

  /**
   * A card transaction was declined by the merchant. This is a final state.
   *
   * @generated from enum value: CRYPTO_TRANSACTION_STATE_DECLINED = 70;
   */
  DECLINED = 70,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoTransactionState)
proto3.util.setEnumType(
  CryptoTransactionState,
  "wallet.v1.CryptoTransactionState",
  [
    { no: 0, name: "CRYPTO_TRANSACTION_STATE_UNSPECIFIED" },
    { no: 10, name: "CRYPTO_TRANSACTION_STATE_INITIALISED" },
    { no: 20, name: "CRYPTO_TRANSACTION_STATE_PENDING" },
    { no: 30, name: "CRYPTO_TRANSACTION_STATE_CLEARED" },
    { no: 40, name: "CRYPTO_TRANSACTION_STATE_REJECTED" },
    { no: 50, name: "CRYPTO_TRANSACTION_STATE_FAILED" },
    { no: 60, name: "CRYPTO_TRANSACTION_STATE_CANCELLED" },
    { no: 70, name: "CRYPTO_TRANSACTION_STATE_DECLINED" },
  ]
);

/**
 * @generated from enum wallet.v1.CryptoTransactionType
 */
export enum CryptoTransactionType {
  /**
   * @generated from enum value: CRYPTO_TRANSACTION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Someone transferred funds on-chain to the user's deposit address
   *
   * @generated from enum value: CRYPTO_TRANSACTION_TYPE_DEPOSIT = 10;
   */
  DEPOSIT = 10,

  /**
   * User transferred money out of their account to a blockchain address
   *
   * @generated from enum value: CRYPTO_TRANSACTION_TYPE_WITHDRAWAL = 20;
   */
  WITHDRAWAL = 20,

  /**
   * An amount was debited or credited to this account as part of a currency conversion
   * Either crypto/crypt or fiat/crypto
   *
   * @generated from enum value: CRYPTO_TRANSACTION_TYPE_EXCHANGE = 30;
   */
  EXCHANGE = 30,

  /**
   * Funds have been transferred between Harbour accounts rather than going on-chain.
   * Could be a transfer between user's own wallets or between different users
   *
   * @generated from enum value: CRYPTO_TRANSACTION_TYPE_TRANSFER = 40;
   */
  TRANSFER = 40,

  /**
   * Normally any fees are included in a transaction's gross amount.
   * However, it is still good to have a fee type, who knows, maybe in the future there will be subscription
   * plans that can be paid in crypto.
   *
   * @generated from enum value: CRYPTO_TRANSACTION_TYPE_FEE = 50;
   */
  FEE = 50,

  /**
   * Any kind of card transaction
   *
   * @generated from enum value: CRYPTO_TRANSACTION_TYPE_CARD = 60;
   */
  CARD = 60,

  /**
   * Any ATM transaction
   *
   * @generated from enum value: CRYPTO_TRANSACTION_TYPE_ATM = 70;
   */
  ATM = 70,

  /**
   * Other kind of transaction. Two examples of when this could happen:
   * Our staff amends a ledger manually because of an error or any other internal operation.
   * A new type has being added and older RPC versions are adapted to convert to this type,
   * whereas new RPC versions will expose the correct type.
   * This helps avoid breaking outdated client apps.
   *
   * @generated from enum value: CRYPTO_TRANSACTION_TYPE_OTHER = 1000;
   */
  OTHER = 1000,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoTransactionType)
proto3.util.setEnumType(
  CryptoTransactionType,
  "wallet.v1.CryptoTransactionType",
  [
    { no: 0, name: "CRYPTO_TRANSACTION_TYPE_UNSPECIFIED" },
    { no: 10, name: "CRYPTO_TRANSACTION_TYPE_DEPOSIT" },
    { no: 20, name: "CRYPTO_TRANSACTION_TYPE_WITHDRAWAL" },
    { no: 30, name: "CRYPTO_TRANSACTION_TYPE_EXCHANGE" },
    { no: 40, name: "CRYPTO_TRANSACTION_TYPE_TRANSFER" },
    { no: 50, name: "CRYPTO_TRANSACTION_TYPE_FEE" },
    { no: 60, name: "CRYPTO_TRANSACTION_TYPE_CARD" },
    { no: 70, name: "CRYPTO_TRANSACTION_TYPE_ATM" },
    { no: 1000, name: "CRYPTO_TRANSACTION_TYPE_OTHER" },
  ]
);

/**
 * @generated from enum wallet.v1.CryptoTransactionFailReason
 */
export enum CryptoTransactionFailReason {
  /**
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_INSUFFICIENT_BALANCE = 10;
   */
  INSUFFICIENT_BALANCE = 10,

  /**
   * Failed due to limits on account. Example: max balance, max daily or monthly withdrawals.
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_LIMITS = 20;
   */
  LIMITS = 20,

  /**
   * Failed because of screening. Example: destination address is detected as involved in fraud.
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_SCREENING = 30;
   */
  SCREENING = 30,

  /**
   * Failed because the amount is smaller than the minimum allowed
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_MIN_AMOUNT = 40;
   */
  MIN_AMOUNT = 40,

  /**
   * Insufficient amount to pay for fees on the account
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_FEES = 50;
   */
  FEES = 50,

  /**
   * Network error
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_NETWORK = 60;
   */
  NETWORK = 60,

  /**
   * Eg: wrong PIN at POS, or wrong CVV at online merchant.
   * Hopefully we are able to get a more detailed error (see following), but not all card processors support it,
   * so we might fall back to this one.
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_INVALID_CARD_DETAILS = 80;
   */
  INVALID_CARD_DETAILS = 80,

  /**
   * Wrong PIN at POS/ATM
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_WRONG_CARD_PIN = 90;
   */
  WRONG_CARD_PIN = 90,

  /**
   * Wrong CVV when paying online
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_WRONG_CARD_CVV = 100;
   */
  WRONG_CARD_CVV = 100,

  /**
   * Wrong expiry date paying online
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_WRONG_CARD_EXPIRY_DATE = 110;
   */
  WRONG_CARD_EXPIRY_DATE = 110,

  /**
   * Failed 3D-secure challenge while paying online
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_FAILED_3DS = 120;
   */
  FAILED_3DS = 120,

  /**
   * Card expired
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_FAILED_CARD_EXPIRED = 130;
   */
  FAILED_CARD_EXPIRED = 130,

  /**
   * Card got deactivated by user
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_FAILED_CARD_INACTIVE = 140;
   */
  FAILED_CARD_INACTIVE = 140,

  /**
   * An unexpected error happened and our backend wasn't able to process this tx
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_SERVER_ERROR = 500;
   */
  SERVER_ERROR = 500,

  /**
   * If we add new elements to this enum, handlers should convert them to this type to avoid breaking clients
   *
   * @generated from enum value: CRYPTO_TRANSACTION_FAIL_REASON_UNKNOWN = 1000;
   */
  UNKNOWN = 1000,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoTransactionFailReason)
proto3.util.setEnumType(
  CryptoTransactionFailReason,
  "wallet.v1.CryptoTransactionFailReason",
  [
    { no: 0, name: "CRYPTO_TRANSACTION_FAIL_REASON_UNSPECIFIED" },
    { no: 10, name: "CRYPTO_TRANSACTION_FAIL_REASON_INSUFFICIENT_BALANCE" },
    { no: 20, name: "CRYPTO_TRANSACTION_FAIL_REASON_LIMITS" },
    { no: 30, name: "CRYPTO_TRANSACTION_FAIL_REASON_SCREENING" },
    { no: 40, name: "CRYPTO_TRANSACTION_FAIL_REASON_MIN_AMOUNT" },
    { no: 50, name: "CRYPTO_TRANSACTION_FAIL_REASON_FEES" },
    { no: 60, name: "CRYPTO_TRANSACTION_FAIL_REASON_NETWORK" },
    { no: 80, name: "CRYPTO_TRANSACTION_FAIL_REASON_INVALID_CARD_DETAILS" },
    { no: 90, name: "CRYPTO_TRANSACTION_FAIL_REASON_WRONG_CARD_PIN" },
    { no: 100, name: "CRYPTO_TRANSACTION_FAIL_REASON_WRONG_CARD_CVV" },
    { no: 110, name: "CRYPTO_TRANSACTION_FAIL_REASON_WRONG_CARD_EXPIRY_DATE" },
    { no: 120, name: "CRYPTO_TRANSACTION_FAIL_REASON_FAILED_3DS" },
    { no: 130, name: "CRYPTO_TRANSACTION_FAIL_REASON_FAILED_CARD_EXPIRED" },
    { no: 140, name: "CRYPTO_TRANSACTION_FAIL_REASON_FAILED_CARD_INACTIVE" },
    { no: 500, name: "CRYPTO_TRANSACTION_FAIL_REASON_SERVER_ERROR" },
    { no: 1000, name: "CRYPTO_TRANSACTION_FAIL_REASON_UNKNOWN" },
  ]
);

/**
 * We've decided to not give users actual crypto wallets.
 * We will take their assets in our custody and might move them on-chain for internal purposes.
 * So we can call this entity account rather than wallet.
 * Especially to simplify scenarios where there's multiple cryptocurrencies potentially sitting on the same wallet,
 * such as Ethereum ERC-20 tokens.
 *
 * @generated from message wallet.v1.CryptoAccount
 */
export class CryptoAccount extends Message<CryptoAccount> {
  /**
   * @generated from field: string id = 10;
   */
  id = "";

  /**
   * @generated from field: wallet.v1.Balance balance = 20;
   */
  balance?: Balance;

  /**
   * @generated from field: string currency = 30;
   */
  currency = "";

  /**
   * @generated from field: wallet.v1.DepositIdentifier deposit_identifier = 40;
   */
  depositIdentifier?: DepositIdentifier;

  constructor(data?: PartialMessage<CryptoAccount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.CryptoAccount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "balance", kind: "message", T: Balance },
    { no: 30, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 40,
      name: "deposit_identifier",
      kind: "message",
      T: DepositIdentifier,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): CryptoAccount {
    return new CryptoAccount().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): CryptoAccount {
    return new CryptoAccount().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CryptoAccount {
    return new CryptoAccount().fromJsonString(jsonString, options);
  }

  static equals(
    a: CryptoAccount | PlainMessage<CryptoAccount> | undefined,
    b: CryptoAccount | PlainMessage<CryptoAccount> | undefined
  ): boolean {
    return proto3.util.equals(CryptoAccount, a, b);
  }
}

/**
 * @generated from message wallet.v1.DepositIdentifier
 */
export class DepositIdentifier extends Message<DepositIdentifier> {
  /**
   * on-chain address on which funds can be deposited
   *
   * at a later stage we can add things such as memos
   *
   * @generated from field: string address = 10;
   */
  address = "";

  constructor(data?: PartialMessage<DepositIdentifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.DepositIdentifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): DepositIdentifier {
    return new DepositIdentifier().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): DepositIdentifier {
    return new DepositIdentifier().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): DepositIdentifier {
    return new DepositIdentifier().fromJsonString(jsonString, options);
  }

  static equals(
    a: DepositIdentifier | PlainMessage<DepositIdentifier> | undefined,
    b: DepositIdentifier | PlainMessage<DepositIdentifier> | undefined
  ): boolean {
    return proto3.util.equals(DepositIdentifier, a, b);
  }
}

/**
 * not much use for backend, mainly used to facilitate client code
 *
 * @generated from message wallet.v1.CryptoTransactions
 */
export class CryptoTransactions extends Message<CryptoTransactions> {
  /**
   * @generated from field: repeated wallet.v1.CryptoTransaction transactions = 1;
   */
  transactions: CryptoTransaction[] = [];

  constructor(data?: PartialMessage<CryptoTransactions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.CryptoTransactions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "transactions",
      kind: "message",
      T: CryptoTransaction,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): CryptoTransactions {
    return new CryptoTransactions().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): CryptoTransactions {
    return new CryptoTransactions().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CryptoTransactions {
    return new CryptoTransactions().fromJsonString(jsonString, options);
  }

  static equals(
    a: CryptoTransactions | PlainMessage<CryptoTransactions> | undefined,
    b: CryptoTransactions | PlainMessage<CryptoTransactions> | undefined
  ): boolean {
    return proto3.util.equals(CryptoTransactions, a, b);
  }
}

/**
 * @generated from message wallet.v1.CryptoTransaction
 */
export class CryptoTransaction extends Message<CryptoTransaction> {
  /**
   * @generated from field: string id = 10;
   */
  id = "";

  /**
   * Client needs to know which account this transaction belongs to, as our endpoints support
   * returning transactions for all accounts.
   * Specifying the currency won't be necessary, as the client can infer from the account.
   * It's best to always synchronize transactions right after having synchronized accounts,
   * to avoid ending up with a tx referencing an unknown account_id.
   *
   * @generated from field: string account_id = 11;
   */
  accountId = "";

  /**
   * @generated from field: string event_id = 12;
   */
  eventId = "";

  /**
   * eg: 1.01 SOL total amount = 1 SOL net amount + 0.005 fee + 0.005 service fee
   * also keep in mind that crypto transactions might be pretty long strings, eg: 1200.0012345342341
   * truncate decimal digits in the UI when displaying in narrow spaces
   *
   * @generated from field: string total_amount = 20;
   */
  totalAmount = "";

  /**
   * @generated from field: string net_amount = 21;
   */
  netAmount = "";

  /**
   * @generated from field: string fee_amount = 22;
   */
  feeAmount = "";

  /**
   * @generated from field: string service_fee_amount = 23;
   */
  serviceFeeAmount = "";

  /**
   * if this is an exchange transaction, the following fields will contain the exchanged amount and asset
   *
   * @generated from field: string exchange_amount = 24;
   */
  exchangeAmount = "";

  /**
   * @generated from field: string exchange_asset = 25;
   */
  exchangeAsset = "";

  /**
   * @generated from field: wallet.v1.CryptoTransactionState state = 30;
   */
  state = CryptoTransactionState.UNSPECIFIED;

  /**
   * check this enum if state is REJECTED or FAILED
   *
   * @generated from field: wallet.v1.CryptoTransactionFailReason fail_reason = 31;
   */
  failReason = CryptoTransactionFailReason.UNSPECIFIED;

  /**
   * @generated from field: wallet.v1.CryptoTransactionType type = 40;
   */
  type = CryptoTransactionType.UNSPECIFIED;

  /**
   * Harbour-generated transaction description
   * At the moment there are no guarantees in length, make sure to truncate on clients when displaying.
   *
   * @generated from field: string description = 50;
   */
  description = "";

  /**
   * Only populated for withdrawals, in which case it's the destination blockchain address,
   * and deposits, in which case it's the origin blockchain address
   *
   * @generated from field: string counterparty = 60;
   */
  counterparty = "";

  /**
   * If this is an on-chain transaction, the following info can be used to redirect users to block explorers
   * and give them some basic information about the transaction on the network
   *
   * @generated from field: wallet.v1.BlockchainTxInfo blockchain_tx_info = 70;
   */
  blockchainTxInfo?: BlockchainTxInfo;

  /**
   * @generated from field: wallet.v1.TransactionTime time = 80;
   */
  time?: TransactionTime;

  /**
   * @generated from oneof wallet.v1.CryptoTransaction.details
   */
  details:
    | {
        /**
         * in case it's none of the below
         *
         * @generated from field: google.protobuf.Empty empty_details = 99;
         */
        value: Empty;
        case: "emptyDetails";
      }
    | {
        /**
         * only present if it's a card transaction
         *
         * @generated from field: wallet.v1.CardTransactionDetails card_tx_details = 110;
         */
        value: CardTransactionDetails;
        case: "cardTxDetails";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CryptoTransaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.CryptoTransaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 11,
      name: "account_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 12, name: "event_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "total_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 21,
      name: "net_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 22,
      name: "fee_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 23,
      name: "service_fee_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 24,
      name: "exchange_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 25,
      name: "exchange_asset",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 30,
      name: "state",
      kind: "enum",
      T: proto3.getEnumType(CryptoTransactionState),
    },
    {
      no: 31,
      name: "fail_reason",
      kind: "enum",
      T: proto3.getEnumType(CryptoTransactionFailReason),
    },
    {
      no: 40,
      name: "type",
      kind: "enum",
      T: proto3.getEnumType(CryptoTransactionType),
    },
    {
      no: 50,
      name: "description",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 60,
      name: "counterparty",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 70,
      name: "blockchain_tx_info",
      kind: "message",
      T: BlockchainTxInfo,
    },
    { no: 80, name: "time", kind: "message", T: TransactionTime },
    {
      no: 99,
      name: "empty_details",
      kind: "message",
      T: Empty,
      oneof: "details",
    },
    {
      no: 110,
      name: "card_tx_details",
      kind: "message",
      T: CardTransactionDetails,
      oneof: "details",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): CryptoTransaction {
    return new CryptoTransaction().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): CryptoTransaction {
    return new CryptoTransaction().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CryptoTransaction {
    return new CryptoTransaction().fromJsonString(jsonString, options);
  }

  static equals(
    a: CryptoTransaction | PlainMessage<CryptoTransaction> | undefined,
    b: CryptoTransaction | PlainMessage<CryptoTransaction> | undefined
  ): boolean {
    return proto3.util.equals(CryptoTransaction, a, b);
  }
}

/**
 * @generated from message wallet.v1.BlockchainTxInfo
 */
export class BlockchainTxInfo extends Message<BlockchainTxInfo> {
  /**
   * @generated from field: string tx_hash = 10;
   */
  txHash = "";

  /**
   * @generated from field: string block_height = 20;
   */
  blockHeight = "";

  /**
   * @generated from field: string block_hash = 30;
   */
  blockHash = "";

  constructor(data?: PartialMessage<BlockchainTxInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wallet.v1.BlockchainTxInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "block_height",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 30,
      name: "block_hash",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): BlockchainTxInfo {
    return new BlockchainTxInfo().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): BlockchainTxInfo {
    return new BlockchainTxInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): BlockchainTxInfo {
    return new BlockchainTxInfo().fromJsonString(jsonString, options);
  }

  static equals(
    a: BlockchainTxInfo | PlainMessage<BlockchainTxInfo> | undefined,
    b: BlockchainTxInfo | PlainMessage<BlockchainTxInfo> | undefined
  ): boolean {
    return proto3.util.equals(BlockchainTxInfo, a, b);
  }
}
