// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file exchange/v1/public.proto (package exchange.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from enum exchange.v1.CurrencyType
 */
export enum CurrencyType {
  /**
   * @generated from enum value: CURRENCY_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CURRENCY_TYPE_FIAT = 10;
   */
  FIAT = 10,

  /**
   * @generated from enum value: CURRENCY_TYPE_CRYPTO = 20;
   */
  CRYPTO = 20,
}
// Retrieve enum metadata with: proto3.getEnumType(CurrencyType)
proto3.util.setEnumType(CurrencyType, "exchange.v1.CurrencyType", [
  { no: 0, name: "CURRENCY_TYPE_UNSPECIFIED" },
  { no: 10, name: "CURRENCY_TYPE_FIAT" },
  { no: 20, name: "CURRENCY_TYPE_CRYPTO" },
]);

/**
 * @generated from message exchange.v1.PingRequest
 */
export class PingRequest extends Message<PingRequest> {
  constructor(data?: PartialMessage<PingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "exchange.v1.PingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): PingRequest {
    return new PingRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): PingRequest {
    return new PingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): PingRequest {
    return new PingRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: PingRequest | PlainMessage<PingRequest> | undefined,
    b: PingRequest | PlainMessage<PingRequest> | undefined
  ): boolean {
    return proto3.util.equals(PingRequest, a, b);
  }
}

/**
 * @generated from message exchange.v1.PingResponse
 */
export class PingResponse extends Message<PingResponse> {
  /**
   * @generated from field: string message = 10;
   */
  message = "";

  constructor(data?: PartialMessage<PingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "exchange.v1.PingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): PingResponse {
    return new PingResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): PingResponse {
    return new PingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): PingResponse {
    return new PingResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: PingResponse | PlainMessage<PingResponse> | undefined,
    b: PingResponse | PlainMessage<PingResponse> | undefined
  ): boolean {
    return proto3.util.equals(PingResponse, a, b);
  }
}

/**
 * @generated from message exchange.v1.Asset
 */
export class Asset extends Message<Asset> {
  /**
   * @generated from field: exchange.v1.CurrencyType type = 10;
   */
  type = CurrencyType.UNSPECIFIED;

  /**
   * @generated from field: string id = 20;
   */
  id = "";

  constructor(data?: PartialMessage<Asset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "exchange.v1.Asset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "type", kind: "enum", T: proto3.getEnumType(CurrencyType) },
    { no: 20, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): Asset {
    return new Asset().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): Asset {
    return new Asset().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Asset {
    return new Asset().fromJsonString(jsonString, options);
  }

  static equals(
    a: Asset | PlainMessage<Asset> | undefined,
    b: Asset | PlainMessage<Asset> | undefined
  ): boolean {
    return proto3.util.equals(Asset, a, b);
  }
}

/**
 * @generated from message exchange.v1.Account
 */
export class Account extends Message<Account> {
  /**
   * @generated from field: exchange.v1.CurrencyType type = 10;
   */
  type = CurrencyType.UNSPECIFIED;

  /**
   * @generated from field: string account_id = 20;
   */
  accountId = "";

  constructor(data?: PartialMessage<Account>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "exchange.v1.Account";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "type", kind: "enum", T: proto3.getEnumType(CurrencyType) },
    {
      no: 20,
      name: "account_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): Account {
    return new Account().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): Account {
    return new Account().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): Account {
    return new Account().fromJsonString(jsonString, options);
  }

  static equals(
    a: Account | PlainMessage<Account> | undefined,
    b: Account | PlainMessage<Account> | undefined
  ): boolean {
    return proto3.util.equals(Account, a, b);
  }
}

/**
 * @generated from message exchange.v1.GetExchangeRateRequest
 */
export class GetExchangeRateRequest extends Message<GetExchangeRateRequest> {
  /**
   * @generated from field: exchange.v1.Asset from = 10;
   */
  from?: Asset;

  /**
   * @generated from field: exchange.v1.Asset to = 20;
   */
  to?: Asset;

  /**
   * @generated from field: string user_id = 30;
   */
  userId = "";

  constructor(data?: PartialMessage<GetExchangeRateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "exchange.v1.GetExchangeRateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "from", kind: "message", T: Asset },
    { no: 20, name: "to", kind: "message", T: Asset },
    { no: 30, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetExchangeRateRequest {
    return new GetExchangeRateRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetExchangeRateRequest {
    return new GetExchangeRateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetExchangeRateRequest {
    return new GetExchangeRateRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetExchangeRateRequest
      | PlainMessage<GetExchangeRateRequest>
      | undefined,
    b: GetExchangeRateRequest | PlainMessage<GetExchangeRateRequest> | undefined
  ): boolean {
    return proto3.util.equals(GetExchangeRateRequest, a, b);
  }
}

/**
 * @generated from message exchange.v1.GetExchangeRateResponse
 */
export class GetExchangeRateResponse extends Message<GetExchangeRateResponse> {
  /**
   * @generated from oneof exchange.v1.GetExchangeRateResponse.result
   */
  result:
    | {
        /**
         * @generated from field: exchange.v1.GetExchangeRateResponse.Error error = 20;
         */
        value: GetExchangeRateResponse_Error;
        case: "error";
      }
    | {
        /**
         * @generated from field: exchange.v1.GetExchangeRateResponse.Quote quote = 30;
         */
        value: GetExchangeRateResponse_Quote;
        case: "quote";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetExchangeRateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "exchange.v1.GetExchangeRateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 20,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(GetExchangeRateResponse_Error),
      oneof: "result",
    },
    {
      no: 30,
      name: "quote",
      kind: "message",
      T: GetExchangeRateResponse_Quote,
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetExchangeRateResponse {
    return new GetExchangeRateResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetExchangeRateResponse {
    return new GetExchangeRateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetExchangeRateResponse {
    return new GetExchangeRateResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetExchangeRateResponse
      | PlainMessage<GetExchangeRateResponse>
      | undefined,
    b:
      | GetExchangeRateResponse
      | PlainMessage<GetExchangeRateResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(GetExchangeRateResponse, a, b);
  }
}

/**
 * @generated from enum exchange.v1.GetExchangeRateResponse.Error
 */
export enum GetExchangeRateResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ERROR_UNSUPPORTED_ASSET_PAIR = 10;
   */
  UNSUPPORTED_ASSET_PAIR = 10,

  /**
   * the FX service is unavailable due to operational reasons
   * (eg: we are dealing with a liquidity issue or halting FX temporarily for other reasons)
   *
   * @generated from enum value: ERROR_SERVICE_UNAVAILABLE = 20;
   */
  SERVICE_UNAVAILABLE = 20,
}
// Retrieve enum metadata with: proto3.getEnumType(GetExchangeRateResponse_Error)
proto3.util.setEnumType(
  GetExchangeRateResponse_Error,
  "exchange.v1.GetExchangeRateResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 10, name: "ERROR_UNSUPPORTED_ASSET_PAIR" },
    { no: 20, name: "ERROR_SERVICE_UNAVAILABLE" },
  ]
);

/**
 * @generated from message exchange.v1.GetExchangeRateResponse.Quote
 */
export class GetExchangeRateResponse_Quote extends Message<GetExchangeRateResponse_Quote> {
  /**
   * rate is from/to (eg: GBP/USDC when exchanging from GBP to USDC)
   *
   * @generated from field: string rate = 10;
   */
  rate = "";

  /**
   * the expiry is also in the JWT, but we added as an extra field so that the client doesn't need to parse the token
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 20;
   */
  expiresAt?: Timestamp;

  /**
   * a signed JWT containing claims (from, to, expires_at and rate)
   * client app can just treat as a string
   *
   * @generated from field: string token = 30;
   */
  token = "";

  /**
   * the minimum amount that can be converted (eg: 1 GBP), note: might be different for each asset
   *
   * @generated from field: string min_amount = 40;
   */
  minAmount = "";

  /**
   * the maximum amount that can be converted (eg: 1000 GBP)
   *
   * @generated from field: string max_amount = 50;
   */
  maxAmount = "";

  constructor(data?: PartialMessage<GetExchangeRateResponse_Quote>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "exchange.v1.GetExchangeRateResponse.Quote";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "expires_at", kind: "message", T: Timestamp },
    { no: 30, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 40,
      name: "min_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 50,
      name: "max_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetExchangeRateResponse_Quote {
    return new GetExchangeRateResponse_Quote().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetExchangeRateResponse_Quote {
    return new GetExchangeRateResponse_Quote().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetExchangeRateResponse_Quote {
    return new GetExchangeRateResponse_Quote().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | GetExchangeRateResponse_Quote
      | PlainMessage<GetExchangeRateResponse_Quote>
      | undefined,
    b:
      | GetExchangeRateResponse_Quote
      | PlainMessage<GetExchangeRateResponse_Quote>
      | undefined
  ): boolean {
    return proto3.util.equals(GetExchangeRateResponse_Quote, a, b);
  }
}

/**
 * @generated from message exchange.v1.ExchangeRequest
 */
export class ExchangeRequest extends Message<ExchangeRequest> {
  /**
   * a non-expired JWT from GetExchangeRateResponse
   * (the backend will allow a few seconds slack on expired quotes to factor in network latency)
   *
   * @generated from field: string token = 10;
   */
  token = "";

  /**
   * @generated from field: string user_id = 20;
   */
  userId = "";

  /**
   * the account that will be debited (eg: GBP if converting from GBP to USDC)
   *
   * @generated from field: exchange.v1.Account from = 30;
   */
  from?: Account;

  /**
   * the account that will be credited (eg: USDC if converting from GBP to USDC)
   *
   * @generated from field: exchange.v1.Account to = 40;
   */
  to?: Account;

  /**
   * amount to exchange of the "from" Account
   * note: for fiat currencies, the max precision is defined by the ISO 4217 standard, eg: 2 decimal digits for GBP
   * for crypto currencies, the max precision is the same as for with withdrawal API
   *
   * @generated from field: string amount = 50;
   */
  amount = "";

  /**
   * mandatory UUID to prevent duplicate requests
   * should be generated by the client when landing on the exchange screen
   *
   * @generated from field: string idempotency_key = 60;
   */
  idempotencyKey = "";

  /**
   * if true, all validation is performed but no exchange is actually performed
   * an ok response is still returned
   *
   * @generated from field: bool dry_run = 70;
   */
  dryRun = false;

  constructor(data?: PartialMessage<ExchangeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "exchange.v1.ExchangeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "from", kind: "message", T: Account },
    { no: 40, name: "to", kind: "message", T: Account },
    { no: 50, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 60,
      name: "idempotency_key",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 70, name: "dry_run", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): ExchangeRequest {
    return new ExchangeRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): ExchangeRequest {
    return new ExchangeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): ExchangeRequest {
    return new ExchangeRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: ExchangeRequest | PlainMessage<ExchangeRequest> | undefined,
    b: ExchangeRequest | PlainMessage<ExchangeRequest> | undefined
  ): boolean {
    return proto3.util.equals(ExchangeRequest, a, b);
  }
}

/**
 * @generated from message exchange.v1.ExchangeResponse
 */
export class ExchangeResponse extends Message<ExchangeResponse> {
  /**
   * @generated from oneof exchange.v1.ExchangeResponse.result
   */
  result:
    | {
        /**
         * @generated from field: exchange.v1.ExchangeResponse.Error error = 20;
         */
        value: ExchangeResponse_Error;
        case: "error";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExchangeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "exchange.v1.ExchangeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 20,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(ExchangeResponse_Error),
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): ExchangeResponse {
    return new ExchangeResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): ExchangeResponse {
    return new ExchangeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): ExchangeResponse {
    return new ExchangeResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: ExchangeResponse | PlainMessage<ExchangeResponse> | undefined,
    b: ExchangeResponse | PlainMessage<ExchangeResponse> | undefined
  ): boolean {
    return proto3.util.equals(ExchangeResponse, a, b);
  }
}

/**
 * @generated from enum exchange.v1.ExchangeResponse.Error
 */
export enum ExchangeResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ERROR_TOKEN_EXPIRED = 10;
   */
  TOKEN_EXPIRED = 10,

  /**
   * @generated from enum value: ERROR_TOKEN_INVALID = 20;
   */
  TOKEN_INVALID = 20,

  /**
   * @generated from enum value: ERROR_INSUFFICIENT_BALANCE = 30;
   */
  INSUFFICIENT_BALANCE = 30,

  /**
   * amount is less than the min_amount in the quote
   *
   * @generated from enum value: ERROR_MIN_AMOUNT = 40;
   */
  MIN_AMOUNT = 40,

  /**
   * amount is greater than the max_amount in the quote
   *
   * @generated from enum value: ERROR_MAX_AMOUNT = 50;
   */
  MAX_AMOUNT = 50,

  /**
   * @generated from enum value: ERROR_PRECISION_EXCEEDED = 60;
   */
  PRECISION_EXCEEDED = 60,

  /**
   * amount is within max_amount, however daily or monthly limit has been exceeded
   *
   * @generated from enum value: ERROR_LIMIT_EXCEEDED = 70;
   */
  LIMIT_EXCEEDED = 70,

  /**
   * @generated from enum value: ERROR_SERVICE_UNAVAILABLE = 80;
   */
  SERVICE_UNAVAILABLE = 80,
}
// Retrieve enum metadata with: proto3.getEnumType(ExchangeResponse_Error)
proto3.util.setEnumType(
  ExchangeResponse_Error,
  "exchange.v1.ExchangeResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 10, name: "ERROR_TOKEN_EXPIRED" },
    { no: 20, name: "ERROR_TOKEN_INVALID" },
    { no: 30, name: "ERROR_INSUFFICIENT_BALANCE" },
    { no: 40, name: "ERROR_MIN_AMOUNT" },
    { no: 50, name: "ERROR_MAX_AMOUNT" },
    { no: 60, name: "ERROR_PRECISION_EXCEEDED" },
    { no: 70, name: "ERROR_LIMIT_EXCEEDED" },
    { no: 80, name: "ERROR_SERVICE_UNAVAILABLE" },
  ]
);
