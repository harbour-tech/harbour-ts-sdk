// @generated by protoc-gen-connect-web v0.9.1 with parameter "target=ts"
// @generated from file auth/v1/public.proto (package auth.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import {
  AuthenticateRequest,
  AuthenticateResponse,
  ChangePhoneNumberRequest,
  ChangePhoneNumberResponse,
  ConfirmPhoneNumberRequest,
  ConfirmPhoneNumberResponse,
  CreateUserConfirmRequest,
  CreateUserConfirmResponse,
  CreateUserRequest,
  CreateUserResponse,
  GetUserDetailsRequest,
  GetUserDetailsResponse,
  PingRequest,
  PingResponse,
  RefreshRequest,
  RefreshResponse,
  RegisterDeviceRequest,
  RegisterDeviceResponse,
  SignInConfirmRequest,
  SignInConfirmResponse,
  SignInRequest,
  SignInResponse,
  SignOutRequest,
  SignOutResponse,
} from "./public_pb";
import { MethodKind } from "@bufbuild/protobuf";

/**
 * @generated from service auth.v1.PingService
 */
export const PingService = {
  typeName: "auth.v1.PingService",
  methods: {
    /**
     * @generated from rpc auth.v1.PingService.Ping
     */
    ping: {
      name: "Ping",
      I: PingRequest,
      O: PingResponse,
      kind: MethodKind.Unary,
    },
  },
} as const;

/**
 * @generated from service auth.v1.DeviceService
 */
export const DeviceService = {
  typeName: "auth.v1.DeviceService",
  methods: {
    /**
     * When a device has no local data (fresh install) or outdated device id (data recovered from different device backup),
     * it has to generate a new keypair and register itself.
     * It is vital to store the private key securely on the device (eg: pin or biometrics protection to access).
     * After correct device registration, user should be presented with the SignIn/SignUp screen.
     *
     * @generated from rpc auth.v1.DeviceService.RegisterDevice
     */
    registerDevice: {
      name: "RegisterDevice",
      I: RegisterDeviceRequest,
      O: RegisterDeviceResponse,
      kind: MethodKind.Unary,
    },
  },
} as const;

/**
 * @generated from service auth.v1.AuthService
 */
export const AuthService = {
  typeName: "auth.v1.AuthService",
  methods: {
    /**
     * Active devices can use this rpc to obtain access and refresh token.
     * The access token has a strict expiry (minutes), and should be refreshed before expiry.
     * The refresh token has a longer expiry time (hours).
     * The app can keep store those somewhat securely, but pin/biometrics should not be required to fetch them,
     * as it would be terrible user experience to have to insert the PIN while using the app.
     * However, user inactivity must be detected in the app and these credentials deleted if so,
     * in order to force biometrics/pin use when the user comes back.
     *
     * @generated from rpc auth.v1.AuthService.Authenticate
     */
    authenticate: {
      name: "Authenticate",
      I: AuthenticateRequest,
      O: AuthenticateResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Exchange the refresh token for a new access and refresh token.
     * Once exchanged, the previous refresh token gets invalidated and can not be re used.
     * Refresh tokens have a fixed lifespan and every new refresh token inherits this lifespan.
     * This way if an attacker manages to steal a refresh token he wont be able to generate new
     * tokens for ever as at some point will have to re authenticate.
     *
     * @generated from rpc auth.v1.AuthService.Refresh
     */
    refresh: {
      name: "Refresh",
      I: RefreshRequest,
      O: RefreshResponse,
      kind: MethodKind.Unary,
    },
  },
} as const;

/**
 * @generated from service auth.v1.UserService
 */
export const UserService = {
  typeName: "auth.v1.UserService",
  methods: {
    /**
     *    -- -> signup
     *    -- -> send device id, phone number, full name, signed
     *    --      <- server determines if phone number is already associated with user, if so returns an error, else creates user, sends OTP SMS and returns details on how long before retrying and an onboarding ID
     *    --          if user already associated, return an error code
     *    --          if already active, return an error code
     *    --          if device id not found, return an error code
     *
     * @generated from rpc auth.v1.UserService.CreateUser
     */
    createUser: {
      name: "CreateUser",
      I: CreateUserRequest,
      O: CreateUserResponse,
      kind: MethodKind.Unary,
    },
    /**
     *    -- Accepts the user OTP value and a token.
     *    -- Token is the one returned by CreateUser RPC and contains user/device info and the OTP id
     *    -- Creates the user account and connects it with the appropriate device.
     *
     * @generated from rpc auth.v1.UserService.CreateUserConfirm
     */
    createUserConfirm: {
      name: "CreateUserConfirm",
      I: CreateUserConfirmRequest,
      O: CreateUserConfirmResponse,
      kind: MethodKind.Unary,
    },
    /**
     *    -- -> sign in
     *    -- -> send device id, phone number, signed
     *    --      <- server determines if phone number is associated with user, if so sends SMS via OTP and returns details on how long before retrying is allowed
     *    --          if no associated user, return an error code
     * --          if already active, return an error code
     * --          if device id not found, return an error code
     *
     * @generated from rpc auth.v1.UserService.SignIn
     */
    signIn: {
      name: "SignIn",
      I: SignInRequest,
      O: SignInResponse,
      kind: MethodKind.Unary,
    },
    /**
     *     -- Accepts the user OTP value and a token.
     *     -- Token is the one returned by SignIn RPC and contains ...
     *
     * @generated from rpc auth.v1.UserService.SignInConfirm
     */
    signInConfirm: {
      name: "SignInConfirm",
      I: SignInConfirmRequest,
      O: SignInConfirmResponse,
      kind: MethodKind.Unary,
    },
    /**
     *     -- Fetch user details
     *     -- Endpoint should be used only by authenticated users
     *
     * @generated from rpc auth.v1.UserService.GetUserDetails
     */
    getUserDetails: {
      name: "GetUserDetails",
      I: GetUserDetailsRequest,
      O: GetUserDetailsResponse,
      kind: MethodKind.Unary,
    },
    /**
     *     -- Sign out
     *     -- unlink the device from the user account
     *     -- the client doesn't need to delete private key and re-register, just go back to the initial screen for either user sign in or sign up
     *
     * @generated from rpc auth.v1.UserService.SignOut
     */
    signOut: {
      name: "SignOut",
      I: SignOutRequest,
      O: SignOutResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Change phone number requires a signature, obliging the user to go through pin/biometrics.
     * Note: it also requires a valid access token, so the user must be signed in.
     * An OTP is sent to the user, which will have to be used to confirm the change.
     *
     * @generated from rpc auth.v1.UserService.ChangePhoneNumber
     */
    changePhoneNumber: {
      name: "ChangePhoneNumber",
      I: ChangePhoneNumberRequest,
      O: ChangePhoneNumberResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Confirm phone number change
     *
     * @generated from rpc auth.v1.UserService.ConfirmPhoneNumber
     */
    confirmPhoneNumber: {
      name: "ConfirmPhoneNumber",
      I: ConfirmPhoneNumberRequest,
      O: ConfirmPhoneNumberResponse,
      kind: MethodKind.Unary,
    },
  },
} as const;
