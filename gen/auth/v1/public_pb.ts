// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file auth/v1/public.proto (package auth.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { PhoneNumber } from "./common_pb";

/**
 * @generated from message auth.v1.PingRequest
 */
export class PingRequest extends Message<PingRequest> {
  constructor(data?: PartialMessage<PingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.PingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): PingRequest {
    return new PingRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): PingRequest {
    return new PingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): PingRequest {
    return new PingRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: PingRequest | PlainMessage<PingRequest> | undefined,
    b: PingRequest | PlainMessage<PingRequest> | undefined
  ): boolean {
    return proto3.util.equals(PingRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.PingResponse
 */
export class PingResponse extends Message<PingResponse> {
  /**
   * @generated from field: string message = 10;
   */
  message = "";

  constructor(data?: PartialMessage<PingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.PingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): PingResponse {
    return new PingResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): PingResponse {
    return new PingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): PingResponse {
    return new PingResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: PingResponse | PlainMessage<PingResponse> | undefined,
    b: PingResponse | PlainMessage<PingResponse> | undefined
  ): boolean {
    return proto3.util.equals(PingResponse, a, b);
  }
}

/**
 * @generated from message auth.v1.ConfirmPhoneNumberRequest
 */
export class ConfirmPhoneNumberRequest extends Message<ConfirmPhoneNumberRequest> {
  /**
   * the otp received
   *
   * @generated from field: string otp = 10;
   */
  otp = "";

  /**
   * required
   *
   * @generated from field: string user_id = 20;
   */
  userId = "";

  /**
   * the token from the ChangePhoneNumberResponse
   *
   * @generated from field: string token = 30;
   */
  token = "";

  constructor(data?: PartialMessage<ConfirmPhoneNumberRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.ConfirmPhoneNumberRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "otp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): ConfirmPhoneNumberRequest {
    return new ConfirmPhoneNumberRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): ConfirmPhoneNumberRequest {
    return new ConfirmPhoneNumberRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): ConfirmPhoneNumberRequest {
    return new ConfirmPhoneNumberRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | ConfirmPhoneNumberRequest
      | PlainMessage<ConfirmPhoneNumberRequest>
      | undefined,
    b:
      | ConfirmPhoneNumberRequest
      | PlainMessage<ConfirmPhoneNumberRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(ConfirmPhoneNumberRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.ConfirmPhoneNumberResponse
 */
export class ConfirmPhoneNumberResponse extends Message<ConfirmPhoneNumberResponse> {
  /**
   * @generated from oneof auth.v1.ConfirmPhoneNumberResponse.result
   */
  result:
    | {
        /**
         * @generated from field: auth.v1.ConfirmPhoneNumberResponse.Error error = 10;
         */
        value: ConfirmPhoneNumberResponse_Error;
        case: "error";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ConfirmPhoneNumberResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.ConfirmPhoneNumberResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(ConfirmPhoneNumberResponse_Error),
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): ConfirmPhoneNumberResponse {
    return new ConfirmPhoneNumberResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): ConfirmPhoneNumberResponse {
    return new ConfirmPhoneNumberResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): ConfirmPhoneNumberResponse {
    return new ConfirmPhoneNumberResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | ConfirmPhoneNumberResponse
      | PlainMessage<ConfirmPhoneNumberResponse>
      | undefined,
    b:
      | ConfirmPhoneNumberResponse
      | PlainMessage<ConfirmPhoneNumberResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(ConfirmPhoneNumberResponse, a, b);
  }
}

/**
 * @generated from enum auth.v1.ConfirmPhoneNumberResponse.Error
 */
export enum ConfirmPhoneNumberResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * the wrong OTP was inserted
   *
   * @generated from enum value: ERROR_OTP_INVALID = 1;
   */
  OTP_INVALID = 1,

  /**
   * the OTP code has expired
   *
   * @generated from enum value: ERROR_OTP_EXPIRED = 2;
   */
  OTP_EXPIRED = 2,

  /**
   * OTP code was already used
   *
   * @generated from enum value: ERROR_OTP_ALREADY_USED = 3;
   */
  OTP_ALREADY_USED = 3,

  /**
   * the wrong token was supplied
   *
   * @generated from enum value: ERROR_TOKEN_INVALID = 4;
   */
  TOKEN_INVALID = 4,

  /**
   * Only returned in the extremely unlikely case that some one else managed to change their phone number in between
   * the ChangePhoneNumber and ConfirmPhoneNumber RPCs.
   * Should be impossible as two distinct users shouldn't be able to use the same mobile number, but better be able
   * to recognise this error and show the proper message to the user.
   *
   * @generated from enum value: ERROR_PHONE_DUPLICATE = 5;
   */
  PHONE_DUPLICATE = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(ConfirmPhoneNumberResponse_Error)
proto3.util.setEnumType(
  ConfirmPhoneNumberResponse_Error,
  "auth.v1.ConfirmPhoneNumberResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_OTP_INVALID" },
    { no: 2, name: "ERROR_OTP_EXPIRED" },
    { no: 3, name: "ERROR_OTP_ALREADY_USED" },
    { no: 4, name: "ERROR_TOKEN_INVALID" },
    { no: 5, name: "ERROR_PHONE_DUPLICATE" },
  ]
);

/**
 * @generated from message auth.v1.ChangePhoneNumberRequest
 */
export class ChangePhoneNumberRequest extends Message<ChangePhoneNumberRequest> {
  /**
   * Required
   *
   * @generated from field: auth.v1.PhoneNumber phone_num = 10;
   */
  phoneNum?: PhoneNumber;

  /**
   * Required
   *
   * @generated from field: string user_id = 20;
   */
  userId = "";

  /**
   * A JWT with a `vendor_device_id` claim and an expiry not further than 10 seconds from now
   *
   * @generated from field: string signature = 40;
   */
  signature = "";

  constructor(data?: PartialMessage<ChangePhoneNumberRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.ChangePhoneNumberRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "phone_num", kind: "message", T: PhoneNumber },
    { no: 20, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): ChangePhoneNumberRequest {
    return new ChangePhoneNumberRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): ChangePhoneNumberRequest {
    return new ChangePhoneNumberRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): ChangePhoneNumberRequest {
    return new ChangePhoneNumberRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | ChangePhoneNumberRequest
      | PlainMessage<ChangePhoneNumberRequest>
      | undefined,
    b:
      | ChangePhoneNumberRequest
      | PlainMessage<ChangePhoneNumberRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(ChangePhoneNumberRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.ChangePhoneNumberResponse
 */
export class ChangePhoneNumberResponse extends Message<ChangePhoneNumberResponse> {
  /**
   * @generated from oneof auth.v1.ChangePhoneNumberResponse.result
   */
  result:
    | {
        /**
         * @generated from field: auth.v1.ChangePhoneNumberResponse.Error error = 10;
         */
        value: ChangePhoneNumberResponse_Error;
        case: "error";
      }
    | {
        /**
         * use along OTP to confirm phone number change
         *
         * @generated from field: string token = 20;
         */
        value: string;
        case: "token";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ChangePhoneNumberResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.ChangePhoneNumberResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(ChangePhoneNumberResponse_Error),
      oneof: "result",
    },
    {
      no: 20,
      name: "token",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): ChangePhoneNumberResponse {
    return new ChangePhoneNumberResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): ChangePhoneNumberResponse {
    return new ChangePhoneNumberResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): ChangePhoneNumberResponse {
    return new ChangePhoneNumberResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | ChangePhoneNumberResponse
      | PlainMessage<ChangePhoneNumberResponse>
      | undefined,
    b:
      | ChangePhoneNumberResponse
      | PlainMessage<ChangePhoneNumberResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(ChangePhoneNumberResponse, a, b);
  }
}

/**
 * @generated from enum auth.v1.ChangePhoneNumberResponse.Error
 */
export enum ChangePhoneNumberResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Phone number is already taken by a different user
   *
   * @generated from enum value: ERROR_PHONE_DUPLICATE = 1;
   */
  PHONE_DUPLICATE = 1,

  /**
   * Phone number is invalid
   *
   * @generated from enum value: ERROR_PHONE_INVALID = 2;
   */
  PHONE_INVALID = 2,

  /**
   * The new prefix is different from the old prefix, suggesting that the user is trying to change their phone number
   * to one of a different country. This might or might not be allowed depending on our risk appetite. If it's not
   * allowed, this error will be returned.
   *
   * @generated from enum value: ERROR_COUNTRY_CHANGE_DISALLOWED = 3;
   */
  COUNTRY_CHANGE_DISALLOWED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ChangePhoneNumberResponse_Error)
proto3.util.setEnumType(
  ChangePhoneNumberResponse_Error,
  "auth.v1.ChangePhoneNumberResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_PHONE_DUPLICATE" },
    { no: 2, name: "ERROR_PHONE_INVALID" },
    { no: 3, name: "ERROR_COUNTRY_CHANGE_DISALLOWED" },
  ]
);

/**
 * @generated from message auth.v1.GetUserDetailsRequest
 */
export class GetUserDetailsRequest extends Message<GetUserDetailsRequest> {
  constructor(data?: PartialMessage<GetUserDetailsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.GetUserDetailsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetUserDetailsRequest {
    return new GetUserDetailsRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetUserDetailsRequest {
    return new GetUserDetailsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetUserDetailsRequest {
    return new GetUserDetailsRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetUserDetailsRequest | PlainMessage<GetUserDetailsRequest> | undefined,
    b: GetUserDetailsRequest | PlainMessage<GetUserDetailsRequest> | undefined
  ): boolean {
    return proto3.util.equals(GetUserDetailsRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.GetUserDetailsResponse
 */
export class GetUserDetailsResponse extends Message<GetUserDetailsResponse> {
  /**
   * @generated from field: string id = 10;
   */
  id = "";

  /**
   * @generated from field: string first_name = 20;
   */
  firstName = "";

  /**
   * @generated from field: string middle_names = 30;
   */
  middleNames = "";

  /**
   * @generated from field: string last_name = 40;
   */
  lastName = "";

  /**
   * @generated from field: auth.v1.PhoneNumber phone_number = 50;
   */
  phoneNumber?: PhoneNumber;

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 60;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: string email = 70;
   */
  email = "";

  /**
   * @generated from field: string date_of_birth = 80;
   */
  dateOfBirth = "";

  /**
   * @generated from field: auth.v1.GetUserDetailsResponse.Address address = 90;
   */
  address?: GetUserDetailsResponse_Address;

  /**
   * If true, this is a test user and informs the client that any banking endpoint (such as pay out and exchange)
   * should use the dry-run flag, and cards should not allowed to be issued.
   * Changing phone number will be allowed from UI, but will have no effect on our db.
   *
   * @generated from field: bool is_test_user = 100;
   */
  isTestUser = false;

  constructor(data?: PartialMessage<GetUserDetailsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.GetUserDetailsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "first_name",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 30,
      name: "middle_names",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 40, name: "last_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 50, name: "phone_number", kind: "message", T: PhoneNumber },
    { no: 60, name: "created_at", kind: "message", T: Timestamp },
    { no: 70, name: "email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 80,
      name: "date_of_birth",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 90,
      name: "address",
      kind: "message",
      T: GetUserDetailsResponse_Address,
    },
    {
      no: 100,
      name: "is_test_user",
      kind: "scalar",
      T: 8 /* ScalarType.BOOL */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetUserDetailsResponse {
    return new GetUserDetailsResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetUserDetailsResponse {
    return new GetUserDetailsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetUserDetailsResponse {
    return new GetUserDetailsResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetUserDetailsResponse
      | PlainMessage<GetUserDetailsResponse>
      | undefined,
    b: GetUserDetailsResponse | PlainMessage<GetUserDetailsResponse> | undefined
  ): boolean {
    return proto3.util.equals(GetUserDetailsResponse, a, b);
  }
}

/**
 * @generated from message auth.v1.GetUserDetailsResponse.Address
 */
export class GetUserDetailsResponse_Address extends Message<GetUserDetailsResponse_Address> {
  /**
   * @generated from field: string address_line1 = 10;
   */
  addressLine1 = "";

  /**
   * @generated from field: string address_line2 = 20;
   */
  addressLine2 = "";

  /**
   * @generated from field: string city = 30;
   */
  city = "";

  /**
   * @generated from field: string state = 40;
   */
  state = "";

  /**
   * @generated from field: string post_code = 50;
   */
  postCode = "";

  /**
   * @generated from field: string country = 60;
   */
  country = "";

  constructor(data?: PartialMessage<GetUserDetailsResponse_Address>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.GetUserDetailsResponse.Address";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "address_line1",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 20,
      name: "address_line2",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 30, name: "city", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "state", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 50, name: "post_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 60, name: "country", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetUserDetailsResponse_Address {
    return new GetUserDetailsResponse_Address().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetUserDetailsResponse_Address {
    return new GetUserDetailsResponse_Address().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetUserDetailsResponse_Address {
    return new GetUserDetailsResponse_Address().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | GetUserDetailsResponse_Address
      | PlainMessage<GetUserDetailsResponse_Address>
      | undefined,
    b:
      | GetUserDetailsResponse_Address
      | PlainMessage<GetUserDetailsResponse_Address>
      | undefined
  ): boolean {
    return proto3.util.equals(GetUserDetailsResponse_Address, a, b);
  }
}

/**
 * @generated from message auth.v1.CreateUserConfirmRequest
 */
export class CreateUserConfirmRequest extends Message<CreateUserConfirmRequest> {
  /**
   * The OTP that was sent to user.
   *
   * @generated from field: string value = 10;
   */
  value = "";

  /**
   * Returned by CreateUser RPC. Contains user data and the OTP ID.
   *
   * @generated from field: string token = 20;
   */
  token = "";

  constructor(data?: PartialMessage<CreateUserConfirmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.CreateUserConfirmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): CreateUserConfirmRequest {
    return new CreateUserConfirmRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): CreateUserConfirmRequest {
    return new CreateUserConfirmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CreateUserConfirmRequest {
    return new CreateUserConfirmRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | CreateUserConfirmRequest
      | PlainMessage<CreateUserConfirmRequest>
      | undefined,
    b:
      | CreateUserConfirmRequest
      | PlainMessage<CreateUserConfirmRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(CreateUserConfirmRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.CreateUserConfirmResponse
 */
export class CreateUserConfirmResponse extends Message<CreateUserConfirmResponse> {
  /**
   * @generated from oneof auth.v1.CreateUserConfirmResponse.result
   */
  result:
    | {
        /**
         * @generated from field: auth.v1.CreateUserConfirmResponse.Error error = 10;
         */
        value: CreateUserConfirmResponse_Error;
        case: "error";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CreateUserConfirmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.CreateUserConfirmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(CreateUserConfirmResponse_Error),
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): CreateUserConfirmResponse {
    return new CreateUserConfirmResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): CreateUserConfirmResponse {
    return new CreateUserConfirmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CreateUserConfirmResponse {
    return new CreateUserConfirmResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | CreateUserConfirmResponse
      | PlainMessage<CreateUserConfirmResponse>
      | undefined,
    b:
      | CreateUserConfirmResponse
      | PlainMessage<CreateUserConfirmResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(CreateUserConfirmResponse, a, b);
  }
}

/**
 * @generated from enum auth.v1.CreateUserConfirmResponse.Error
 */
export enum CreateUserConfirmResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * OTP value does not match with the OTP provided by the user.
   *
   * @generated from enum value: ERROR_INVALID_OTP = 1;
   */
  INVALID_OTP = 1,

  /**
   * OTP Already used
   *
   * @generated from enum value: ERROR_ALREADY_USED_OTP = 2;
   */
  ALREADY_USED_OTP = 2,

  /**
   * OTP is correct but expired
   *
   * @generated from enum value: ERROR_EXPIRED_OTP = 3;
   */
  EXPIRED_OTP = 3,

  /**
   * Phone number is already taken. Might have completed registration from another device.
   *
   * @generated from enum value: ERROR_PHONE_DUPLICATE = 4;
   */
  PHONE_DUPLICATE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(CreateUserConfirmResponse_Error)
proto3.util.setEnumType(
  CreateUserConfirmResponse_Error,
  "auth.v1.CreateUserConfirmResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_INVALID_OTP" },
    { no: 2, name: "ERROR_ALREADY_USED_OTP" },
    { no: 3, name: "ERROR_EXPIRED_OTP" },
    { no: 4, name: "ERROR_PHONE_DUPLICATE" },
  ]
);

/**
 * Create a new user. Won't be active, nor linked to the device, until the phone number is confirmed.
 * A successful request will trigger an OTP being sent via SMS (or other channels, see phone_num.prefix).
 * Any Unicode character is supported, os names can be typed in any language keyboard.
 *
 * @generated from message auth.v1.CreateUserRequest
 */
export class CreateUserRequest extends Message<CreateUserRequest> {
  /**
   * The device ID returned by the backend when registering, mandatory.
   * Submitting a wrong device id will produce an invalid_argument error response
   *
   * @generated from field: string device_id = 10;
   */
  deviceId = "";

  /**
   * Mandatory, the vendor device ID used when registering
   *
   * @generated from field: string vendor_device_id = 20;
   */
  vendorDeviceId = "";

  /**
   * Required
   *
   * @generated from field: auth.v1.PhoneNumber phone_num = 30;
   */
  phoneNum?: PhoneNumber;

  /**
   * Required, max len 100, must match ^[\p{L}\p{M} \p{Pd}\p{Pi}\p{Pf}'`]*$
   * (any Unicode letter, or combination of letter with accents, spaces, any hyphen or dash dashes, any kind of apostrophe or single quote)
   *
   * @generated from field: string first_name = 40;
   */
  firstName = "";

  /**
   * Optional, max len 100, must match ^[\p{L}\p{M} \p{Pd}\p{Pi}\p{Pf}'`]*$
   *
   * @generated from field: string middle_names = 50;
   */
  middleNames = "";

  /**
   * Required, max len 100, must match ^[\p{L}\p{M} \p{Pd}\p{Pi}\p{Pf}'`]*$
   *
   * @generated from field: string last_name = 60;
   */
  lastName = "";

  /**
   * A JWT with a `vendor_device_id` claim and an expiry not further than 10 seconds from now
   *
   * @generated from field: string signature = 70;
   */
  signature = "";

  constructor(data?: PartialMessage<CreateUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.CreateUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "device_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "vendor_device_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 30, name: "phone_num", kind: "message", T: PhoneNumber },
    {
      no: 40,
      name: "first_name",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 50,
      name: "middle_names",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 60, name: "last_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 70, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): CreateUserRequest {
    return new CreateUserRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): CreateUserRequest {
    return new CreateUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CreateUserRequest {
    return new CreateUserRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateUserRequest | PlainMessage<CreateUserRequest> | undefined,
    b: CreateUserRequest | PlainMessage<CreateUserRequest> | undefined
  ): boolean {
    return proto3.util.equals(CreateUserRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.CreateUserResponse
 */
export class CreateUserResponse extends Message<CreateUserResponse> {
  /**
   * @generated from oneof auth.v1.CreateUserResponse.result
   */
  result:
    | {
        /**
         * @generated from field: auth.v1.CreateUserResponse.Error error = 10;
         */
        value: CreateUserResponse_Error;
        case: "error";
      }
    | {
        /**
         * A token to be used to confirm the user along with the OTP
         *
         * @generated from field: string token = 20;
         */
        value: string;
        case: "token";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CreateUserResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.CreateUserResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(CreateUserResponse_Error),
      oneof: "result",
    },
    {
      no: 20,
      name: "token",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): CreateUserResponse {
    return new CreateUserResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): CreateUserResponse {
    return new CreateUserResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CreateUserResponse {
    return new CreateUserResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateUserResponse | PlainMessage<CreateUserResponse> | undefined,
    b: CreateUserResponse | PlainMessage<CreateUserResponse> | undefined
  ): boolean {
    return proto3.util.equals(CreateUserResponse, a, b);
  }
}

/**
 * @generated from enum auth.v1.CreateUserResponse.Error
 */
export enum CreateUserResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Phone number is already taken. The user should be told to go through sign-in instead of sign-up.
   *
   * @generated from enum value: ERROR_PHONE_DUPLICATE = 10;
   */
  PHONE_DUPLICATE = 10,

  /**
   * Very rare edge case in which the app has correctly registered a device (with an old vendor_device_id),
   * then unused until it's restored on a new phone with a new vendor_device_id.
   * In this case, the device should register itself again.
   *
   * @generated from enum value: ERROR_VENDOR_DEVICE_ID_NOT_RECOGNIZED = 20;
   */
  VENDOR_DEVICE_ID_NOT_RECOGNIZED = 20,

  /**
   * The backend might validate the phone number depending on country.
   * If this error is returned, the user should be informed that they inserted an invalid phone number.
   *
   * @generated from enum value: ERROR_INVALID_PHONE_NUM = 30;
   */
  INVALID_PHONE_NUM = 30,

  /**
   * This error is only ever returned if the whitelist has been enabled.
   * It means the input phone number doesn't match a whitelist entry, thus the user is not allowed to sign up.
   *
   * @generated from enum value: ERROR_NOT_ALLOWED = 40;
   */
  NOT_ALLOWED = 40,
}
// Retrieve enum metadata with: proto3.getEnumType(CreateUserResponse_Error)
proto3.util.setEnumType(
  CreateUserResponse_Error,
  "auth.v1.CreateUserResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 10, name: "ERROR_PHONE_DUPLICATE" },
    { no: 20, name: "ERROR_VENDOR_DEVICE_ID_NOT_RECOGNIZED" },
    { no: 30, name: "ERROR_INVALID_PHONE_NUM" },
    { no: 40, name: "ERROR_NOT_ALLOWED" },
  ]
);

/**
 * @generated from message auth.v1.SignInRequest
 */
export class SignInRequest extends Message<SignInRequest> {
  /**
   * The device ID returned by the backend when registering, mandatory.
   * Submitting a wrong device id will produce an invalid_argument error response
   *
   * @generated from field: string device_id = 10;
   */
  deviceId = "";

  /**
   * Mandatory, the vendor device ID used when registering
   *
   * @generated from field: string vendor_device_id = 20;
   */
  vendorDeviceId = "";

  /**
   * Required
   *
   * @generated from field: auth.v1.PhoneNumber phone_num = 30;
   */
  phoneNum?: PhoneNumber;

  /**
   * A JWT with a `vendor_device_id` claim and an expiry not further than 10 seconds from now
   *
   * @generated from field: string signature = 70;
   */
  signature = "";

  constructor(data?: PartialMessage<SignInRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.SignInRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "device_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "vendor_device_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 30, name: "phone_num", kind: "message", T: PhoneNumber },
    { no: 70, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): SignInRequest {
    return new SignInRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): SignInRequest {
    return new SignInRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): SignInRequest {
    return new SignInRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: SignInRequest | PlainMessage<SignInRequest> | undefined,
    b: SignInRequest | PlainMessage<SignInRequest> | undefined
  ): boolean {
    return proto3.util.equals(SignInRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.SignInResponse
 */
export class SignInResponse extends Message<SignInResponse> {
  /**
   * @generated from oneof auth.v1.SignInResponse.result
   */
  result:
    | {
        /**
         * @generated from field: auth.v1.SignInResponse.Error error = 10;
         */
        value: SignInResponse_Error;
        case: "error";
      }
    | {
        /**
         * A token to be used to confirm the user along with the OTP
         *
         * @generated from field: string token = 20;
         */
        value: string;
        case: "token";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SignInResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.SignInResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(SignInResponse_Error),
      oneof: "result",
    },
    {
      no: 20,
      name: "token",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): SignInResponse {
    return new SignInResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): SignInResponse {
    return new SignInResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): SignInResponse {
    return new SignInResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: SignInResponse | PlainMessage<SignInResponse> | undefined,
    b: SignInResponse | PlainMessage<SignInResponse> | undefined
  ): boolean {
    return proto3.util.equals(SignInResponse, a, b);
  }
}

/**
 * @generated from enum auth.v1.SignInResponse.Error
 */
export enum SignInResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * user associated with the device is not found
   *
   * @generated from enum value: ERROR_USER_NOT_FOUND = 1;
   */
  USER_NOT_FOUND = 1,

  /**
   * @generated from enum value: ERROR_DEVICE_NOT_FOUND = 2;
   */
  DEVICE_NOT_FOUND = 2,

  /**
   * @generated from enum value: ERROR_INVALID_PHONE_NUMBER = 3;
   */
  INVALID_PHONE_NUMBER = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SignInResponse_Error)
proto3.util.setEnumType(SignInResponse_Error, "auth.v1.SignInResponse.Error", [
  { no: 0, name: "ERROR_UNSPECIFIED" },
  { no: 1, name: "ERROR_USER_NOT_FOUND" },
  { no: 2, name: "ERROR_DEVICE_NOT_FOUND" },
  { no: 3, name: "ERROR_INVALID_PHONE_NUMBER" },
]);

/**
 * @generated from message auth.v1.SignInConfirmRequest
 */
export class SignInConfirmRequest extends Message<SignInConfirmRequest> {
  /**
   * The OTP that was send to user.
   *
   * @generated from field: string value = 10;
   */
  value = "";

  /**
   * Returned by SignIn RPC. Contains user/device data and the OTP ID.
   *
   * @generated from field: string token = 20;
   */
  token = "";

  constructor(data?: PartialMessage<SignInConfirmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.SignInConfirmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): SignInConfirmRequest {
    return new SignInConfirmRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): SignInConfirmRequest {
    return new SignInConfirmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): SignInConfirmRequest {
    return new SignInConfirmRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: SignInConfirmRequest | PlainMessage<SignInConfirmRequest> | undefined,
    b: SignInConfirmRequest | PlainMessage<SignInConfirmRequest> | undefined
  ): boolean {
    return proto3.util.equals(SignInConfirmRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.SignInConfirmResponse
 */
export class SignInConfirmResponse extends Message<SignInConfirmResponse> {
  /**
   * @generated from oneof auth.v1.SignInConfirmResponse.result
   */
  result:
    | {
        /**
         * @generated from field: auth.v1.SignInConfirmResponse.Error error = 10;
         */
        value: SignInConfirmResponse_Error;
        case: "error";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SignInConfirmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.SignInConfirmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(SignInConfirmResponse_Error),
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): SignInConfirmResponse {
    return new SignInConfirmResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): SignInConfirmResponse {
    return new SignInConfirmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): SignInConfirmResponse {
    return new SignInConfirmResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: SignInConfirmResponse | PlainMessage<SignInConfirmResponse> | undefined,
    b: SignInConfirmResponse | PlainMessage<SignInConfirmResponse> | undefined
  ): boolean {
    return proto3.util.equals(SignInConfirmResponse, a, b);
  }
}

/**
 * @generated from enum auth.v1.SignInConfirmResponse.Error
 */
export enum SignInConfirmResponse_Error {
  /**
   * OTP value does not match with the OTP provided by the user.
   *
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ERROR_INVALID_OTP = 1;
   */
  INVALID_OTP = 1,

  /**
   * @generated from enum value: ERROR_ALREADY_USED_OTP = 2;
   */
  ALREADY_USED_OTP = 2,

  /**
   * OTP is correct but expired
   *
   * @generated from enum value: ERROR_EXPIRED_OTP = 3;
   */
  EXPIRED_OTP = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SignInConfirmResponse_Error)
proto3.util.setEnumType(
  SignInConfirmResponse_Error,
  "auth.v1.SignInConfirmResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_INVALID_OTP" },
    { no: 2, name: "ERROR_ALREADY_USED_OTP" },
    { no: 3, name: "ERROR_EXPIRED_OTP" },
  ]
);

/**
 * @generated from message auth.v1.AuthenticateRequest
 */
export class AuthenticateRequest extends Message<AuthenticateRequest> {
  /**
   * Device-specific data.
   * If server does not recognise the vendor device id or vendor id, it is likely that this is a new device
   * on which a backup from a previous device was restored.
   * If that's the case, the mobile app should go back to DeviceService.Register and then present the user with the SignIn/SignUp screen
   *
   * @generated from field: string vendor_device_id = 10;
   */
  vendorDeviceId = "";

  /**
   * @generated from field: string vendor_id = 20;
   */
  vendorId = "";

  /**
   * These fields are allowed to change over time.
   * The device will often authenticate, so as soon as there is a change in os or app version,
   * our backend will update its records, just for the purpose of keeping track.
   * Knowing the os and app version is useful for debugging and to force updates.
   *
   * @generated from field: string os = 30;
   */
  os = "";

  /**
   * @generated from field: string os_version = 40;
   */
  osVersion = "";

  /**
   * @generated from field: string app_version = 50;
   */
  appVersion = "";

  /**
   * @generated from field: string name = 60;
   */
  name = "";

  /**
   * Server side device id that allows our backend to identify this device
   *
   * @generated from field: string device_id = 70;
   */
  deviceId = "";

  /**
   * Signature is generated as following:
   * - create a json web token with one claim vendor_device_id and an expiry no further than 10s from now
   * - sign the jwt with the device's RSA key
   * - jwt libraries will output the jwt as base64 encoded: this will be the value of the signature field
   * The reason why the expiry is required and time-sensitive is to avoid man-in-the-middle attacks.
   * Every AuthRequest should have a different signature as it should pick the current time + 10s for expiry.
   * Sending the same signature twice (ie, with the same expiry time), will be rejected.
   * Note: for the sake of testing, the max expiry is configurable in the backend, on non-prod environments,
   * so this RPC might accept an expiry greater than 10s.
   *
   * @generated from field: string signature = 90;
   */
  signature = "";

  constructor(data?: PartialMessage<AuthenticateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.AuthenticateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "vendor_device_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 20, name: "vendor_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "os", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 40,
      name: "os_version",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 50,
      name: "app_version",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 60, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 70, name: "device_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 90, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AuthenticateRequest {
    return new AuthenticateRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AuthenticateRequest {
    return new AuthenticateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AuthenticateRequest {
    return new AuthenticateRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: AuthenticateRequest | PlainMessage<AuthenticateRequest> | undefined,
    b: AuthenticateRequest | PlainMessage<AuthenticateRequest> | undefined
  ): boolean {
    return proto3.util.equals(AuthenticateRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.AuthenticateResponse
 */
export class AuthenticateResponse extends Message<AuthenticateResponse> {
  /**
   * @generated from oneof auth.v1.AuthenticateResponse.result
   */
  result:
    | {
        /**
         * @generated from field: auth.v1.AuthenticateResponse.Error error = 10;
         */
        value: AuthenticateResponse_Error;
        case: "error";
      }
    | {
        /**
         * @generated from field: auth.v1.AuthCredentials credentials = 11;
         */
        value: AuthCredentials;
        case: "credentials";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AuthenticateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.AuthenticateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(AuthenticateResponse_Error),
      oneof: "result",
    },
    {
      no: 11,
      name: "credentials",
      kind: "message",
      T: AuthCredentials,
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AuthenticateResponse {
    return new AuthenticateResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AuthenticateResponse {
    return new AuthenticateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AuthenticateResponse {
    return new AuthenticateResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: AuthenticateResponse | PlainMessage<AuthenticateResponse> | undefined,
    b: AuthenticateResponse | PlainMessage<AuthenticateResponse> | undefined
  ): boolean {
    return proto3.util.equals(AuthenticateResponse, a, b);
  }
}

/**
 * @generated from enum auth.v1.AuthenticateResponse.Error
 */
export enum AuthenticateResponse_Error {
  /**
   * Protobuf defaults to this if server adds new enum values that are unknown to the client,
   * and should be treated as an error
   *
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Token is invalid, or does not contain the right claims, or is expired,
   * or the signature does not match the device pubkey registered on the server,
   * or it has already been used.
   *
   * @generated from enum value: ERROR_INVALID = 1;
   */
  INVALID = 1,

  /**
   * App version is too old and user should be forced to update in their app store
   *
   * @generated from enum value: ERROR_DEPRECATED = 2;
   */
  DEPRECATED = 2,

  /**
   * Either the device_id doesn't exist in our database, or it has been inactivated,
   * or the vendor_device_id and vendor_id do not correspond.
   * Either way, the device needs to be registered again (DeviceService.Register())
   *
   * @generated from enum value: ERROR_INACTIVE = 3;
   */
  INACTIVE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AuthenticateResponse_Error)
proto3.util.setEnumType(
  AuthenticateResponse_Error,
  "auth.v1.AuthenticateResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_INVALID" },
    { no: 2, name: "ERROR_DEPRECATED" },
    { no: 3, name: "ERROR_INACTIVE" },
  ]
);

/**
 * @generated from message auth.v1.AuthCredentials
 */
export class AuthCredentials extends Message<AuthCredentials> {
  /**
   * @generated from field: string access_token = 10;
   */
  accessToken = "";

  /**
   * @generated from field: string refresh_token = 20;
   */
  refreshToken = "";

  /**
   * @generated from field: int64 access_token_expiry_sec = 30;
   */
  accessTokenExpirySec = protoInt64.zero;

  /**
   * @generated from field: int64 refresh_token_expiry_sec = 40;
   */
  refreshTokenExpirySec = protoInt64.zero;

  constructor(data?: PartialMessage<AuthCredentials>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.AuthCredentials";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "access_token",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 20,
      name: "refresh_token",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 30,
      name: "access_token_expiry_sec",
      kind: "scalar",
      T: 3 /* ScalarType.INT64 */,
    },
    {
      no: 40,
      name: "refresh_token_expiry_sec",
      kind: "scalar",
      T: 3 /* ScalarType.INT64 */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AuthCredentials {
    return new AuthCredentials().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AuthCredentials {
    return new AuthCredentials().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AuthCredentials {
    return new AuthCredentials().fromJsonString(jsonString, options);
  }

  static equals(
    a: AuthCredentials | PlainMessage<AuthCredentials> | undefined,
    b: AuthCredentials | PlainMessage<AuthCredentials> | undefined
  ): boolean {
    return proto3.util.equals(AuthCredentials, a, b);
  }
}

/**
 * @generated from message auth.v1.RefreshRequest
 */
export class RefreshRequest extends Message<RefreshRequest> {
  /**
   * @generated from field: string refresh_token = 10;
   */
  refreshToken = "";

  /**
   * @generated from field: string device_id = 20;
   */
  deviceId = "";

  constructor(data?: PartialMessage<RefreshRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.RefreshRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "refresh_token",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 20, name: "device_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): RefreshRequest {
    return new RefreshRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): RefreshRequest {
    return new RefreshRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): RefreshRequest {
    return new RefreshRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: RefreshRequest | PlainMessage<RefreshRequest> | undefined,
    b: RefreshRequest | PlainMessage<RefreshRequest> | undefined
  ): boolean {
    return proto3.util.equals(RefreshRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.RefreshResponse
 */
export class RefreshResponse extends Message<RefreshResponse> {
  /**
   * @generated from oneof auth.v1.RefreshResponse.result
   */
  result:
    | {
        /**
         * @generated from field: auth.v1.RefreshResponse.Error error = 10;
         */
        value: RefreshResponse_Error;
        case: "error";
      }
    | {
        /**
         * @generated from field: auth.v1.AuthCredentials credentials = 11;
         */
        value: AuthCredentials;
        case: "credentials";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RefreshResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.RefreshResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(RefreshResponse_Error),
      oneof: "result",
    },
    {
      no: 11,
      name: "credentials",
      kind: "message",
      T: AuthCredentials,
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): RefreshResponse {
    return new RefreshResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): RefreshResponse {
    return new RefreshResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): RefreshResponse {
    return new RefreshResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: RefreshResponse | PlainMessage<RefreshResponse> | undefined,
    b: RefreshResponse | PlainMessage<RefreshResponse> | undefined
  ): boolean {
    return proto3.util.equals(RefreshResponse, a, b);
  }
}

/**
 * @generated from enum auth.v1.RefreshResponse.Error
 */
export enum RefreshResponse_Error {
  /**
   * Protobuf defaults to this if server adds new enum values that are unknown to the client,
   * and should be treated as an error.
   * App should bring user back to pin/biometrics screen and go through auth again and notify a bug.
   *
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The refresh token is valid but in the meantime the device has been unlinked from the user
   * and needs to register again.
   *
   * @generated from enum value: ERROR_INACTIVE = 2;
   */
  INACTIVE = 2,

  /**
   * Refresh cannot be used to generate new tokens (invalid, expired).
   * App should bring user back to pin/biometrics screen and go through auth again.
   *
   * @generated from enum value: ERROR_INVALID_REFRESH_TOKEN = 4;
   */
  INVALID_REFRESH_TOKEN = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(RefreshResponse_Error)
proto3.util.setEnumType(
  RefreshResponse_Error,
  "auth.v1.RefreshResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 2, name: "ERROR_INACTIVE" },
    { no: 4, name: "ERROR_INVALID_REFRESH_TOKEN" },
  ]
);

/**
 * @generated from message auth.v1.RegisterDeviceRequest
 */
export class RegisterDeviceRequest extends Message<RegisterDeviceRequest> {
  /**
   * required
   *
   * @generated from field: string vendor_device_id = 10;
   */
  vendorDeviceId = "";

  /**
   * required
   *
   * @generated from field: string vendor_id = 20;
   */
  vendorId = "";

  /**
   * required
   *
   * @generated from field: string os = 30;
   */
  os = "";

  /**
   * required
   *
   * @generated from field: string os_version = 40;
   */
  osVersion = "";

  /**
   * required
   *
   * @generated from field: string app_version = 50;
   */
  appVersion = "";

  /**
   * required, device name (eg: Martin's iPhone)
   *
   * @generated from field: string name = 60;
   */
  name = "";

  /**
   * RSA 4096 public key base64 encoded, if correctly generated should be 736 chars
   *
   * @generated from field: string public_key = 70;
   */
  publicKey = "";

  /**
   * In order to verify that the public key and signing algorithm is correct,
   * generate a signature as following:
   * - create a json web token with one string fields: vendor_device_id
   * - sign the jwt with the device's RSA key
   * - jwt libraries will output the jwt as base64 encoded: this will be the value of the signature field
   *
   * @generated from field: string signature = 80;
   */
  signature = "";

  constructor(data?: PartialMessage<RegisterDeviceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.RegisterDeviceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "vendor_device_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 20, name: "vendor_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "os", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 40,
      name: "os_version",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 50,
      name: "app_version",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 60, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 70,
      name: "public_key",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 80, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): RegisterDeviceRequest {
    return new RegisterDeviceRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): RegisterDeviceRequest {
    return new RegisterDeviceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): RegisterDeviceRequest {
    return new RegisterDeviceRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: RegisterDeviceRequest | PlainMessage<RegisterDeviceRequest> | undefined,
    b: RegisterDeviceRequest | PlainMessage<RegisterDeviceRequest> | undefined
  ): boolean {
    return proto3.util.equals(RegisterDeviceRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.RegisterDeviceResponse
 */
export class RegisterDeviceResponse extends Message<RegisterDeviceResponse> {
  /**
   * server-side device id, this is a UUID different than the vendor_device_id
   * devices must persist it for later usage, however this is not sensitive data
   *
   * @generated from field: string device_id = 10;
   */
  deviceId = "";

  constructor(data?: PartialMessage<RegisterDeviceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.RegisterDeviceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "device_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): RegisterDeviceResponse {
    return new RegisterDeviceResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): RegisterDeviceResponse {
    return new RegisterDeviceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): RegisterDeviceResponse {
    return new RegisterDeviceResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | RegisterDeviceResponse
      | PlainMessage<RegisterDeviceResponse>
      | undefined,
    b: RegisterDeviceResponse | PlainMessage<RegisterDeviceResponse> | undefined
  ): boolean {
    return proto3.util.equals(RegisterDeviceResponse, a, b);
  }
}

/**
 * @generated from message auth.v1.SignOutRequest
 */
export class SignOutRequest extends Message<SignOutRequest> {
  constructor(data?: PartialMessage<SignOutRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.SignOutRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): SignOutRequest {
    return new SignOutRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): SignOutRequest {
    return new SignOutRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): SignOutRequest {
    return new SignOutRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: SignOutRequest | PlainMessage<SignOutRequest> | undefined,
    b: SignOutRequest | PlainMessage<SignOutRequest> | undefined
  ): boolean {
    return proto3.util.equals(SignOutRequest, a, b);
  }
}

/**
 * @generated from message auth.v1.SignOutResponse
 */
export class SignOutResponse extends Message<SignOutResponse> {
  constructor(data?: PartialMessage<SignOutResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.SignOutResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): SignOutResponse {
    return new SignOutResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): SignOutResponse {
    return new SignOutResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): SignOutResponse {
    return new SignOutResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: SignOutResponse | PlainMessage<SignOutResponse> | undefined,
    b: SignOutResponse | PlainMessage<SignOutResponse> | undefined
  ): boolean {
    return proto3.util.equals(SignOutResponse, a, b);
  }
}
