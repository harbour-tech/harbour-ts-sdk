// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file crypto_payment/v1/public.proto (package crypto_payment.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message crypto_payment.v1.PingRequest
 */
export class PingRequest extends Message<PingRequest> {
  constructor(data?: PartialMessage<PingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.PingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): PingRequest {
    return new PingRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): PingRequest {
    return new PingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): PingRequest {
    return new PingRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: PingRequest | PlainMessage<PingRequest> | undefined,
    b: PingRequest | PlainMessage<PingRequest> | undefined
  ): boolean {
    return proto3.util.equals(PingRequest, a, b);
  }
}

/**
 * @generated from message crypto_payment.v1.PingResponse
 */
export class PingResponse extends Message<PingResponse> {
  /**
   * @generated from field: string message = 10;
   */
  message = "";

  constructor(data?: PartialMessage<PingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.PingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): PingResponse {
    return new PingResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): PingResponse {
    return new PingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): PingResponse {
    return new PingResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: PingResponse | PlainMessage<PingResponse> | undefined,
    b: PingResponse | PlainMessage<PingResponse> | undefined
  ): boolean {
    return proto3.util.equals(PingResponse, a, b);
  }
}

/**
 * @generated from message crypto_payment.v1.GetWhitelistRequest
 */
export class GetWhitelistRequest extends Message<GetWhitelistRequest> {
  /**
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * network - optional parameter, if specified, the endpoint returns only the whitelist entries from the specified network
   *
   * @generated from field: optional string network = 20;
   */
  network?: string;

  constructor(data?: PartialMessage<GetWhitelistRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.GetWhitelistRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "network",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      opt: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetWhitelistRequest {
    return new GetWhitelistRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetWhitelistRequest {
    return new GetWhitelistRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetWhitelistRequest {
    return new GetWhitelistRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetWhitelistRequest | PlainMessage<GetWhitelistRequest> | undefined,
    b: GetWhitelistRequest | PlainMessage<GetWhitelistRequest> | undefined
  ): boolean {
    return proto3.util.equals(GetWhitelistRequest, a, b);
  }
}

/**
 * @generated from message crypto_payment.v1.GetWhitelistResponse
 */
export class GetWhitelistResponse extends Message<GetWhitelistResponse> {
  /**
   * @generated from field: repeated crypto_payment.v1.WhitelistEntry entries = 10;
   */
  entries: WhitelistEntry[] = [];

  constructor(data?: PartialMessage<GetWhitelistResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.GetWhitelistResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "entries",
      kind: "message",
      T: WhitelistEntry,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetWhitelistResponse {
    return new GetWhitelistResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetWhitelistResponse {
    return new GetWhitelistResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetWhitelistResponse {
    return new GetWhitelistResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetWhitelistResponse | PlainMessage<GetWhitelistResponse> | undefined,
    b: GetWhitelistResponse | PlainMessage<GetWhitelistResponse> | undefined
  ): boolean {
    return proto3.util.equals(GetWhitelistResponse, a, b);
  }
}

/**
 * @generated from message crypto_payment.v1.WhitelistEntry
 */
export class WhitelistEntry extends Message<WhitelistEntry> {
  /**
   * @generated from field: string id = 10;
   */
  id = "";

  /**
   * @generated from field: string network_id = 20;
   */
  networkId = "";

  /**
   * a mandatory nickname/alias to allow users to easily identify this address, with a minimum of 2 and up to 100 chars
   *
   * @generated from field: string name = 30;
   */
  name = "";

  /**
   * mandatory on-chain address which can be used to transfer funds to, with a minimum of 3 and up to 256 chars
   *
   * @generated from field: string address = 40;
   */
  address = "";

  constructor(data?: PartialMessage<WhitelistEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.WhitelistEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 20,
      name: "network_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 30, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): WhitelistEntry {
    return new WhitelistEntry().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): WhitelistEntry {
    return new WhitelistEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): WhitelistEntry {
    return new WhitelistEntry().fromJsonString(jsonString, options);
  }

  static equals(
    a: WhitelistEntry | PlainMessage<WhitelistEntry> | undefined,
    b: WhitelistEntry | PlainMessage<WhitelistEntry> | undefined
  ): boolean {
    return proto3.util.equals(WhitelistEntry, a, b);
  }
}

/**
 * @generated from message crypto_payment.v1.AddToWhitelistRequest
 */
export class AddToWhitelistRequest extends Message<AddToWhitelistRequest> {
  /**
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * the name of this entry which can be displayed to the user (the maximum length of the name is 100 symbols)
   *
   * @generated from field: string name = 20;
   */
  name = "";

  /**
   * on-chain address
   *
   * @generated from field: string address = 30;
   */
  address = "";

  /**
   * network - the identification of the network, to which belongs the on-chain address
   * possible values: bitcoin-mainnet, bitcoin-testnet, ethereum-mainnet, ethereum-goerli...
   *
   * @generated from field: string network = 40;
   */
  network = "";

  /**
   * this option can be set to true to validate all the parameters without actually creating any
   * entries. Response to the dry run can contain either error or an empty token in the result - it means
   * the dry run was successfully executed without errors
   *
   * @generated from field: bool dry_run = 50;
   */
  dryRun = false;

  constructor(data?: PartialMessage<AddToWhitelistRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.AddToWhitelistRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 50, name: "dry_run", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AddToWhitelistRequest {
    return new AddToWhitelistRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AddToWhitelistRequest {
    return new AddToWhitelistRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AddToWhitelistRequest {
    return new AddToWhitelistRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: AddToWhitelistRequest | PlainMessage<AddToWhitelistRequest> | undefined,
    b: AddToWhitelistRequest | PlainMessage<AddToWhitelistRequest> | undefined
  ): boolean {
    return proto3.util.equals(AddToWhitelistRequest, a, b);
  }
}

/**
 * @generated from message crypto_payment.v1.AddToWhitelistResponse
 */
export class AddToWhitelistResponse extends Message<AddToWhitelistResponse> {
  /**
   * @generated from oneof crypto_payment.v1.AddToWhitelistResponse.result
   */
  result:
    | {
        /**
         * @generated from field: crypto_payment.v1.AddToWhitelistResponse.Error error = 1;
         */
        value: AddToWhitelistResponse_Error;
        case: "error";
      }
    | {
        /**
         * @generated from field: string token = 2;
         */
        value: string;
        case: "token";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AddToWhitelistResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.AddToWhitelistResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(AddToWhitelistResponse_Error),
      oneof: "result",
    },
    {
      no: 2,
      name: "token",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AddToWhitelistResponse {
    return new AddToWhitelistResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AddToWhitelistResponse {
    return new AddToWhitelistResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AddToWhitelistResponse {
    return new AddToWhitelistResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | AddToWhitelistResponse
      | PlainMessage<AddToWhitelistResponse>
      | undefined,
    b: AddToWhitelistResponse | PlainMessage<AddToWhitelistResponse> | undefined
  ): boolean {
    return proto3.util.equals(AddToWhitelistResponse, a, b);
  }
}

/**
 * @generated from enum crypto_payment.v1.AddToWhitelistResponse.Error
 */
export enum AddToWhitelistResponse_Error {
  /**
   * is not used right now - linter requires this to be here
   *
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * returned when there is already such a combination {user_id, address, asset} in the database
   *
   * @generated from enum value: ERROR_ALREADY_EXIST = 1;
   */
  ALREADY_EXIST = 1,

  /**
   * returned if the specified address is not valid for the specified asset in the request
   *
   * @generated from enum value: ERROR_ADDRESS_INVALID = 2;
   */
  ADDRESS_INVALID = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AddToWhitelistResponse_Error)
proto3.util.setEnumType(
  AddToWhitelistResponse_Error,
  "crypto_payment.v1.AddToWhitelistResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_ALREADY_EXIST" },
    { no: 2, name: "ERROR_ADDRESS_INVALID" },
  ]
);

/**
 * @generated from message crypto_payment.v1.AddToWhitelistConfirmRequest
 */
export class AddToWhitelistConfirmRequest extends Message<AddToWhitelistConfirmRequest> {
  /**
   * @generated from field: string otp = 10;
   */
  otp = "";

  /**
   * @generated from field: string token = 20;
   */
  token = "";

  constructor(data?: PartialMessage<AddToWhitelistConfirmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.AddToWhitelistConfirmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "otp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AddToWhitelistConfirmRequest {
    return new AddToWhitelistConfirmRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AddToWhitelistConfirmRequest {
    return new AddToWhitelistConfirmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AddToWhitelistConfirmRequest {
    return new AddToWhitelistConfirmRequest().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | AddToWhitelistConfirmRequest
      | PlainMessage<AddToWhitelistConfirmRequest>
      | undefined,
    b:
      | AddToWhitelistConfirmRequest
      | PlainMessage<AddToWhitelistConfirmRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(AddToWhitelistConfirmRequest, a, b);
  }
}

/**
 * @generated from message crypto_payment.v1.AddToWhitelistConfirmResponse
 */
export class AddToWhitelistConfirmResponse extends Message<AddToWhitelistConfirmResponse> {
  /**
   * @generated from oneof crypto_payment.v1.AddToWhitelistConfirmResponse.result
   */
  result:
    | {
        /**
         * @generated from field: crypto_payment.v1.AddToWhitelistConfirmResponse.Error error = 10;
         */
        value: AddToWhitelistConfirmResponse_Error;
        case: "error";
      }
    | {
        /**
         * the id of the created entry in the whitelist - can be used later on in the withdraw process -
         * which actually requires this id
         *
         * @generated from field: string whitelist_id = 20;
         */
        value: string;
        case: "whitelistId";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AddToWhitelistConfirmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.AddToWhitelistConfirmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(AddToWhitelistConfirmResponse_Error),
      oneof: "result",
    },
    {
      no: 20,
      name: "whitelist_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): AddToWhitelistConfirmResponse {
    return new AddToWhitelistConfirmResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): AddToWhitelistConfirmResponse {
    return new AddToWhitelistConfirmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): AddToWhitelistConfirmResponse {
    return new AddToWhitelistConfirmResponse().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | AddToWhitelistConfirmResponse
      | PlainMessage<AddToWhitelistConfirmResponse>
      | undefined,
    b:
      | AddToWhitelistConfirmResponse
      | PlainMessage<AddToWhitelistConfirmResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(AddToWhitelistConfirmResponse, a, b);
  }
}

/**
 * @generated from enum crypto_payment.v1.AddToWhitelistConfirmResponse.Error
 */
export enum AddToWhitelistConfirmResponse_Error {
  /**
   * when we get unspecified error from the auth service (shouldn't be the case in normal situations)
   *
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ERROR_OTP_INVALID = 1;
   */
  OTP_INVALID = 1,

  /**
   * when the OTP code is already expired
   *
   * @generated from enum value: ERROR_OTP_EXPIRED = 2;
   */
  OTP_EXPIRED = 2,

  /**
   * OTP code is marked as used in the database
   *
   * @generated from enum value: ERROR_OTP_ALREADY_USED = 3;
   */
  OTP_ALREADY_USED = 3,

  /**
   * malformed token or wrong signature
   *
   * @generated from enum value: ERROR_TOKEN_INVALID = 4;
   */
  TOKEN_INVALID = 4,

  /**
   * this whitelist entry already exists in the database (same combination of {user_id,address,asset})
   *
   * @generated from enum value: ERROR_ALREADY_EXIST = 5;
   */
  ALREADY_EXIST = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(AddToWhitelistConfirmResponse_Error)
proto3.util.setEnumType(
  AddToWhitelistConfirmResponse_Error,
  "crypto_payment.v1.AddToWhitelistConfirmResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_OTP_INVALID" },
    { no: 2, name: "ERROR_OTP_EXPIRED" },
    { no: 3, name: "ERROR_OTP_ALREADY_USED" },
    { no: 4, name: "ERROR_TOKEN_INVALID" },
    { no: 5, name: "ERROR_ALREADY_EXIST" },
  ]
);

/**
 * @generated from message crypto_payment.v1.WithdrawAssetRequest
 */
export class WithdrawAssetRequest extends Message<WithdrawAssetRequest> {
  /**
   * mandatory id of the user requesting the withdrawal
   *
   * @generated from field: string user_id = 10;
   */
  userId = "";

  /**
   * mandatory id of the crypto account - the id of the crypto account entity returned by the wallet API
   * an invalid account will result in a code invalid argument
   *
   * @generated from field: string crypto_account_id = 30;
   */
  cryptoAccountId = "";

  /**
   * mandatory whitelist id
   * an invalid whitelist id has its own custom error type, as another device could remove a whitelist
   * without the user's current device knowing
   *
   * @generated from field: string whitelist_id = 40;
   */
  whitelistId = "";

  /**
   * mandatory amount to be received by counterparty, on top of which fees will be added
   * must be positive, else a code invalid argument is returned
   * there's also a minimum and a maximum amount that can be sent, which the client needs to fetch via a dedicated RPC
   *
   * @generated from field: string net_amount = 50;
   */
  netAmount = "";

  /**
   * network fee which should be paid by user in order to withdraw funds to external address.
   * it should be request with EstimateWithdrawalFeeRequest and re-requested before "valid_until" of
   * EstimateWithdrawalFeeResponse
   *
   * @generated from field: string fee = 55;
   */
  fee = "";

  /**
   * this flag can be used to validate all the parameters without actually making any withdrawals
   *
   * @generated from field: bool dry_run = 60;
   */
  dryRun = false;

  /**
   * idempotency key to avoid double spend
   *
   * @generated from field: string idempotency_key = 70;
   */
  idempotencyKey = "";

  /**
   * standard jwt with vendor_device_id claim and strict expiry, same as when authenticating
   * note: if this is built incorrectly you'll get a grpc code invalid argument
   *
   * @generated from field: string signature = 80;
   */
  signature = "";

  constructor(data?: PartialMessage<WithdrawAssetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.WithdrawAssetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 30,
      name: "crypto_account_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 40,
      name: "whitelist_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 50,
      name: "net_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 55, name: "fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 60, name: "dry_run", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    {
      no: 70,
      name: "idempotency_key",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 80, name: "signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): WithdrawAssetRequest {
    return new WithdrawAssetRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): WithdrawAssetRequest {
    return new WithdrawAssetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): WithdrawAssetRequest {
    return new WithdrawAssetRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: WithdrawAssetRequest | PlainMessage<WithdrawAssetRequest> | undefined,
    b: WithdrawAssetRequest | PlainMessage<WithdrawAssetRequest> | undefined
  ): boolean {
    return proto3.util.equals(WithdrawAssetRequest, a, b);
  }
}

/**
 * @generated from message crypto_payment.v1.WithdrawAssetResponse
 */
export class WithdrawAssetResponse extends Message<WithdrawAssetResponse> {
  /**
   * @generated from oneof crypto_payment.v1.WithdrawAssetResponse.result
   */
  result:
    | {
        /**
         * @generated from field: crypto_payment.v1.WithdrawAssetResponse.Error error = 10;
         */
        value: WithdrawAssetResponse_Error;
        case: "error";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<WithdrawAssetResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.WithdrawAssetResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 10,
      name: "error",
      kind: "enum",
      T: proto3.getEnumType(WithdrawAssetResponse_Error),
      oneof: "result",
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): WithdrawAssetResponse {
    return new WithdrawAssetResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): WithdrawAssetResponse {
    return new WithdrawAssetResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): WithdrawAssetResponse {
    return new WithdrawAssetResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: WithdrawAssetResponse | PlainMessage<WithdrawAssetResponse> | undefined,
    b: WithdrawAssetResponse | PlainMessage<WithdrawAssetResponse> | undefined
  ): boolean {
    return proto3.util.equals(WithdrawAssetResponse, a, b);
  }
}

/**
 * @generated from enum crypto_payment.v1.WithdrawAssetResponse.Error
 */
export enum WithdrawAssetResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * whitelist entry with the ID provided in the request was not found in the DB
   * can only happen if another device deletes the entry at around the same time, which is highly unlikely
   *
   * @generated from enum value: ERROR_INVALID_WHITELIST_ID = 1;
   */
  INVALID_WHITELIST_ID = 1,

  /**
   * insufficient funds on the account to withdraw
   *
   * @generated from enum value: ERROR_INSUFFICIENT_BALANCE = 2;
   */
  INSUFFICIENT_BALANCE = 2,

  /**
   * there's single tx / daily / monthly spending limits associated with each user
   *
   * @generated from enum value: ERROR_LIMITS_EXCEED = 3;
   */
  LIMITS_EXCEED = 3,

  /**
   * account is blocked (possibly temporarily) from sending assets out of Harbor
   *
   * @generated from enum value: ERROR_BLOCKED = 4;
   */
  BLOCKED = 4,

  /**
   * Client submitted an amount < than the minimum withdrawable for this asset.
   * The client should always retrieve the min amount from our API before submitting a request.
   * If this happens, either the client has a bug in interpreting our API, or it was unlucky enough that the
   * backend-configured min amount changed in between the two requests.
   * Handle this error gracefully and just tell the user the amount is below minimum.
   *
   * @generated from enum value: ERROR_MIN_AMOUNT = 5;
   */
  MIN_AMOUNT = 5,

  /**
   * Withdrawal fee is to low, this might happen because of spike in network fees or client didn't
   * poll new fee after "valid_until" of EstimateWithdrawalFeeResponse. Fee need to be re-requested and withdraw
   * request retried
   *
   * @generated from enum value: ERROR_MIN_FEE = 6;
   */
  MIN_FEE = 6,

  /**
   * Client submitted an amount with decimal digits more than allowed for this asset.
   * i.e. 1.00001 USDC while the max allowed precision for USDC is 2 decimal digist,
   * so it's only allowed to withdraw 1.01
   * same goes for other assets but with other allowed precision.
   *
   * @generated from enum value: ERROR_PRECISION_EXCEEDED = 7;
   */
  PRECISION_EXCEEDED = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(WithdrawAssetResponse_Error)
proto3.util.setEnumType(
  WithdrawAssetResponse_Error,
  "crypto_payment.v1.WithdrawAssetResponse.Error",
  [
    { no: 0, name: "ERROR_UNSPECIFIED" },
    { no: 1, name: "ERROR_INVALID_WHITELIST_ID" },
    { no: 2, name: "ERROR_INSUFFICIENT_BALANCE" },
    { no: 3, name: "ERROR_LIMITS_EXCEED" },
    { no: 4, name: "ERROR_BLOCKED" },
    { no: 5, name: "ERROR_MIN_AMOUNT" },
    { no: 6, name: "ERROR_MIN_FEE" },
    { no: 7, name: "ERROR_PRECISION_EXCEEDED" },
  ]
);

/**
 * @generated from message crypto_payment.v1.EstimateWithdrawalFeeRequest
 */
export class EstimateWithdrawalFeeRequest extends Message<EstimateWithdrawalFeeRequest> {
  /**
   * @generated from field: string asset_id = 10;
   */
  assetId = "";

  constructor(data?: PartialMessage<EstimateWithdrawalFeeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.EstimateWithdrawalFeeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "asset_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): EstimateWithdrawalFeeRequest {
    return new EstimateWithdrawalFeeRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): EstimateWithdrawalFeeRequest {
    return new EstimateWithdrawalFeeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): EstimateWithdrawalFeeRequest {
    return new EstimateWithdrawalFeeRequest().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | EstimateWithdrawalFeeRequest
      | PlainMessage<EstimateWithdrawalFeeRequest>
      | undefined,
    b:
      | EstimateWithdrawalFeeRequest
      | PlainMessage<EstimateWithdrawalFeeRequest>
      | undefined
  ): boolean {
    return proto3.util.equals(EstimateWithdrawalFeeRequest, a, b);
  }
}

/**
 * @generated from message crypto_payment.v1.EstimateWithdrawalFeeResponse
 */
export class EstimateWithdrawalFeeResponse extends Message<EstimateWithdrawalFeeResponse> {
  /**
   * estimates fee denominated in currency of request
   *
   * @generated from field: string fee = 10;
   */
  fee = "";

  /**
   * until when fee is valid, after that new fee estimation should be polled again
   *
   * @generated from field: google.protobuf.Timestamp valid_until = 20;
   */
  validUntil?: Timestamp;

  constructor(data?: PartialMessage<EstimateWithdrawalFeeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "crypto_payment.v1.EstimateWithdrawalFeeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "valid_until", kind: "message", T: Timestamp },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): EstimateWithdrawalFeeResponse {
    return new EstimateWithdrawalFeeResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): EstimateWithdrawalFeeResponse {
    return new EstimateWithdrawalFeeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): EstimateWithdrawalFeeResponse {
    return new EstimateWithdrawalFeeResponse().fromJsonString(
      jsonString,
      options
    );
  }

  static equals(
    a:
      | EstimateWithdrawalFeeResponse
      | PlainMessage<EstimateWithdrawalFeeResponse>
      | undefined,
    b:
      | EstimateWithdrawalFeeResponse
      | PlainMessage<EstimateWithdrawalFeeResponse>
      | undefined
  ): boolean {
    return proto3.util.equals(EstimateWithdrawalFeeResponse, a, b);
  }
}
