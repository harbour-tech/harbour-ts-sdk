// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file ramp/v1/public.proto (package ramp.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file ramp/v1/public.proto.
 */
export const file_ramp_v1_public: GenFile = /*@__PURE__*/
  fileDesc("ChRyYW1wL3YxL3B1YmxpYy5wcm90bxIHcmFtcC52MSINCgtQaW5nUmVxdWVzdCIfCgxQaW5nUmVzcG9uc2USDwoHbWVzc2FnZRgKIAEoCSJFChVHZXRBY2NvdW50SW5mb1JlcXVlc3QSGgoNcmVmZXJyYWxfY29kZRgKIAEoCUgAiAEBQhAKDl9yZWZlcnJhbF9jb2RlIsATChZHZXRBY2NvdW50SW5mb1Jlc3BvbnNlEkgKDmF1dGhlbnRpY2F0aW9uGBQgASgLMi4ucmFtcC52MS5HZXRBY2NvdW50SW5mb1Jlc3BvbnNlLkF1dGhlbnRpY2F0aW9uSAASOgoHYWNjb3VudBgeIAEoCzInLnJhbXAudjEuR2V0QWNjb3VudEluZm9SZXNwb25zZS5BY2NvdW50SAAaRAoOQXV0aGVudGljYXRpb24SGgoSYXV0aGVudGljYXRpb25fdXJsGAogASgJEhYKDmV4cGlyZXNfaW5fc2VjGBQgASgDGuwECgdBY2NvdW50EjcKB3dhbGxldHMYCiADKAsyJi5yYW1wLnYxLkdldEFjY291bnRJbmZvUmVzcG9uc2UuV2FsbGV0Ei8KC29ucmFtcF9zY2FuGGQgASgLMhgucmFtcC52MS5TY2FuQ29vcmRpbmF0ZXNIABIvCgtvbnJhbXBfaWJhbhhuIAEoCzIYLnJhbXAudjEuSWJhbkNvb3JkaW5hdGVzSAASMQoMb2ZmcmFtcF9zY2FuGMgBIAEoCzIYLnJhbXAudjEuU2NhbkNvb3JkaW5hdGVzSAESMQoMb2ZmcmFtcF9pYmFuGNIBIAEoCzIYLnJhbXAudjEuSWJhbkNvb3JkaW5hdGVzSAESFgoOYWNjb3VudF9ob2xkZXIYFCABKAkSFQoNZW1haWxfYWRkcmVzcxgZIAEoCRJCCg1jcnlwdG9fYXNzZXRzGB4gAygLMisucmFtcC52MS5HZXRBY2NvdW50SW5mb1Jlc3BvbnNlLkNyeXB0b0Fzc2V0Ej0KBmxpbWl0cxgoIAEoCzItLnJhbXAudjEuR2V0QWNjb3VudEluZm9SZXNwb25zZS5BY2NvdW50TGltaXRzEkMKBnJld2FyZBgyIAEoCzIuLnJhbXAudjEuR2V0QWNjb3VudEluZm9SZXNwb25zZS5BY2NvdW50LlJld2FyZEgCiAEBGi8KBlJld2FyZBIOCgZwb2ludHMYCiABKAMSFQoNcmVmZXJyYWxfY29kZRgUIAEoCUIVChNvbnJhbXBfYmFua19hY2NvdW50QhYKFG9mZnJhbXBfYmFua19hY2NvdW50QgkKB19yZXdhcmQa8wcKC0NyeXB0b0Fzc2V0EkYKBnN0YXR1cxgBIAEoCzI2LnJhbXAudjEuR2V0QWNjb3VudEluZm9SZXNwb25zZS5DcnlwdG9Bc3NldC5SYW1wU3RhdHVzEiMKCHByb3RvY29sGAUgASgOMhEucmFtcC52MS5Qcm90b2NvbBIhCgduZXR3b3JrGAogASgOMhAucmFtcC52MS5OZXR3b3JrEiIKCGFzc2V0X2lkGBQgASgOMhAucmFtcC52MS5Bc3NldElkEhIKCnNob3J0X25hbWUYHiABKAkSDgoGc3ltYm9sGCMgASgJEl4KFGV0aGVyZXVtX2VyYzIwX3Rva2VuGCggASgLMj4ucmFtcC52MS5HZXRBY2NvdW50SW5mb1Jlc3BvbnNlLkNyeXB0b0Fzc2V0LkV0aGVyZXVtRXJjMjBUb2tlbkgAEloKEmNvc21vc19pY3MyMF90b2tlbhgyIAEoCzI8LnJhbXAudjEuR2V0QWNjb3VudEluZm9SZXNwb25zZS5DcnlwdG9Bc3NldC5Db3Ntb3NJY3MyMFRva2VuSAASYAoVc3Vic3RyYXRlX3BzcDIyX3Rva2VuGDwgASgLMj8ucmFtcC52MS5HZXRBY2NvdW50SW5mb1Jlc3BvbnNlLkNyeXB0b0Fzc2V0LlN1YnN0cmF0ZVBzcDIyVG9rZW5IABJVCg9ldGhlcmV1bV9uYXRpdmUYRiABKAsyOi5yYW1wLnYxLkdldEFjY291bnRJbmZvUmVzcG9uc2UuQ3J5cHRvQXNzZXQuRXRoZXJldW1OYXRpdmVIABorChJFdGhlcmV1bUVyYzIwVG9rZW4SFQoNdG9rZW5fYWRkcmVzcxgKIAEoCRonChBDb3Ntb3NJY3MyMFRva2VuEhMKC2liY19hZGRyZXNzGAogASgJGiwKE1N1YnN0cmF0ZVBzcDIyVG9rZW4SFQoNdG9rZW5fYWRkcmVzcxgKIAEoCRoQCg5FdGhlcmV1bU5hdGl2ZRr1AQoKUmFtcFN0YXR1cxJNCgZvbnJhbXAYCiABKA4yPS5yYW1wLnYxLkdldEFjY291bnRJbmZvUmVzcG9uc2UuQ3J5cHRvQXNzZXQuUmFtcFN0YXR1cy5TdGF0dXMSTgoHb2ZmcmFtcBgUIAEoDjI9LnJhbXAudjEuR2V0QWNjb3VudEluZm9SZXNwb25zZS5DcnlwdG9Bc3NldC5SYW1wU3RhdHVzLlN0YXR1cyJICgZTdGF0dXMSFgoSU1RBVFVTX1VOU1BFQ0lGSUVEEAASEwoPU1RBVFVTX0RFR1JBREVEEBQSEQoNU1RBVFVTX0hBTFRFRBAeQgkKB2RldGFpbHMamwMKBldhbGxldBIMCgRuYW1lGAUgASgJEiMKCHByb3RvY29sGAogASgOMhEucmFtcC52MS5Qcm90b2NvbBIPCgdhZGRyZXNzGBQgASgJEkAKBmFzc2V0cxgeIAMoCzIwLnJhbXAudjEuR2V0QWNjb3VudEluZm9SZXNwb25zZS5XYWxsZXQuUmFtcEFzc2V0GskBCglSYW1wQXNzZXQSOgoFYXNzZXQYCiABKAsyKy5yYW1wLnYxLkdldEFjY291bnRJbmZvUmVzcG9uc2UuQ3J5cHRvQXNzZXQSPgoHb25fcmFtcBgUIAEoCzItLnJhbXAudjEuR2V0QWNjb3VudEluZm9SZXNwb25zZS5XYWxsZXQuT25SYW1wEkAKCG9mZl9yYW1wGB4gASgLMi4ucmFtcC52MS5HZXRBY2NvdW50SW5mb1Jlc3BvbnNlLldhbGxldC5PZmZSYW1wGiMKBk9uUmFtcBIZChFwYXltZW50X3JlZmVyZW5jZRgKIAEoCRoaCgdPZmZSYW1wEg8KB2FkZHJlc3MYCiABKAkazAEKDUFjY291bnRMaW1pdHMSGwoTb25yYW1wX3NpbmdsZV9saW1pdBgKIAEoCRIaChJvbnJhbXBfZGFpbHlfbGltaXQYFCABKAkSIgoab25yYW1wX2N1cnJlbnRfZGFpbHlfdXNhZ2UYHiABKAkSHAoUb2ZmcmFtcF9zaW5nbGVfbGltaXQYKCABKAkSGwoTb2ZmcmFtcF9kYWlseV9saW1pdBgyIAEoCRIjChtvZmZyYW1wX2N1cnJlbnRfZGFpbHlfdXNhZ2UYPCABKAlCCAoGcmVzdWx0IrUCChdXaGl0ZWxpc3RBZGRyZXNzUmVxdWVzdBIQCgRuYW1lGAogASgJQgIYARIjCghwcm90b2NvbBgUIAEoDjIRLnJhbXAudjEuUHJvdG9jb2wSEwoHYWRkcmVzcxgeIAEoCUICGAESFgoKcHVibGljX2tleRgjIAEoCUICGAESHQoRYWRkcmVzc19zaWduYXR1cmUYKCABKAlCAhgBEkYKDnNpZ25lZF9hZGRyZXNzGDIgASgLMi4ucmFtcC52MS5XaGl0ZWxpc3RBZGRyZXNzUmVxdWVzdC5TaWduZWRBZGRyZXNzGk8KDVNpZ25lZEFkZHJlc3MSDwoHYWRkcmVzcxgeIAEoCRISCgpwdWJsaWNfa2V5GCMgASgJEhkKEWFkZHJlc3Nfc2lnbmF0dXJlGCggASgJIhoKGFdoaXRlbGlzdEFkZHJlc3NSZXNwb25zZSLfAQoeV2hpdGVsaXN0RXJjMTI3MUFkZHJlc3NSZXF1ZXN0EiMKCHByb3RvY29sGAogASgOMhEucmFtcC52MS5Qcm90b2NvbBJUCg5zaWduZWRfYWRkcmVzcxgUIAEoCzI8LnJhbXAudjEuV2hpdGVsaXN0RXJjMTI3MUFkZHJlc3NSZXF1ZXN0LlNpZ25lZEVyYzEyNzFBZGRyZXNzGkIKFFNpZ25lZEVyYzEyNzFBZGRyZXNzEg8KB2FkZHJlc3MYCiABKAkSGQoRYWRkcmVzc19zaWduYXR1cmUYFCABKAkiIQofV2hpdGVsaXN0RXJjMTI3MUFkZHJlc3NSZXNwb25zZSJMChRSZW1vdmVBZGRyZXNzUmVxdWVzdBIjCghwcm90b2NvbBgKIAEoDjIRLnJhbXAudjEuUHJvdG9jb2wSDwoHYWRkcmVzcxgeIAEoCSIXChVSZW1vdmVBZGRyZXNzUmVzcG9uc2UiewoVU2V0QmFua0FjY291bnRSZXF1ZXN0EigKBHNjYW4YCiABKAsyGC5yYW1wLnYxLlNjYW5Db29yZGluYXRlc0gAEigKBGliYW4YFCABKAsyGC5yYW1wLnYxLkliYW5Db29yZGluYXRlc0gAQg4KDGJhbmtfYWNjb3VudCLIAQoWU2V0QmFua0FjY291bnRSZXNwb25zZRI1CgZlcnJvcnMYCiADKA4yJS5yYW1wLnYxLlNldEJhbmtBY2NvdW50UmVzcG9uc2UuRXJyb3IidwoFRXJyb3ISFQoRRVJST1JfVU5TUEVDSUZJRUQQABIbChdFUlJPUl9CQU5LX0NPREVfSU5WQUxJRBABEh0KGUVSUk9SX0JBTktfTlVNQkVSX0lOVkFMSUQQAhIbChdFUlJPUl9TQU1FX0JBTktfQUNDT1VOVBADIvMBChhFc3RpbWF0ZU9uUmFtcEZlZVJlcXVlc3QSKgoNZmlhdF9hc3NldF9pZBgFIAEoDjITLnJhbXAudjEuQ3VycmVuY3lJZBIpCg9jcnlwdG9fYXNzZXRfaWQYCiABKA4yEC5yYW1wLnYxLkFzc2V0SWQSIwoIcHJvdG9jb2wYDyABKA4yES5yYW1wLnYxLlByb3RvY29sEhsKEWZpYXRfYXNzZXRfYW1vdW50GBQgASgJSAASDgoEY29kZRgeIAEoCUgBEhgKDndhbGxldF9hZGRyZXNzGCggASgJSAFCCAoGYW1vdW50QgoKCHJlZmVycmFsIt4BChlFc3RpbWF0ZU9uUmFtcEZlZVJlc3BvbnNlEhkKEWZpYXRfYXNzZXRfYW1vdW50GBQgASgJEhsKE2NyeXB0b19hc3NldF9hbW91bnQYHiABKAkSFQoNZXhjaGFuZ2VfcmF0ZRgoIAEoCRIaChJuZXR3b3JrX2ZlZV9hbW91bnQYMiABKAkSHQoVcHJvY2Vzc2luZ19mZWVfYW1vdW50GDwgASgJEhsKE3JlZmVycmFsX2ZlZV9hbW91bnQYRiABKAkSGgoSaW5zdGFudF9wcm9jZXNzaW5nGFAgASgIIvYBChlFc3RpbWF0ZU9mZlJhbXBGZWVSZXF1ZXN0EioKDWZpYXRfYXNzZXRfaWQYBSABKA4yEy5yYW1wLnYxLkN1cnJlbmN5SWQSKQoPY3J5cHRvX2Fzc2V0X2lkGAogASgOMhAucmFtcC52MS5Bc3NldElkEiMKCHByb3RvY29sGA8gASgOMhEucmFtcC52MS5Qcm90b2NvbBIdChNjcnlwdG9fYXNzZXRfYW1vdW50GBQgASgJSAASDgoEY29kZRgeIAEoCUgBEhgKDndhbGxldF9hZGRyZXNzGCggASgJSAFCCAoGYW1vdW50QgoKCHJlZmVycmFsIsMBChpFc3RpbWF0ZU9mZlJhbXBGZWVSZXNwb25zZRIZChFmaWF0X2Fzc2V0X2Ftb3VudBgUIAEoCRIbChNjcnlwdG9fYXNzZXRfYW1vdW50GB4gASgJEhUKDWV4Y2hhbmdlX3JhdGUYKCABKAkSHQoVcHJvY2Vzc2luZ19mZWVfYW1vdW50GDwgASgJEhsKE3JlZmVycmFsX2ZlZV9hbW91bnQYRiABKAkSGgoSaW5zdGFudF9wcm9jZXNzaW5nGFAgASgIIo0CCg9HZXRSYW1wc1JlcXVlc3QSIAoEcGFnZRgKIAEoCzINLnJhbXAudjEuUGFnZUgAiAEBEiQKCXJhbXBfdHlwZRgUIAEoDjIRLnJhbXAudjEuUmFtcFR5cGUSOwoKZGF0ZV9yYW5nZRgeIAEoCzIiLnJhbXAudjEuR2V0UmFtcHNSZXF1ZXN0LkRhdGVSYW5nZUgBiAEBGl0KCURhdGVSYW5nZRIoCgRmcm9tGAogASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBImCgJ0bxgUIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCBwoFX3BhZ2VCDQoLX2RhdGVfcmFuZ2Ui0gMKEEdldFJhbXBzUmVzcG9uc2USIgoEcGFnZRgKIAEoCzIULnJhbXAudjEuUGFnZWRSZXN1bHQSLQoFcmFtcHMYFCADKAsyHi5yYW1wLnYxLkdldFJhbXBzUmVzcG9uc2UuUmFtcBrqAgoEUmFtcBIKCgJpZBgKIAEoCRIfCgR0eXBlGBQgASgOMhEucmFtcC52MS5SYW1wVHlwZRImCgxjcnlwdG9fYXNzZXQYHiABKA4yEC5yYW1wLnYxLkFzc2V0SWQSEwoLZmlhdF9hbW91bnQYKCABKAkSFQoNY3J5cHRvX2Ftb3VudBgyIAEoCRIqCg93YWxsZXRfcHJvdG9jb2wYRiABKA4yES5yYW1wLnYxLlByb3RvY29sEhYKDndhbGxldF9hZGRyZXNzGFAgASgJEhoKEm5ldHdvcmtfZmVlX2Ftb3VudBhaIAEoCRIdChVwcm9jZXNzaW5nX2ZlZV9hbW91bnQYZCABKAkSMAoMZmluYWxpemVkX2F0GG4gASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIwCgxpbml0aWF0ZWRfYXQYeCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIj4KEEdldEFzc2V0c1JlcXVlc3QSKgoNZmlhdF9hc3NldF9pZBgKIAEoDjITLnJhbXAudjEuQ3VycmVuY3lJZCJAChFHZXRBc3NldHNSZXNwb25zZRIrCg1jcnlwdG9fYXNzZXRzGAogAygLMhQucmFtcC52MS5DcnlwdG9Bc3NldCKmAgoiUmVnaXN0ZXJSZWZlcnJhbFRyYW5zYWN0aW9uUmVxdWVzdBIVCg1yZWZlcnJhbF9jb2RlGAogASgJEhYKDndhbGxldF9hZGRyZXNzGBQgASgJEh8KBHR5cGUYHiABKA4yES5yYW1wLnYxLlJhbXBUeXBlEiUKCGN1cnJlbmN5GCggASgOMhMucmFtcC52MS5DdXJyZW5jeUlkEiYKDGNyeXB0b19hc3NldBgyIAEoDjIQLnJhbXAudjEuQXNzZXRJZBIwChVjcnlwdG9fYXNzZXRfcHJvdG9jb2wYPCABKA4yES5yYW1wLnYxLlByb3RvY29sEh8KF3JlZmVycmFsX3RyYW5zYWN0aW9uX2lkGEYgASgJEg4KBmFtb3VudBhQIAEoCSIlCiNSZWdpc3RlclJlZmVycmFsVHJhbnNhY3Rpb25SZXNwb25zZSLxCQoLQ3J5cHRvQXNzZXQSLwoGc3RhdHVzGAogASgLMh8ucmFtcC52MS5DcnlwdG9Bc3NldC5SYW1wU3RhdHVzEiMKCHByb3RvY29sGBQgASgOMhEucmFtcC52MS5Qcm90b2NvbBIhCgduZXR3b3JrGB4gASgOMhAucmFtcC52MS5OZXR3b3JrEiIKCGFzc2V0X2lkGCggASgOMhAucmFtcC52MS5Bc3NldElkEhIKCnNob3J0X25hbWUYMiABKAkSDgoGc3ltYm9sGDcgASgJEkcKFGV0aGVyZXVtX2VyYzIwX3Rva2VuGDwgASgLMicucmFtcC52MS5DcnlwdG9Bc3NldC5FdGhlcmV1bUVyYzIwVG9rZW5IABJDChJjb3Ntb3NfaWNzMjBfdG9rZW4YRiABKAsyJS5yYW1wLnYxLkNyeXB0b0Fzc2V0LkNvc21vc0ljczIwVG9rZW5IABJJChVzdWJzdHJhdGVfcHNwMjJfdG9rZW4YUCABKAsyKC5yYW1wLnYxLkNyeXB0b0Fzc2V0LlN1YnN0cmF0ZVBzcDIyVG9rZW5IABI+Cg9ldGhlcmV1bV9uYXRpdmUYWiABKAsyIy5yYW1wLnYxLkNyeXB0b0Fzc2V0LkV0aGVyZXVtTmF0aXZlSAASMgoNb25yYW1wX2xpbWl0cxhkIAEoCzIbLnJhbXAudjEuQ3J5cHRvQXNzZXQuTGltaXRzEjMKDm9mZnJhbXBfbGltaXRzGG4gASgLMhsucmFtcC52MS5DcnlwdG9Bc3NldC5MaW1pdHMaKwoSRXRoZXJldW1FcmMyMFRva2VuEhUKDXRva2VuX2FkZHJlc3MYCiABKAkaJwoQQ29zbW9zSWNzMjBUb2tlbhITCgtpYmNfYWRkcmVzcxgKIAEoCRosChNTdWJzdHJhdGVQc3AyMlRva2VuEhUKDXRva2VuX2FkZHJlc3MYCiABKAkaEAoORXRoZXJldW1OYXRpdmUaxwEKClJhbXBTdGF0dXMSNgoGb25yYW1wGAogASgOMiYucmFtcC52MS5DcnlwdG9Bc3NldC5SYW1wU3RhdHVzLlN0YXR1cxI3CgdvZmZyYW1wGBQgASgOMiYucmFtcC52MS5DcnlwdG9Bc3NldC5SYW1wU3RhdHVzLlN0YXR1cyJICgZTdGF0dXMSFgoSU1RBVFVTX1VOU1BFQ0lGSUVEEAASEwoPU1RBVFVTX0RFR1JBREVEEBQSEQoNU1RBVFVTX0hBTFRFRBAeGrMCCgZMaW1pdHMSPwoTc2luZ2xlX2xpbWl0X2Ftb3VudBgKIAEoCzIiLnJhbXAudjEuQ3J5cHRvQXNzZXQuTGltaXRzLkFtb3VudBI+ChJkYWlseV9saW1pdF9hbW91bnQYFCABKAsyIi5yYW1wLnYxLkNyeXB0b0Fzc2V0LkxpbWl0cy5BbW91bnQSPQoRZGFpbHlfdXNlZF9hbW91bnQYHiABKAsyIi5yYW1wLnYxLkNyeXB0b0Fzc2V0LkxpbWl0cy5BbW91bnQSQgoWZGFpbHlfcmVtYWluaW5nX2Ftb3VudBgoIAEoCzIiLnJhbXAudjEuQ3J5cHRvQXNzZXQuTGltaXRzLkFtb3VudBolCgZBbW91bnQSDQoFYXNzZXQYCiABKAkSDAoEZmlhdBgUIAEoCUIJCgdkZXRhaWxzIjwKD1NjYW5Db29yZGluYXRlcxIWCg5hY2NvdW50X251bWJlchgKIAEoCRIRCglzb3J0X2NvZGUYFCABKAkiHwoPSWJhbkNvb3JkaW5hdGVzEgwKBGliYW4YCiABKAkimwYKD1JhbXBUcmFuc2FjdGlvbhIWCg50cmFuc2FjdGlvbl9pZBgKIAEoCRIfChdyZWZlcnJhbF90cmFuc2FjdGlvbl9pZBgUIAEoCRIfCgR0eXBlGB4gASgOMhEucmFtcC52MS5SYW1wVHlwZRIjCgZzdGF0dXMYKCABKA4yEy5yYW1wLnYxLlJhbXBTdGF0dXMSJQoIY3VycmVuY3kYMiABKA4yEy5yYW1wLnYxLkN1cnJlbmN5SWQSKQoPY3J5cHRvX2Fzc2V0X2lkGDwgASgOMhAucmFtcC52MS5Bc3NldElkEjAKFWNyeXB0b19hc3NldF9wcm90b2NvbBhGIAEoDjIRLnJhbXAudjEuUHJvdG9jb2wSEwoLZmlhdF9hbW91bnQYUCABKAkSFQoNY3J5cHRvX2Ftb3VudBhaIAEoCRIVCg1leGNoYW5nZV9yYXRlGGQgASgJEisKBGZlZXMYbiABKAsyHS5yYW1wLnYxLlJhbXBUcmFuc2FjdGlvbi5GZWVzEhYKDndhbGxldF9hZGRyZXNzGHggASgJEhgKEHRyYW5zYWN0aW9uX2hhc2gYfSABKAkSMQoMZmluYWxpemVkX2F0GIIBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASMQoMaW5pdGlhdGVkX2F0GIwBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLwoOcGF5bWVudF9tZXRob2QYkQEgASgOMhYucmFtcC52MS5QYXltZW50TWV0aG9kEj8KDnVzZF9lc3RpbWF0aW9uGJYBIAEoCzImLnJhbXAudjEuUmFtcFRyYW5zYWN0aW9uLlVzZEVzdGltYXRpb24aPQoERmVlcxISCgpwcm9jZXNzaW5nGAogASgJEg8KB25ldHdvcmsYFCABKAkSEAoIcmVmZXJyYWwYHiABKAkaTAoNVXNkRXN0aW1hdGlvbhIOCgZhbW91bnQYCiABKAkSKwoEZmVlcxgUIAEoCzIdLnJhbXAudjEuUmFtcFRyYW5zYWN0aW9uLkZlZXMiFQoTR2V0Q291bnRyaWVzUmVxdWVzdCJ3ChRHZXRDb3VudHJpZXNSZXNwb25zZRI4Cgljb3VudHJpZXMYCiADKAsyJS5yYW1wLnYxLkdldENvdW50cmllc1Jlc3BvbnNlLkNvdW50cnkaJQoHQ291bnRyeRIMCgRjb2RlGAogASgJEgwKBG5hbWUYFCABKAkiQAoEUGFnZRISCgVpbmRleBgKIAEoBEgAiAEBEhEKBHNpemUYFCABKARIAYgBAUIICgZfaW5kZXhCBwoFX3NpemUiPAoLUGFnZWRSZXN1bHQSDQoFaW5kZXgYCiABKAQSDAoEc2l6ZRgUIAEoBBIQCghoYXNfbW9yZRgeIAEoCCIvChZTZXRFbWFpbEFkZHJlc3NSZXF1ZXN0EhUKDWVtYWlsX2FkZHJlc3MYCiABKAkiGQoXU2V0RW1haWxBZGRyZXNzUmVzcG9uc2UqVAoIUmFtcFR5cGUSGQoVUkFNUF9UWVBFX1VOU1BFQ0lGSUVEEAASFQoRUkFNUF9UWVBFX09OX1JBTVAQChIWChJSQU1QX1RZUEVfT0ZGX1JBTVAQFCpdCgpSYW1wU3RhdHVzEhsKF1JBTVBfU1RBVFVTX1VOU1BFQ0lGSUVEEAASFwoTUkFNUF9TVEFUVVNfUEVORElORxAKEhkKFVJBTVBfU1RBVFVTX0NPTVBMRVRFRBAUKoMBCglFY29zeXN0ZW0SGQoVRUNPU1lTVEVNX1VOU1BFQ0lGSUVEEAASFgoSRUNPU1lTVEVNX0VUSEVSRVVNEAoSFAoQRUNPU1lTVEVNX0NPU01PUxAUEhcKE0VDT1NZU1RFTV9TVUJTVFJBVEUQHhIUChBFQ09TWVNURU1fU09MQU5BECgqiAIKCFByb3RvY29sEhgKFFBST1RPQ09MX1VOU1BFQ0lGSUVEEAASFQoRUFJPVE9DT0xfRVRIRVJFVU0QChIRCg1QUk9UT0NPTF9BVkFYEBQSEgoOUFJPVE9DT0xfVEVSUkEQHhIUChBQUk9UT0NPTF9QT0xZR09OECgSGwoTUFJPVE9DT0xfQUxFUEhfWkVSTxAyGgIIARIaChZQUk9UT0NPTF9BTEVQSF9aRVJPX0wyEDwSFQoRUFJPVE9DT0xfUE9MS0FET1QQRhISCg5QUk9UT0NPTF9OT0JMRRBQEhUKEVBST1RPQ09MX0FSQklUUlVNEFoSEwoPUFJPVE9DT0xfU09MQU5BEGQqlwEKB0Fzc2V0SWQSGAoUQVNTRVRfSURfVU5TUEVDSUZJRUQQABIRCg1BU1NFVF9JRF9VU0RDEAoSFQoRQVNTRVRfSURfQVhMX1VTREMQFBIRCg1BU1NFVF9JRF8xVVNEEB4SEAoMQVNTRVRfSURfRVRIECgSEAoMQVNTRVRfSURfRE9UEDISEQoNQVNTRVRfSURfVVNERRA8KlMKCkN1cnJlbmN5SWQSGwoXQ1VSUkVOQ1lfSURfVU5TUEVDSUZJRUQQABITCg9DVVJSRU5DWV9JRF9FVVIQChITCg9DVVJSRU5DWV9JRF9HQlAQFCrWBAoHTmV0d29yaxIXChNORVRXT1JLX1VOU1BFQ0lGSUVEEAASHAoYTkVUV09SS19FVEhFUkVVTV9NQUlOTkVUEAoSHAoYTkVUV09SS19FVEhFUkVVTV9TRVBPTElBEBQSFQoRTkVUV09SS19BVkFYX0ZVSkkQHhIaChZORVRXT1JLX0FWQVhfQ19NQUlOTkVUECgSGgoWTkVUV09SS19URVJSQTJfTUFJTk5FVBAyEhsKF05FVFdPUktfUE9MWUdPTl9NQUlOTkVUEDwSGAoUTkVUV09SS19QT0xZR09OX0FNT1kQRhIeChpORVRXT1JLX0FMRVBIX1pFUk9fTUFJTk5FVBBQEh4KGk5FVFdPUktfQUxFUEhfWkVST19URVNUTkVUEFoSIQodTkVUV09SS19BTEVQSF9aRVJPX0wyX01BSU5ORVQQZBIhCh1ORVRXT1JLX0FMRVBIX1pFUk9fTDJfVEVTVE5FVBBuEhwKGE5FVFdPUktfUE9MS0FET1RfTUFJTk5FVBB4Eh0KGE5FVFdPUktfUE9MS0FET1RfVEVTVE5FVBCCARIaChVORVRXT1JLX05PQkxFX01BSU5ORVQQjAESGgoVTkVUV09SS19OT0JMRV9URVNUTkVUEJYBEh0KGE5FVFdPUktfQVJCSVRSVU1fTUFJTk5FVBCgARIdChhORVRXT1JLX0FSQklUUlVNX1NFUE9MSUEQqgESGwoWTkVUV09SS19TT0xBTkFfTUFJTk5FVBC0ARIaChVORVRXT1JLX1NPTEFOQV9ERVZORVQQvgEqSAoNUGF5bWVudE1ldGhvZBIeChpQQVlNRU5UX01FVEhPRF9VTlNQRUNJRklFRBAAEhcKE1BBWU1FTlRfTUVUSE9EX1NFUEEQCjJECgtQaW5nU2VydmljZRI1CgRQaW5nEhQucmFtcC52MS5QaW5nUmVxdWVzdBoVLnJhbXAudjEuUGluZ1Jlc3BvbnNlIgAyvwgKC1JhbXBTZXJ2aWNlElMKDkdldEFjY291bnRJbmZvEh4ucmFtcC52MS5HZXRBY2NvdW50SW5mb1JlcXVlc3QaHy5yYW1wLnYxLkdldEFjY291bnRJbmZvUmVzcG9uc2UiABJZChBXaGl0ZWxpc3RBZGRyZXNzEiAucmFtcC52MS5XaGl0ZWxpc3RBZGRyZXNzUmVxdWVzdBohLnJhbXAudjEuV2hpdGVsaXN0QWRkcmVzc1Jlc3BvbnNlIgASbgoXV2hpdGVsaXN0RXJjMTI3MUFkZHJlc3MSJy5yYW1wLnYxLldoaXRlbGlzdEVyYzEyNzFBZGRyZXNzUmVxdWVzdBooLnJhbXAudjEuV2hpdGVsaXN0RXJjMTI3MUFkZHJlc3NSZXNwb25zZSIAElAKDVJlbW92ZUFkZHJlc3MSHS5yYW1wLnYxLlJlbW92ZUFkZHJlc3NSZXF1ZXN0Gh4ucmFtcC52MS5SZW1vdmVBZGRyZXNzUmVzcG9uc2UiABJTCg5TZXRCYW5rQWNjb3VudBIeLnJhbXAudjEuU2V0QmFua0FjY291bnRSZXF1ZXN0Gh8ucmFtcC52MS5TZXRCYW5rQWNjb3VudFJlc3BvbnNlIgASQQoIR2V0UmFtcHMSGC5yYW1wLnYxLkdldFJhbXBzUmVxdWVzdBoZLnJhbXAudjEuR2V0UmFtcHNSZXNwb25zZSIAEnoKG1JlZ2lzdGVyUmVmZXJyYWxUcmFuc2FjdGlvbhIrLnJhbXAudjEuUmVnaXN0ZXJSZWZlcnJhbFRyYW5zYWN0aW9uUmVxdWVzdBosLnJhbXAudjEuUmVnaXN0ZXJSZWZlcnJhbFRyYW5zYWN0aW9uUmVzcG9uc2UiABJcChFFc3RpbWF0ZU9uUmFtcEZlZRIhLnJhbXAudjEuRXN0aW1hdGVPblJhbXBGZWVSZXF1ZXN0GiIucmFtcC52MS5Fc3RpbWF0ZU9uUmFtcEZlZVJlc3BvbnNlIgASXwoSRXN0aW1hdGVPZmZSYW1wRmVlEiIucmFtcC52MS5Fc3RpbWF0ZU9mZlJhbXBGZWVSZXF1ZXN0GiMucmFtcC52MS5Fc3RpbWF0ZU9mZlJhbXBGZWVSZXNwb25zZSIAEkQKCUdldEFzc2V0cxIZLnJhbXAudjEuR2V0QXNzZXRzUmVxdWVzdBoaLnJhbXAudjEuR2V0QXNzZXRzUmVzcG9uc2UiABJWCg9TZXRFbWFpbEFkZHJlc3MSHy5yYW1wLnYxLlNldEVtYWlsQWRkcmVzc1JlcXVlc3QaIC5yYW1wLnYxLlNldEVtYWlsQWRkcmVzc1Jlc3BvbnNlIgASTQoMR2V0Q291bnRyaWVzEhwucmFtcC52MS5HZXRDb3VudHJpZXNSZXF1ZXN0Gh0ucmFtcC52MS5HZXRDb3VudHJpZXNSZXNwb25zZSIAQlcKC2NvbS5yYW1wLnYxQgtQdWJsaWNQcm90b1ABogIDUlhYqgIHUmFtcC5WMcoCB1JhbXBcVjHiAhNSYW1wXFYxXEdQQk1ldGFkYXRh6gIIUmFtcDo6VjFiBnByb3RvMw", [file_google_protobuf_timestamp]);

/**
 * @generated from message ramp.v1.PingRequest
 */
export type PingRequest = Message<"ramp.v1.PingRequest"> & {
};

/**
 * Describes the message ramp.v1.PingRequest.
 * Use `create(PingRequestSchema)` to create a new message.
 */
export const PingRequestSchema: GenMessage<PingRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 0);

/**
 * @generated from message ramp.v1.PingResponse
 */
export type PingResponse = Message<"ramp.v1.PingResponse"> & {
  /**
   * @generated from field: string message = 10;
   */
  message: string;
};

/**
 * Describes the message ramp.v1.PingResponse.
 * Use `create(PingResponseSchema)` to create a new message.
 */
export const PingResponseSchema: GenMessage<PingResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 1);

/**
 * @generated from message ramp.v1.GetAccountInfoRequest
 */
export type GetAccountInfoRequest = Message<"ramp.v1.GetAccountInfoRequest"> & {
  /**
   * @generated from field: optional string referral_code = 10;
   */
  referralCode?: string;
};

/**
 * Describes the message ramp.v1.GetAccountInfoRequest.
 * Use `create(GetAccountInfoRequestSchema)` to create a new message.
 */
export const GetAccountInfoRequestSchema: GenMessage<GetAccountInfoRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 2);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse
 */
export type GetAccountInfoResponse = Message<"ramp.v1.GetAccountInfoResponse"> & {
  /**
   * @generated from oneof ramp.v1.GetAccountInfoResponse.result
   */
  result: {
    /**
     * when result is authentication user needs to be onboarded or logged in
     *
     * @generated from field: ramp.v1.GetAccountInfoResponse.Authentication authentication = 20;
     */
    value: GetAccountInfoResponse_Authentication;
    case: "authentication";
  } | {
    /**
     * when result is account user is logged
     *
     * @generated from field: ramp.v1.GetAccountInfoResponse.Account account = 30;
     */
    value: GetAccountInfoResponse_Account;
    case: "account";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.
 * Use `create(GetAccountInfoResponseSchema)` to create a new message.
 */
export const GetAccountInfoResponseSchema: GenMessage<GetAccountInfoResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Authentication
 */
export type GetAccountInfoResponse_Authentication = Message<"ramp.v1.GetAccountInfoResponse.Authentication"> & {
  /**
   * authentication_url should be loaded in the i-frame or browser window in order to log in or onboard user
   *
   * @generated from field: string authentication_url = 10;
   */
  authenticationUrl: string;

  /**
   * token expiry in seconds, the frontend is expected to close the onboarding view (but the user can come back any time)
   * don't worry about the time skew from api latency, there's a grace period on top of this expiry
   *
   * @generated from field: int64 expires_in_sec = 20;
   */
  expiresInSec: bigint;
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.Authentication.
 * Use `create(GetAccountInfoResponse_AuthenticationSchema)` to create a new message.
 */
export const GetAccountInfoResponse_AuthenticationSchema: GenMessage<GetAccountInfoResponse_Authentication> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 0);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Account
 */
export type GetAccountInfoResponse_Account = Message<"ramp.v1.GetAccountInfoResponse.Account"> & {
  /**
   * list of whitelisted addresses. On-ramping could be done only to whitelisted address
   *
   * @generated from field: repeated ramp.v1.GetAccountInfoResponse.Wallet wallets = 10;
   */
  wallets: GetAccountInfoResponse_Wallet[];

  /**
   * A bank account created by Harbour in the name of the user, where funds can be sent
   *
   * @generated from oneof ramp.v1.GetAccountInfoResponse.Account.onramp_bank_account
   */
  onrampBankAccount: {
    /**
     * only for scheme SCAN (UK payments)
     *
     * @generated from field: ramp.v1.ScanCoordinates onramp_scan = 100;
     */
    value: ScanCoordinates;
    case: "onrampScan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates onramp_iban = 110;
     */
    value: IbanCoordinates;
    case: "onrampIban";
  } | { case: undefined; value?: undefined };

  /**
   * A bank account set by the user for off-ramping, see rpc SetBankAccount
   *
   * @generated from oneof ramp.v1.GetAccountInfoResponse.Account.offramp_bank_account
   */
  offrampBankAccount: {
    /**
     * only for scheme SCAN (UK payments)
     *
     * @generated from field: ramp.v1.ScanCoordinates offramp_scan = 200;
     */
    value: ScanCoordinates;
    case: "offrampScan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates offramp_iban = 210;
     */
    value: IbanCoordinates;
    case: "offrampIban";
  } | { case: undefined; value?: undefined };

  /**
   * account holder name for on and off-ramping
   *
   * @generated from field: string account_holder = 20;
   */
  accountHolder: string;

  /**
   * email address for receipts and notifications. Can be updated with SetEmailAddress
   *
   * @generated from field: string email_address = 25;
   */
  emailAddress: string;

  /**
   * list of supported assets
   *
   * @generated from field: repeated ramp.v1.GetAccountInfoResponse.CryptoAsset crypto_assets = 30;
   */
  cryptoAssets: GetAccountInfoResponse_CryptoAsset[];

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.AccountLimits limits = 40;
   */
  limits?: GetAccountInfoResponse_AccountLimits;

  /**
   * Field is optional as it depends on downstream microservices. In case of error
   * fetching points, we want this API to keep working. If this ends up being null,
   * the client should show something like N/A or 'error fetching points' to the 
   * user, but not 0 points, to avoid alarming them.
   *
   * @generated from field: optional ramp.v1.GetAccountInfoResponse.Account.Reward reward = 50;
   */
  reward?: GetAccountInfoResponse_Account_Reward;
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.Account.
 * Use `create(GetAccountInfoResponse_AccountSchema)` to create a new message.
 */
export const GetAccountInfoResponse_AccountSchema: GenMessage<GetAccountInfoResponse_Account> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 1);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Account.Reward
 */
export type GetAccountInfoResponse_Account_Reward = Message<"ramp.v1.GetAccountInfoResponse.Account.Reward"> & {
  /**
   * the amount of reward points the user has earned
   *
   * @generated from field: int64 points = 10;
   */
  points: bigint;

  /**
   * referral code the user can use to refer others and earn more points
   *
   * @generated from field: string referral_code = 20;
   */
  referralCode: string;
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.Account.Reward.
 * Use `create(GetAccountInfoResponse_Account_RewardSchema)` to create a new message.
 */
export const GetAccountInfoResponse_Account_RewardSchema: GenMessage<GetAccountInfoResponse_Account_Reward> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 1, 0);

/**
 * Deprecated
 *
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset
 */
export type GetAccountInfoResponse_CryptoAsset = Message<"ramp.v1.GetAccountInfoResponse.CryptoAsset"> & {
  /**
   * asset status for on/off ramping
   *
   * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus status = 1;
   */
  status?: GetAccountInfoResponse_CryptoAsset_RampStatus;

  /**
   * @generated from field: ramp.v1.Protocol protocol = 5;
   */
  protocol: Protocol;

  /**
   * @generated from field: ramp.v1.Network network = 10;
   */
  network: Network;

  /**
   * the client can use this to match an asset with precision and display custom wording / icon, e.g. "USDC"
   *
   * @generated from field: ramp.v1.AssetId asset_id = 20;
   */
  assetId: AssetId;

  /**
   * to be used as a fallback if the client doesn't recognise the asset_id (eg: out of date proto definitions)
   *
   * @generated from field: string short_name = 30;
   */
  shortName: string;

  /**
   * the canonical symbol for the asset - eg: USDC for any Circle-issued USDC on any chain, or ETH for Ethereum
   *
   * @generated from field: string symbol = 35;
   */
  symbol: string;

  /**
   * @generated from oneof ramp.v1.GetAccountInfoResponse.CryptoAsset.details
   */
  details: {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumErc20Token ethereum_erc20_token = 40;
     */
    value: GetAccountInfoResponse_CryptoAsset_EthereumErc20Token;
    case: "ethereumErc20Token";
  } | {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.CosmosIcs20Token cosmos_ics20_token = 50;
     */
    value: GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token;
    case: "cosmosIcs20Token";
  } | {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.SubstratePsp22Token substrate_psp22_token = 60;
     */
    value: GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token;
    case: "substratePsp22Token";
  } | {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumNative ethereum_native = 70;
     */
    value: GetAccountInfoResponse_CryptoAsset_EthereumNative;
    case: "ethereumNative";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.CryptoAsset.
 * Use `create(GetAccountInfoResponse_CryptoAssetSchema)` to create a new message.
 */
export const GetAccountInfoResponse_CryptoAssetSchema: GenMessage<GetAccountInfoResponse_CryptoAsset> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 2);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumErc20Token
 */
export type GetAccountInfoResponse_CryptoAsset_EthereumErc20Token = Message<"ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumErc20Token"> & {
  /**
   * ERC20 token address
   *
   * @generated from field: string token_address = 10;
   */
  tokenAddress: string;
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumErc20Token.
 * Use `create(GetAccountInfoResponse_CryptoAsset_EthereumErc20TokenSchema)` to create a new message.
 */
export const GetAccountInfoResponse_CryptoAsset_EthereumErc20TokenSchema: GenMessage<GetAccountInfoResponse_CryptoAsset_EthereumErc20Token> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 2, 0);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.CosmosIcs20Token
 */
export type GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token = Message<"ramp.v1.GetAccountInfoResponse.CryptoAsset.CosmosIcs20Token"> & {
  /**
   * IBC token address
   *
   * @generated from field: string ibc_address = 10;
   */
  ibcAddress: string;
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.CryptoAsset.CosmosIcs20Token.
 * Use `create(GetAccountInfoResponse_CryptoAsset_CosmosIcs20TokenSchema)` to create a new message.
 */
export const GetAccountInfoResponse_CryptoAsset_CosmosIcs20TokenSchema: GenMessage<GetAccountInfoResponse_CryptoAsset_CosmosIcs20Token> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 2, 1);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.SubstratePsp22Token
 */
export type GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token = Message<"ramp.v1.GetAccountInfoResponse.CryptoAsset.SubstratePsp22Token"> & {
  /**
   * Substrate PSP22 token address
   *
   * @generated from field: string token_address = 10;
   */
  tokenAddress: string;
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.CryptoAsset.SubstratePsp22Token.
 * Use `create(GetAccountInfoResponse_CryptoAsset_SubstratePsp22TokenSchema)` to create a new message.
 */
export const GetAccountInfoResponse_CryptoAsset_SubstratePsp22TokenSchema: GenMessage<GetAccountInfoResponse_CryptoAsset_SubstratePsp22Token> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 2, 2);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumNative
 */
export type GetAccountInfoResponse_CryptoAsset_EthereumNative = Message<"ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumNative"> & {
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.CryptoAsset.EthereumNative.
 * Use `create(GetAccountInfoResponse_CryptoAsset_EthereumNativeSchema)` to create a new message.
 */
export const GetAccountInfoResponse_CryptoAsset_EthereumNativeSchema: GenMessage<GetAccountInfoResponse_CryptoAsset_EthereumNative> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 2, 3);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus
 */
export type GetAccountInfoResponse_CryptoAsset_RampStatus = Message<"ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus"> & {
  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus.Status onramp = 10;
   */
  onramp: GetAccountInfoResponse_CryptoAsset_RampStatus_Status;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus.Status offramp = 20;
   */
  offramp: GetAccountInfoResponse_CryptoAsset_RampStatus_Status;
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus.
 * Use `create(GetAccountInfoResponse_CryptoAsset_RampStatusSchema)` to create a new message.
 */
export const GetAccountInfoResponse_CryptoAsset_RampStatusSchema: GenMessage<GetAccountInfoResponse_CryptoAsset_RampStatus> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 2, 4);

/**
 * @generated from enum ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus.Status
 */
export enum GetAccountInfoResponse_CryptoAsset_RampStatus_Status {
  /**
   * All is good, asset can be on/off ramped
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Our system is experiencing degradation (longer waits) but still operational.
   * The UI should warn users.
   *
   * @generated from enum value: STATUS_DEGRADED = 20;
   */
  DEGRADED = 20,

  /**
   * Exceptional scenarios: ramping halted. The UI should prevent users from taking any action.
   *
   * @generated from enum value: STATUS_HALTED = 30;
   */
  HALTED = 30,
}

/**
 * Describes the enum ramp.v1.GetAccountInfoResponse.CryptoAsset.RampStatus.Status.
 */
export const GetAccountInfoResponse_CryptoAsset_RampStatus_StatusSchema: GenEnum<GetAccountInfoResponse_CryptoAsset_RampStatus_Status> = /*@__PURE__*/
  enumDesc(file_ramp_v1_public, 3, 2, 4, 0);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet
 */
export type GetAccountInfoResponse_Wallet = Message<"ramp.v1.GetAccountInfoResponse.Wallet"> & {
  /**
   * user given name, less then 100 symbols
   *
   * @generated from field: string name = 5;
   */
  name: string;

  /**
   * @generated from field: ramp.v1.Protocol protocol = 10;
   */
  protocol: Protocol;

  /**
   * address of a wallet in blockchain
   *
   * @generated from field: string address = 20;
   */
  address: string;

  /**
   * assets available for on- and off- ramping
   *
   * @generated from field: repeated ramp.v1.GetAccountInfoResponse.Wallet.RampAsset assets = 30;
   */
  assets: GetAccountInfoResponse_Wallet_RampAsset[];
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.Wallet.
 * Use `create(GetAccountInfoResponse_WalletSchema)` to create a new message.
 */
export const GetAccountInfoResponse_WalletSchema: GenMessage<GetAccountInfoResponse_Wallet> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 3);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.RampAsset
 */
export type GetAccountInfoResponse_Wallet_RampAsset = Message<"ramp.v1.GetAccountInfoResponse.Wallet.RampAsset"> & {
  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.CryptoAsset asset = 10;
   */
  asset?: GetAccountInfoResponse_CryptoAsset;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.OnRamp on_ramp = 20;
   */
  onRamp?: GetAccountInfoResponse_Wallet_OnRamp;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.OffRamp off_ramp = 30;
   */
  offRamp?: GetAccountInfoResponse_Wallet_OffRamp;
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.Wallet.RampAsset.
 * Use `create(GetAccountInfoResponse_Wallet_RampAssetSchema)` to create a new message.
 */
export const GetAccountInfoResponse_Wallet_RampAssetSchema: GenMessage<GetAccountInfoResponse_Wallet_RampAsset> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 3, 0);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.OnRamp
 */
export type GetAccountInfoResponse_Wallet_OnRamp = Message<"ramp.v1.GetAccountInfoResponse.Wallet.OnRamp"> & {
  /**
   * e.g. "ETU1"
   *
   * @generated from field: string payment_reference = 10;
   */
  paymentReference: string;
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.Wallet.OnRamp.
 * Use `create(GetAccountInfoResponse_Wallet_OnRampSchema)` to create a new message.
 */
export const GetAccountInfoResponse_Wallet_OnRampSchema: GenMessage<GetAccountInfoResponse_Wallet_OnRamp> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 3, 1);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.OffRamp
 */
export type GetAccountInfoResponse_Wallet_OffRamp = Message<"ramp.v1.GetAccountInfoResponse.Wallet.OffRamp"> & {
  /**
   * address, crypto asset should be send to for offramping
   *
   * @generated from field: string address = 10;
   */
  address: string;
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.Wallet.OffRamp.
 * Use `create(GetAccountInfoResponse_Wallet_OffRampSchema)` to create a new message.
 */
export const GetAccountInfoResponse_Wallet_OffRampSchema: GenMessage<GetAccountInfoResponse_Wallet_OffRamp> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 3, 2);

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.AccountLimits
 */
export type GetAccountInfoResponse_AccountLimits = Message<"ramp.v1.GetAccountInfoResponse.AccountLimits"> & {
  /**
   * limit for single on-ramp in fiat currency
   *
   * @generated from field: string onramp_single_limit = 10;
   */
  onrampSingleLimit: string;

  /**
   * daily limit for on-ramp in fiat currency
   *
   * @generated from field: string onramp_daily_limit = 20;
   */
  onrampDailyLimit: string;

  /**
   * current usage for on-ramp in fiat currency
   *
   * @generated from field: string onramp_current_daily_usage = 30;
   */
  onrampCurrentDailyUsage: string;

  /**
   * single limit for off-ramp expressed in fiat currency (either EUR or GBP)
   *
   * @generated from field: string offramp_single_limit = 40;
   */
  offrampSingleLimit: string;

  /**
   * daily limit for off-ramp expressed in fiat currency (either EUR or GBP)
   *
   * @generated from field: string offramp_daily_limit = 50;
   */
  offrampDailyLimit: string;

  /**
   * current usage for off-ramp expressed in fiat currency (either EUR or GBP)
   *
   * @generated from field: string offramp_current_daily_usage = 60;
   */
  offrampCurrentDailyUsage: string;
};

/**
 * Describes the message ramp.v1.GetAccountInfoResponse.AccountLimits.
 * Use `create(GetAccountInfoResponse_AccountLimitsSchema)` to create a new message.
 */
export const GetAccountInfoResponse_AccountLimitsSchema: GenMessage<GetAccountInfoResponse_AccountLimits> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 3, 4);

/**
 * @generated from message ramp.v1.WhitelistAddressRequest
 */
export type WhitelistAddressRequest = Message<"ramp.v1.WhitelistAddressRequest"> & {
  /**
   * user given name, could be same name as in the Self Custody wallet if supported by wallet vendor
   * (the maximum length of the name is 100 symbols)
   *
   * @generated from field: string name = 10 [deprecated = true];
   * @deprecated
   */
  name: string;

  /**
   * Ethereum, Avalanche, Terra and etc.
   *
   * @generated from field: ramp.v1.Protocol protocol = 20;
   */
  protocol: Protocol;

  /**
   * address in particular blockchain e.g. 0x31792BB64B2fA8e0a4F5fD8F82DDf81A6F2C30e0
   * Deprecated in favour of signed_address
   *
   * limited to 255 characters
   *
   * @generated from field: string address = 30 [deprecated = true];
   * @deprecated
   */
  address: string;

  /**
   * address must be derived from the provided public key
   * public key in particular ecosystem, encoded accordingly to ecosystem rules (Ethereum - hex, Cosmos - base64)
   * Deprecated in favour of signed_address
   *
   * limited to 255 characters
   *
   * @generated from field: string public_key = 35 [deprecated = true];
   * @deprecated
   */
  publicKey: string;

  /**
   * the address should be signed with its private key
   * for the Ethereum: the address should be signed with https://docs.metamask.io/wallet/reference/personal_sign/
   * Deprecated in favour of signed_address
   *
   * @generated from field: string address_signature = 40 [deprecated = true];
   * @deprecated
   */
  addressSignature: string;

  /**
   * this field is only required when the public key used to authenticate this request is different from the key used to derive the address
   * if this field is present in the request it takes precedence over the address, public_key and address_signature of the WhitelistAddressRequest
   *
   * @generated from field: ramp.v1.WhitelistAddressRequest.SignedAddress signed_address = 50;
   */
  signedAddress?: WhitelistAddressRequest_SignedAddress;
};

/**
 * Describes the message ramp.v1.WhitelistAddressRequest.
 * Use `create(WhitelistAddressRequestSchema)` to create a new message.
 */
export const WhitelistAddressRequestSchema: GenMessage<WhitelistAddressRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 4);

/**
 * @generated from message ramp.v1.WhitelistAddressRequest.SignedAddress
 */
export type WhitelistAddressRequest_SignedAddress = Message<"ramp.v1.WhitelistAddressRequest.SignedAddress"> & {
  /**
   * address in particular blockchain e.g. 0x31792BB64B2fA8e0a4F5fD8F82DDf81A6F2C30e0
   *
   * limited to 255 characters
   *
   * @generated from field: string address = 30;
   */
  address: string;

  /**
   * address must be derived from the provided public key
   * public key in particular ecosystem, encoded accordingly to ecosystem rules (Ethereum - hex, Cosmos - base64)
   *
   * limited to 255 characters
   *
   * @generated from field: string public_key = 35;
   */
  publicKey: string;

  /**
   * the address should be signed with its private key
   * for the Ethereum: the address should be signed with https://docs.metamask.io/wallet/reference/personal_sign/
   *
   * @generated from field: string address_signature = 40;
   */
  addressSignature: string;
};

/**
 * Describes the message ramp.v1.WhitelistAddressRequest.SignedAddress.
 * Use `create(WhitelistAddressRequest_SignedAddressSchema)` to create a new message.
 */
export const WhitelistAddressRequest_SignedAddressSchema: GenMessage<WhitelistAddressRequest_SignedAddress> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 4, 0);

/**
 * @generated from message ramp.v1.WhitelistAddressResponse
 */
export type WhitelistAddressResponse = Message<"ramp.v1.WhitelistAddressResponse"> & {
};

/**
 * Describes the message ramp.v1.WhitelistAddressResponse.
 * Use `create(WhitelistAddressResponseSchema)` to create a new message.
 */
export const WhitelistAddressResponseSchema: GenMessage<WhitelistAddressResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 5);

/**
 * @generated from message ramp.v1.WhitelistErc1271AddressRequest
 */
export type WhitelistErc1271AddressRequest = Message<"ramp.v1.WhitelistErc1271AddressRequest"> & {
  /**
   * @generated from field: ramp.v1.Protocol protocol = 10;
   */
  protocol: Protocol;

  /**
   * @generated from field: ramp.v1.WhitelistErc1271AddressRequest.SignedErc1271Address signed_address = 20;
   */
  signedAddress?: WhitelistErc1271AddressRequest_SignedErc1271Address;
};

/**
 * Describes the message ramp.v1.WhitelistErc1271AddressRequest.
 * Use `create(WhitelistErc1271AddressRequestSchema)` to create a new message.
 */
export const WhitelistErc1271AddressRequestSchema: GenMessage<WhitelistErc1271AddressRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 6);

/**
 * @generated from message ramp.v1.WhitelistErc1271AddressRequest.SignedErc1271Address
 */
export type WhitelistErc1271AddressRequest_SignedErc1271Address = Message<"ramp.v1.WhitelistErc1271AddressRequest.SignedErc1271Address"> & {
  /**
   * address in particular blockchain e.g. 0x31792BB64B2fA8e0a4F5fD8F82DDf81A6F2C30e0
   *
   * @generated from field: string address = 10;
   */
  address: string;

  /**
   * signature of the the string address representation
   *
   * @generated from field: string address_signature = 20;
   */
  addressSignature: string;
};

/**
 * Describes the message ramp.v1.WhitelistErc1271AddressRequest.SignedErc1271Address.
 * Use `create(WhitelistErc1271AddressRequest_SignedErc1271AddressSchema)` to create a new message.
 */
export const WhitelistErc1271AddressRequest_SignedErc1271AddressSchema: GenMessage<WhitelistErc1271AddressRequest_SignedErc1271Address> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 6, 0);

/**
 * @generated from message ramp.v1.WhitelistErc1271AddressResponse
 */
export type WhitelistErc1271AddressResponse = Message<"ramp.v1.WhitelistErc1271AddressResponse"> & {
};

/**
 * Describes the message ramp.v1.WhitelistErc1271AddressResponse.
 * Use `create(WhitelistErc1271AddressResponseSchema)` to create a new message.
 */
export const WhitelistErc1271AddressResponseSchema: GenMessage<WhitelistErc1271AddressResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 7);

/**
 * @generated from message ramp.v1.RemoveAddressRequest
 */
export type RemoveAddressRequest = Message<"ramp.v1.RemoveAddressRequest"> & {
  /**
   * @generated from field: ramp.v1.Protocol protocol = 10;
   */
  protocol: Protocol;

  /**
   * address in particular blockchain e.g. 0x31792BB64B2fA8e0a4F5fD8F82DDf81A6F2C30e0
   *
   * @generated from field: string address = 30;
   */
  address: string;
};

/**
 * Describes the message ramp.v1.RemoveAddressRequest.
 * Use `create(RemoveAddressRequestSchema)` to create a new message.
 */
export const RemoveAddressRequestSchema: GenMessage<RemoveAddressRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 8);

/**
 * @generated from message ramp.v1.RemoveAddressResponse
 */
export type RemoveAddressResponse = Message<"ramp.v1.RemoveAddressResponse"> & {
};

/**
 * Describes the message ramp.v1.RemoveAddressResponse.
 * Use `create(RemoveAddressResponseSchema)` to create a new message.
 */
export const RemoveAddressResponseSchema: GenMessage<RemoveAddressResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 9);

/**
 * @generated from message ramp.v1.SetBankAccountRequest
 */
export type SetBankAccountRequest = Message<"ramp.v1.SetBankAccountRequest"> & {
  /**
   * first and last beneficiary name is not required. KYC info will be used as beneficiary name
   *
   * @generated from oneof ramp.v1.SetBankAccountRequest.bank_account
   */
  bankAccount: {
    /**
     * only for scheme SCAN
     *
     * @generated from field: ramp.v1.ScanCoordinates scan = 10;
     */
    value: ScanCoordinates;
    case: "scan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates iban = 20;
     */
    value: IbanCoordinates;
    case: "iban";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ramp.v1.SetBankAccountRequest.
 * Use `create(SetBankAccountRequestSchema)` to create a new message.
 */
export const SetBankAccountRequestSchema: GenMessage<SetBankAccountRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 10);

/**
 * The client should comply to basic validation rules such as min/max length for ibans, sort codes and account numbers
 * complex validation such as IBAN or SCAN checksums and sort code directory is performed by Harbour
 *
 * @generated from message ramp.v1.SetBankAccountResponse
 */
export type SetBankAccountResponse = Message<"ramp.v1.SetBankAccountResponse"> & {
  /**
   * @generated from field: repeated ramp.v1.SetBankAccountResponse.Error errors = 10;
   */
  errors: SetBankAccountResponse_Error[];
};

/**
 * Describes the message ramp.v1.SetBankAccountResponse.
 * Use `create(SetBankAccountResponseSchema)` to create a new message.
 */
export const SetBankAccountResponseSchema: GenMessage<SetBankAccountResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 11);

/**
 * @generated from enum ramp.v1.SetBankAccountResponse.Error
 */
export enum SetBankAccountResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Returned when the routing code is wrong (eg: sort code for UK and BIC for ibans).
   * Note: the client still needs to perform basic validation, such as guaranteeing that the sort code is exactly 6 digits,
   * else it won't even get this response and just get a code invalid argument.
   * However, the backend will perform more advanced validation, such as checking that the sort code exists, in which
   * case it will return this error.
   *
   * @generated from enum value: ERROR_BANK_CODE_INVALID = 1;
   */
  BANK_CODE_INVALID = 1,

  /**
   * Same as above, but for the account number (eg: account number for UK and IBAN for ibans).
   * In case of UK account numbers, the account number is validated against the sort code, to determine whether it's
   * valid according to the destination bank.
   * In case of IBAN, basic mathematical checks will be performed, according to the IBAN standard, to verify its validity.
   *
   * @generated from enum value: ERROR_BANK_NUMBER_INVALID = 2;
   */
  BANK_NUMBER_INVALID = 2,

  /**
   * Returned when the user tries to set the bank account same as the magic-ramp account.
   *
   * @generated from enum value: ERROR_SAME_BANK_ACCOUNT = 3;
   */
  SAME_BANK_ACCOUNT = 3,
}

/**
 * Describes the enum ramp.v1.SetBankAccountResponse.Error.
 */
export const SetBankAccountResponse_ErrorSchema: GenEnum<SetBankAccountResponse_Error> = /*@__PURE__*/
  enumDesc(file_ramp_v1_public, 11, 0);

/**
 * @generated from message ramp.v1.EstimateOnRampFeeRequest
 */
export type EstimateOnRampFeeRequest = Message<"ramp.v1.EstimateOnRampFeeRequest"> & {
  /**
   * All fields are mandatory
   *
   * @generated from field: ramp.v1.CurrencyId fiat_asset_id = 5;
   */
  fiatAssetId: CurrencyId;

  /**
   * @generated from field: ramp.v1.AssetId crypto_asset_id = 10;
   */
  cryptoAssetId: AssetId;

  /**
   * @generated from field: ramp.v1.Protocol protocol = 15;
   */
  protocol: Protocol;

  /**
   * @generated from oneof ramp.v1.EstimateOnRampFeeRequest.amount
   */
  amount: {
    /**
     * @generated from field: string fiat_asset_amount = 20;
     */
    value: string;
    case: "fiatAssetAmount";
  } | { case: undefined; value?: undefined };

  /**
   * this is optional and could be used by partners of Harbour
   *
   * @generated from oneof ramp.v1.EstimateOnRampFeeRequest.referral
   */
  referral: {
    /**
     * please reach out support to obtain referral code
     *
     * @generated from field: string code = 30;
     */
    value: string;
    case: "code";
  } | {
    /**
     * provide wallet_address if referral transaction was registered for this address
     *
     * @generated from field: string wallet_address = 40;
     */
    value: string;
    case: "walletAddress";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ramp.v1.EstimateOnRampFeeRequest.
 * Use `create(EstimateOnRampFeeRequestSchema)` to create a new message.
 */
export const EstimateOnRampFeeRequestSchema: GenMessage<EstimateOnRampFeeRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 12);

/**
 * @generated from message ramp.v1.EstimateOnRampFeeResponse
 */
export type EstimateOnRampFeeResponse = Message<"ramp.v1.EstimateOnRampFeeResponse"> & {
  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string fiat_asset_amount = 20;
   */
  fiatAssetAmount: string;

  /**
   * denominated in crypto_asset
   *
   * @generated from field: string crypto_asset_amount = 30;
   */
  cryptoAssetAmount: string;

  /**
   * @generated from field: string exchange_rate = 40;
   */
  exchangeRate: string;

  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string network_fee_amount = 50;
   */
  networkFeeAmount: string;

  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string processing_fee_amount = 60;
   */
  processingFeeAmount: string;

  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string referral_fee_amount = 70;
   */
  referralFeeAmount: string;

  /**
   * True if the ramp will be processed immediately
   *
   * @generated from field: bool instant_processing = 80;
   */
  instantProcessing: boolean;
};

/**
 * Describes the message ramp.v1.EstimateOnRampFeeResponse.
 * Use `create(EstimateOnRampFeeResponseSchema)` to create a new message.
 */
export const EstimateOnRampFeeResponseSchema: GenMessage<EstimateOnRampFeeResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 13);

/**
 * @generated from message ramp.v1.EstimateOffRampFeeRequest
 */
export type EstimateOffRampFeeRequest = Message<"ramp.v1.EstimateOffRampFeeRequest"> & {
  /**
   * optional - just for a transitional period
   *
   * @generated from field: ramp.v1.CurrencyId fiat_asset_id = 5;
   */
  fiatAssetId: CurrencyId;

  /**
   * @generated from field: ramp.v1.AssetId crypto_asset_id = 10;
   */
  cryptoAssetId: AssetId;

  /**
   * @generated from field: ramp.v1.Protocol protocol = 15;
   */
  protocol: Protocol;

  /**
   * @generated from oneof ramp.v1.EstimateOffRampFeeRequest.amount
   */
  amount: {
    /**
     * @generated from field: string crypto_asset_amount = 20;
     */
    value: string;
    case: "cryptoAssetAmount";
  } | { case: undefined; value?: undefined };

  /**
   * this is optional and could be used by partners of Harbour
   *
   * @generated from oneof ramp.v1.EstimateOffRampFeeRequest.referral
   */
  referral: {
    /**
     * please reach out support to obtain referral code
     *
     * @generated from field: string code = 30;
     */
    value: string;
    case: "code";
  } | {
    /**
     * provide wallet_address if referral transaction was registered for this address
     *
     * @generated from field: string wallet_address = 40;
     */
    value: string;
    case: "walletAddress";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ramp.v1.EstimateOffRampFeeRequest.
 * Use `create(EstimateOffRampFeeRequestSchema)` to create a new message.
 */
export const EstimateOffRampFeeRequestSchema: GenMessage<EstimateOffRampFeeRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 14);

/**
 * @generated from message ramp.v1.EstimateOffRampFeeResponse
 */
export type EstimateOffRampFeeResponse = Message<"ramp.v1.EstimateOffRampFeeResponse"> & {
  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string fiat_asset_amount = 20;
   */
  fiatAssetAmount: string;

  /**
   * denominated in crypto_asset
   *
   * @generated from field: string crypto_asset_amount = 30;
   */
  cryptoAssetAmount: string;

  /**
   * @generated from field: string exchange_rate = 40;
   */
  exchangeRate: string;

  /**
   * denominated in user's fiat currency
   *
   * @generated from field: string processing_fee_amount = 60;
   */
  processingFeeAmount: string;

  /**
   * @generated from field: string referral_fee_amount = 70;
   */
  referralFeeAmount: string;

  /**
   * True if the ramp will be processed immediately
   *
   * @generated from field: bool instant_processing = 80;
   */
  instantProcessing: boolean;
};

/**
 * Describes the message ramp.v1.EstimateOffRampFeeResponse.
 * Use `create(EstimateOffRampFeeResponseSchema)` to create a new message.
 */
export const EstimateOffRampFeeResponseSchema: GenMessage<EstimateOffRampFeeResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 15);

/**
 * @generated from message ramp.v1.GetRampsRequest
 */
export type GetRampsRequest = Message<"ramp.v1.GetRampsRequest"> & {
  /**
   * if not set default page will be used (index=0, size=10)
   *
   * @generated from field: optional ramp.v1.Page page = 10;
   */
  page?: Page;

  /**
   * required
   *
   * @generated from field: ramp.v1.RampType ramp_type = 20;
   */
  rampType: RampType;

  /**
   * optional
   *
   * @generated from field: optional ramp.v1.GetRampsRequest.DateRange date_range = 30;
   */
  dateRange?: GetRampsRequest_DateRange;
};

/**
 * Describes the message ramp.v1.GetRampsRequest.
 * Use `create(GetRampsRequestSchema)` to create a new message.
 */
export const GetRampsRequestSchema: GenMessage<GetRampsRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 16);

/**
 * @generated from message ramp.v1.GetRampsRequest.DateRange
 */
export type GetRampsRequest_DateRange = Message<"ramp.v1.GetRampsRequest.DateRange"> & {
  /**
   * @generated from field: google.protobuf.Timestamp from = 10;
   */
  from?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp to = 20;
   */
  to?: Timestamp;
};

/**
 * Describes the message ramp.v1.GetRampsRequest.DateRange.
 * Use `create(GetRampsRequest_DateRangeSchema)` to create a new message.
 */
export const GetRampsRequest_DateRangeSchema: GenMessage<GetRampsRequest_DateRange> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 16, 0);

/**
 * @generated from message ramp.v1.GetRampsResponse
 */
export type GetRampsResponse = Message<"ramp.v1.GetRampsResponse"> & {
  /**
   * @generated from field: ramp.v1.PagedResult page = 10;
   */
  page?: PagedResult;

  /**
   * @generated from field: repeated ramp.v1.GetRampsResponse.Ramp ramps = 20;
   */
  ramps: GetRampsResponse_Ramp[];
};

/**
 * Describes the message ramp.v1.GetRampsResponse.
 * Use `create(GetRampsResponseSchema)` to create a new message.
 */
export const GetRampsResponseSchema: GenMessage<GetRampsResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 17);

/**
 * @generated from message ramp.v1.GetRampsResponse.Ramp
 */
export type GetRampsResponse_Ramp = Message<"ramp.v1.GetRampsResponse.Ramp"> & {
  /**
   * @generated from field: string id = 10;
   */
  id: string;

  /**
   * @generated from field: ramp.v1.RampType type = 20;
   */
  type: RampType;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: ramp.v1.AssetId crypto_asset = 30;
   */
  cryptoAsset: AssetId;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: string fiat_amount = 40;
   */
  fiatAmount: string;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: string crypto_amount = 50;
   */
  cryptoAmount: string;

  /**
   * string exchange_rate = 60; // could be empty if ramp is not completed yet
   *
   * @generated from field: ramp.v1.Protocol wallet_protocol = 70;
   */
  walletProtocol: Protocol;

  /**
   * @generated from field: string wallet_address = 80;
   */
  walletAddress: string;

  /**
   * in fiat, could be empty if ramp is not completed yet
   *
   * @generated from field: string network_fee_amount = 90;
   */
  networkFeeAmount: string;

  /**
   * in fiat, could be empty if ramp is not completed yet
   *
   * @generated from field: string processing_fee_amount = 100;
   */
  processingFeeAmount: string;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: google.protobuf.Timestamp finalized_at = 110;
   */
  finalizedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp initiated_at = 120;
   */
  initiatedAt?: Timestamp;
};

/**
 * Describes the message ramp.v1.GetRampsResponse.Ramp.
 * Use `create(GetRampsResponse_RampSchema)` to create a new message.
 */
export const GetRampsResponse_RampSchema: GenMessage<GetRampsResponse_Ramp> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 17, 0);

/**
 * @generated from message ramp.v1.GetAssetsRequest
 */
export type GetAssetsRequest = Message<"ramp.v1.GetAssetsRequest"> & {
  /**
   * @generated from field: ramp.v1.CurrencyId fiat_asset_id = 10;
   */
  fiatAssetId: CurrencyId;
};

/**
 * Describes the message ramp.v1.GetAssetsRequest.
 * Use `create(GetAssetsRequestSchema)` to create a new message.
 */
export const GetAssetsRequestSchema: GenMessage<GetAssetsRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 18);

/**
 * @generated from message ramp.v1.GetAssetsResponse
 */
export type GetAssetsResponse = Message<"ramp.v1.GetAssetsResponse"> & {
  /**
   * @generated from field: repeated ramp.v1.CryptoAsset crypto_assets = 10;
   */
  cryptoAssets: CryptoAsset[];
};

/**
 * Describes the message ramp.v1.GetAssetsResponse.
 * Use `create(GetAssetsResponseSchema)` to create a new message.
 */
export const GetAssetsResponseSchema: GenMessage<GetAssetsResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 19);

/**
 * @generated from message ramp.v1.RegisterReferralTransactionRequest
 */
export type RegisterReferralTransactionRequest = Message<"ramp.v1.RegisterReferralTransactionRequest"> & {
  /**
   * assigned to the partner by Harbour
   *
   * @generated from field: string referral_code = 10;
   */
  referralCode: string;

  /**
   * @generated from field: string wallet_address = 20;
   */
  walletAddress: string;

  /**
   * @generated from field: ramp.v1.RampType type = 30;
   */
  type: RampType;

  /**
   * @generated from field: ramp.v1.CurrencyId currency = 40;
   */
  currency: CurrencyId;

  /**
   * @generated from field: ramp.v1.AssetId crypto_asset = 50;
   */
  cryptoAsset: AssetId;

  /**
   * @generated from field: ramp.v1.Protocol crypto_asset_protocol = 60;
   */
  cryptoAssetProtocol: Protocol;

  /**
   * client generated id of transaction, will be reported back in the webhook
   *
   * @generated from field: string referral_transaction_id = 70;
   */
  referralTransactionId: string;

  /**
   * fiat amount for on ramps, crypto amount for off ramps
   *
   * @generated from field: string amount = 80;
   */
  amount: string;
};

/**
 * Describes the message ramp.v1.RegisterReferralTransactionRequest.
 * Use `create(RegisterReferralTransactionRequestSchema)` to create a new message.
 */
export const RegisterReferralTransactionRequestSchema: GenMessage<RegisterReferralTransactionRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 20);

/**
 * @generated from message ramp.v1.RegisterReferralTransactionResponse
 */
export type RegisterReferralTransactionResponse = Message<"ramp.v1.RegisterReferralTransactionResponse"> & {
};

/**
 * Describes the message ramp.v1.RegisterReferralTransactionResponse.
 * Use `create(RegisterReferralTransactionResponseSchema)` to create a new message.
 */
export const RegisterReferralTransactionResponseSchema: GenMessage<RegisterReferralTransactionResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 21);

/**
 * @generated from message ramp.v1.CryptoAsset
 */
export type CryptoAsset = Message<"ramp.v1.CryptoAsset"> & {
  /**
   * asset status for on/off ramping
   *
   * @generated from field: ramp.v1.CryptoAsset.RampStatus status = 10;
   */
  status?: CryptoAsset_RampStatus;

  /**
   * @generated from field: ramp.v1.Protocol protocol = 20;
   */
  protocol: Protocol;

  /**
   * @generated from field: ramp.v1.Network network = 30;
   */
  network: Network;

  /**
   * the client can use this to match an asset with precision and display custom wording / icon, e.g. "USDC"
   *
   * @generated from field: ramp.v1.AssetId asset_id = 40;
   */
  assetId: AssetId;

  /**
   * to be used as a fallback if the client doesn't recognise the asset_id (eg: out of date proto definitions)
   *
   * @generated from field: string short_name = 50;
   */
  shortName: string;

  /**
   * the canonical symbol for the asset - eg: USDC for any Circle-issued USDC on any chain, or ETH for Ethereum
   *
   * @generated from field: string symbol = 55;
   */
  symbol: string;

  /**
   * @generated from oneof ramp.v1.CryptoAsset.details
   */
  details: {
    /**
     * @generated from field: ramp.v1.CryptoAsset.EthereumErc20Token ethereum_erc20_token = 60;
     */
    value: CryptoAsset_EthereumErc20Token;
    case: "ethereumErc20Token";
  } | {
    /**
     * @generated from field: ramp.v1.CryptoAsset.CosmosIcs20Token cosmos_ics20_token = 70;
     */
    value: CryptoAsset_CosmosIcs20Token;
    case: "cosmosIcs20Token";
  } | {
    /**
     * @generated from field: ramp.v1.CryptoAsset.SubstratePsp22Token substrate_psp22_token = 80;
     */
    value: CryptoAsset_SubstratePsp22Token;
    case: "substratePsp22Token";
  } | {
    /**
     * @generated from field: ramp.v1.CryptoAsset.EthereumNative ethereum_native = 90;
     */
    value: CryptoAsset_EthereumNative;
    case: "ethereumNative";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits onramp_limits = 100;
   */
  onrampLimits?: CryptoAsset_Limits;

  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits offramp_limits = 110;
   */
  offrampLimits?: CryptoAsset_Limits;
};

/**
 * Describes the message ramp.v1.CryptoAsset.
 * Use `create(CryptoAssetSchema)` to create a new message.
 */
export const CryptoAssetSchema: GenMessage<CryptoAsset> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 22);

/**
 * @generated from message ramp.v1.CryptoAsset.EthereumErc20Token
 */
export type CryptoAsset_EthereumErc20Token = Message<"ramp.v1.CryptoAsset.EthereumErc20Token"> & {
  /**
   * ERC20 token address
   *
   * @generated from field: string token_address = 10;
   */
  tokenAddress: string;
};

/**
 * Describes the message ramp.v1.CryptoAsset.EthereumErc20Token.
 * Use `create(CryptoAsset_EthereumErc20TokenSchema)` to create a new message.
 */
export const CryptoAsset_EthereumErc20TokenSchema: GenMessage<CryptoAsset_EthereumErc20Token> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 22, 0);

/**
 * @generated from message ramp.v1.CryptoAsset.CosmosIcs20Token
 */
export type CryptoAsset_CosmosIcs20Token = Message<"ramp.v1.CryptoAsset.CosmosIcs20Token"> & {
  /**
   * IBC token address
   *
   * @generated from field: string ibc_address = 10;
   */
  ibcAddress: string;
};

/**
 * Describes the message ramp.v1.CryptoAsset.CosmosIcs20Token.
 * Use `create(CryptoAsset_CosmosIcs20TokenSchema)` to create a new message.
 */
export const CryptoAsset_CosmosIcs20TokenSchema: GenMessage<CryptoAsset_CosmosIcs20Token> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 22, 1);

/**
 * @generated from message ramp.v1.CryptoAsset.SubstratePsp22Token
 */
export type CryptoAsset_SubstratePsp22Token = Message<"ramp.v1.CryptoAsset.SubstratePsp22Token"> & {
  /**
   * Substrate PSP22 token address
   *
   * @generated from field: string token_address = 10;
   */
  tokenAddress: string;
};

/**
 * Describes the message ramp.v1.CryptoAsset.SubstratePsp22Token.
 * Use `create(CryptoAsset_SubstratePsp22TokenSchema)` to create a new message.
 */
export const CryptoAsset_SubstratePsp22TokenSchema: GenMessage<CryptoAsset_SubstratePsp22Token> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 22, 2);

/**
 * @generated from message ramp.v1.CryptoAsset.EthereumNative
 */
export type CryptoAsset_EthereumNative = Message<"ramp.v1.CryptoAsset.EthereumNative"> & {
};

/**
 * Describes the message ramp.v1.CryptoAsset.EthereumNative.
 * Use `create(CryptoAsset_EthereumNativeSchema)` to create a new message.
 */
export const CryptoAsset_EthereumNativeSchema: GenMessage<CryptoAsset_EthereumNative> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 22, 3);

/**
 * @generated from message ramp.v1.CryptoAsset.RampStatus
 */
export type CryptoAsset_RampStatus = Message<"ramp.v1.CryptoAsset.RampStatus"> & {
  /**
   * @generated from field: ramp.v1.CryptoAsset.RampStatus.Status onramp = 10;
   */
  onramp: CryptoAsset_RampStatus_Status;

  /**
   * @generated from field: ramp.v1.CryptoAsset.RampStatus.Status offramp = 20;
   */
  offramp: CryptoAsset_RampStatus_Status;
};

/**
 * Describes the message ramp.v1.CryptoAsset.RampStatus.
 * Use `create(CryptoAsset_RampStatusSchema)` to create a new message.
 */
export const CryptoAsset_RampStatusSchema: GenMessage<CryptoAsset_RampStatus> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 22, 4);

/**
 * @generated from enum ramp.v1.CryptoAsset.RampStatus.Status
 */
export enum CryptoAsset_RampStatus_Status {
  /**
   * All is good, asset can be on/off ramped
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Our system is experiencing degradation (longer waits) but still operational.
   * The UI should warn users.
   *
   * @generated from enum value: STATUS_DEGRADED = 20;
   */
  DEGRADED = 20,

  /**
   * Exceptional scenarios: ramping halted. The UI should prevent users from taking any action.
   *
   * @generated from enum value: STATUS_HALTED = 30;
   */
  HALTED = 30,
}

/**
 * Describes the enum ramp.v1.CryptoAsset.RampStatus.Status.
 */
export const CryptoAsset_RampStatus_StatusSchema: GenEnum<CryptoAsset_RampStatus_Status> = /*@__PURE__*/
  enumDesc(file_ramp_v1_public, 22, 4, 0);

/**
 * @generated from message ramp.v1.CryptoAsset.Limits
 */
export type CryptoAsset_Limits = Message<"ramp.v1.CryptoAsset.Limits"> & {
  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits.Amount single_limit_amount = 10;
   */
  singleLimitAmount?: CryptoAsset_Limits_Amount;

  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits.Amount daily_limit_amount = 20;
   */
  dailyLimitAmount?: CryptoAsset_Limits_Amount;

  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits.Amount daily_used_amount = 30;
   */
  dailyUsedAmount?: CryptoAsset_Limits_Amount;

  /**
   * @generated from field: ramp.v1.CryptoAsset.Limits.Amount daily_remaining_amount = 40;
   */
  dailyRemainingAmount?: CryptoAsset_Limits_Amount;
};

/**
 * Describes the message ramp.v1.CryptoAsset.Limits.
 * Use `create(CryptoAsset_LimitsSchema)` to create a new message.
 */
export const CryptoAsset_LimitsSchema: GenMessage<CryptoAsset_Limits> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 22, 5);

/**
 * @generated from message ramp.v1.CryptoAsset.Limits.Amount
 */
export type CryptoAsset_Limits_Amount = Message<"ramp.v1.CryptoAsset.Limits.Amount"> & {
  /**
   * @generated from field: string asset = 10;
   */
  asset: string;

  /**
   * @generated from field: string fiat = 20;
   */
  fiat: string;
};

/**
 * Describes the message ramp.v1.CryptoAsset.Limits.Amount.
 * Use `create(CryptoAsset_Limits_AmountSchema)` to create a new message.
 */
export const CryptoAsset_Limits_AmountSchema: GenMessage<CryptoAsset_Limits_Amount> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 22, 5, 0);

/**
 * @generated from message ramp.v1.ScanCoordinates
 */
export type ScanCoordinates = Message<"ramp.v1.ScanCoordinates"> & {
  /**
   * always 8 digits
   *
   * @generated from field: string account_number = 10;
   */
  accountNumber: string;

  /**
   * always 6 digits (if using an input mask such as ##-##-##, remove the dashes before submitting)
   *
   * @generated from field: string sort_code = 20;
   */
  sortCode: string;
};

/**
 * Describes the message ramp.v1.ScanCoordinates.
 * Use `create(ScanCoordinatesSchema)` to create a new message.
 */
export const ScanCoordinatesSchema: GenMessage<ScanCoordinates> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 23);

/**
 * @generated from message ramp.v1.IbanCoordinates
 */
export type IbanCoordinates = Message<"ramp.v1.IbanCoordinates"> & {
  /**
   * up to 34 characters (please submit them all uppercase) and numbers
   *
   * @generated from field: string iban = 10;
   */
  iban: string;
};

/**
 * Describes the message ramp.v1.IbanCoordinates.
 * Use `create(IbanCoordinatesSchema)` to create a new message.
 */
export const IbanCoordinatesSchema: GenMessage<IbanCoordinates> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 24);

/**
 * used in the webhook for partners (by default in the JSON format)
 *
 * @generated from message ramp.v1.RampTransaction
 */
export type RampTransaction = Message<"ramp.v1.RampTransaction"> & {
  /**
   * @generated from field: string transaction_id = 10;
   */
  transactionId: string;

  /**
   * @generated from field: string referral_transaction_id = 20;
   */
  referralTransactionId: string;

  /**
   * @generated from field: ramp.v1.RampType type = 30;
   */
  type: RampType;

  /**
   * @generated from field: ramp.v1.RampStatus status = 40;
   */
  status: RampStatus;

  /**
   * @generated from field: ramp.v1.CurrencyId currency = 50;
   */
  currency: CurrencyId;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: ramp.v1.AssetId crypto_asset_id = 60;
   */
  cryptoAssetId: AssetId;

  /**
   * @generated from field: ramp.v1.Protocol crypto_asset_protocol = 70;
   */
  cryptoAssetProtocol: Protocol;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: string fiat_amount = 80;
   */
  fiatAmount: string;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: string crypto_amount = 90;
   */
  cryptoAmount: string;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: string exchange_rate = 100;
   */
  exchangeRate: string;

  /**
   * not set if ramp is not completed yet
   *
   * @generated from field: ramp.v1.RampTransaction.Fees fees = 110;
   */
  fees?: RampTransaction_Fees;

  /**
   * @generated from field: string wallet_address = 120;
   */
  walletAddress: string;

  /**
   * The hash of the transaction related to this ramp. For on-ramp it's the transaction to the user's wallet at the end of the ramp
   * For off-ramp it's the transaction hash that initiated the off-ramp.
   * Could be empty for on-ramp if it's not completed yet (i.e. the funds were not sent to the user's wallet yet)
   *
   * @generated from field: string transaction_hash = 125;
   */
  transactionHash: string;

  /**
   * could be empty if ramp is not completed yet
   *
   * @generated from field: google.protobuf.Timestamp finalized_at = 130;
   */
  finalizedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp initiated_at = 140;
   */
  initiatedAt?: Timestamp;

  /**
   * @generated from field: ramp.v1.PaymentMethod payment_method = 145;
   */
  paymentMethod: PaymentMethod;

  /**
   * fiat values, estimated in USD. Not set if ramp is not completed yet. MUST NOT be used for settlement purposes
   *
   * @generated from field: ramp.v1.RampTransaction.UsdEstimation usd_estimation = 150;
   */
  usdEstimation?: RampTransaction_UsdEstimation;
};

/**
 * Describes the message ramp.v1.RampTransaction.
 * Use `create(RampTransactionSchema)` to create a new message.
 */
export const RampTransactionSchema: GenMessage<RampTransaction> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 25);

/**
 * @generated from message ramp.v1.RampTransaction.Fees
 */
export type RampTransaction_Fees = Message<"ramp.v1.RampTransaction.Fees"> & {
  /**
   * in fiat currency
   *
   * @generated from field: string processing = 10;
   */
  processing: string;

  /**
   * in fiat currency
   *
   * @generated from field: string network = 20;
   */
  network: string;

  /**
   * in fiat currency
   *
   * @generated from field: string referral = 30;
   */
  referral: string;
};

/**
 * Describes the message ramp.v1.RampTransaction.Fees.
 * Use `create(RampTransaction_FeesSchema)` to create a new message.
 */
export const RampTransaction_FeesSchema: GenMessage<RampTransaction_Fees> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 25, 0);

/**
 * @generated from message ramp.v1.RampTransaction.UsdEstimation
 */
export type RampTransaction_UsdEstimation = Message<"ramp.v1.RampTransaction.UsdEstimation"> & {
  /**
   * @generated from field: string amount = 10;
   */
  amount: string;

  /**
   * @generated from field: ramp.v1.RampTransaction.Fees fees = 20;
   */
  fees?: RampTransaction_Fees;
};

/**
 * Describes the message ramp.v1.RampTransaction.UsdEstimation.
 * Use `create(RampTransaction_UsdEstimationSchema)` to create a new message.
 */
export const RampTransaction_UsdEstimationSchema: GenMessage<RampTransaction_UsdEstimation> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 25, 1);

/**
 * @generated from message ramp.v1.GetCountriesRequest
 */
export type GetCountriesRequest = Message<"ramp.v1.GetCountriesRequest"> & {
};

/**
 * Describes the message ramp.v1.GetCountriesRequest.
 * Use `create(GetCountriesRequestSchema)` to create a new message.
 */
export const GetCountriesRequestSchema: GenMessage<GetCountriesRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 26);

/**
 * @generated from message ramp.v1.GetCountriesResponse
 */
export type GetCountriesResponse = Message<"ramp.v1.GetCountriesResponse"> & {
  /**
   * @generated from field: repeated ramp.v1.GetCountriesResponse.Country countries = 10;
   */
  countries: GetCountriesResponse_Country[];
};

/**
 * Describes the message ramp.v1.GetCountriesResponse.
 * Use `create(GetCountriesResponseSchema)` to create a new message.
 */
export const GetCountriesResponseSchema: GenMessage<GetCountriesResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 27);

/**
 * @generated from message ramp.v1.GetCountriesResponse.Country
 */
export type GetCountriesResponse_Country = Message<"ramp.v1.GetCountriesResponse.Country"> & {
  /**
   * @generated from field: string code = 10;
   */
  code: string;

  /**
   * @generated from field: string name = 20;
   */
  name: string;
};

/**
 * Describes the message ramp.v1.GetCountriesResponse.Country.
 * Use `create(GetCountriesResponse_CountrySchema)` to create a new message.
 */
export const GetCountriesResponse_CountrySchema: GenMessage<GetCountriesResponse_Country> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 27, 0);

/**
 * @generated from message ramp.v1.Page
 */
export type Page = Message<"ramp.v1.Page"> & {
  /**
   * zero based numbering
   *
   * @generated from field: optional uint64 index = 10;
   */
  index?: bigint;

  /**
   * max 100
   *
   * @generated from field: optional uint64 size = 20;
   */
  size?: bigint;
};

/**
 * Describes the message ramp.v1.Page.
 * Use `create(PageSchema)` to create a new message.
 */
export const PageSchema: GenMessage<Page> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 28);

/**
 * @generated from message ramp.v1.PagedResult
 */
export type PagedResult = Message<"ramp.v1.PagedResult"> & {
  /**
   * zero based numbering
   *
   * @generated from field: uint64 index = 10;
   */
  index: bigint;

  /**
   * @generated from field: uint64 size = 20;
   */
  size: bigint;

  /**
   * true if next page is available
   *
   * @generated from field: bool has_more = 30;
   */
  hasMore: boolean;
};

/**
 * Describes the message ramp.v1.PagedResult.
 * Use `create(PagedResultSchema)` to create a new message.
 */
export const PagedResultSchema: GenMessage<PagedResult> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 29);

/**
 * @generated from message ramp.v1.SetEmailAddressRequest
 */
export type SetEmailAddressRequest = Message<"ramp.v1.SetEmailAddressRequest"> & {
  /**
   * @generated from field: string email_address = 10;
   */
  emailAddress: string;
};

/**
 * Describes the message ramp.v1.SetEmailAddressRequest.
 * Use `create(SetEmailAddressRequestSchema)` to create a new message.
 */
export const SetEmailAddressRequestSchema: GenMessage<SetEmailAddressRequest> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 30);

/**
 * @generated from message ramp.v1.SetEmailAddressResponse
 */
export type SetEmailAddressResponse = Message<"ramp.v1.SetEmailAddressResponse"> & {
};

/**
 * Describes the message ramp.v1.SetEmailAddressResponse.
 * Use `create(SetEmailAddressResponseSchema)` to create a new message.
 */
export const SetEmailAddressResponseSchema: GenMessage<SetEmailAddressResponse> = /*@__PURE__*/
  messageDesc(file_ramp_v1_public, 31);

/**
 * @generated from enum ramp.v1.RampType
 */
export enum RampType {
  /**
   * @generated from enum value: RAMP_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RAMP_TYPE_ON_RAMP = 10;
   */
  ON_RAMP = 10,

  /**
   * @generated from enum value: RAMP_TYPE_OFF_RAMP = 20;
   */
  OFF_RAMP = 20,
}

/**
 * Describes the enum ramp.v1.RampType.
 */
export const RampTypeSchema: GenEnum<RampType> = /*@__PURE__*/
  enumDesc(file_ramp_v1_public, 0);

/**
 * @generated from enum ramp.v1.RampStatus
 */
export enum RampStatus {
  /**
   * @generated from enum value: RAMP_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RAMP_STATUS_PENDING = 10;
   */
  PENDING = 10,

  /**
   * @generated from enum value: RAMP_STATUS_COMPLETED = 20;
   */
  COMPLETED = 20,
}

/**
 * Describes the enum ramp.v1.RampStatus.
 */
export const RampStatusSchema: GenEnum<RampStatus> = /*@__PURE__*/
  enumDesc(file_ramp_v1_public, 1);

/**
 * @generated from enum ramp.v1.Ecosystem
 */
export enum Ecosystem {
  /**
   * @generated from enum value: ECOSYSTEM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * any EVM compatible chain - addresses are expected to be the right-most 160 bits of the keccak256 hash of the public key
   *
   * @generated from enum value: ECOSYSTEM_ETHEREUM = 10;
   */
  ETHEREUM = 10,

  /**
   * any Cosmos ecosystem chain - addresses are expected to be compatible with the Cosmos SDK (such as 160 bit BECH32)
   *
   * @generated from enum value: ECOSYSTEM_COSMOS = 20;
   */
  COSMOS = 20,

  /**
   * any Substrate ecosystem chain - addresses are expected to be compatible with Substrate (overal 256bit SS58)
   *
   * @generated from enum value: ECOSYSTEM_SUBSTRATE = 30;
   */
  SUBSTRATE = 30,

  /**
   * @generated from enum value: ECOSYSTEM_SOLANA = 40;
   */
  SOLANA = 40,
}

/**
 * Describes the enum ramp.v1.Ecosystem.
 */
export const EcosystemSchema: GenEnum<Ecosystem> = /*@__PURE__*/
  enumDesc(file_ramp_v1_public, 2);

/**
 * @generated from enum ramp.v1.Protocol
 */
export enum Protocol {
  /**
   * @generated from enum value: PROTOCOL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PROTOCOL_ETHEREUM = 10;
   */
  ETHEREUM = 10,

  /**
   * @generated from enum value: PROTOCOL_AVAX = 20;
   */
  AVAX = 20,

  /**
   * @generated from enum value: PROTOCOL_TERRA = 30;
   */
  TERRA = 30,

  /**
   * @generated from enum value: PROTOCOL_POLYGON = 40;
   */
  POLYGON = 40,

  /**
   * @generated from enum value: PROTOCOL_ALEPH_ZERO = 50 [deprecated = true];
   * @deprecated
   */
  ALEPH_ZERO = 50,

  /**
   * @generated from enum value: PROTOCOL_ALEPH_ZERO_L2 = 60;
   */
  ALEPH_ZERO_L2 = 60,

  /**
   * @generated from enum value: PROTOCOL_POLKADOT = 70;
   */
  POLKADOT = 70,

  /**
   * @generated from enum value: PROTOCOL_NOBLE = 80;
   */
  NOBLE = 80,

  /**
   * @generated from enum value: PROTOCOL_ARBITRUM = 90;
   */
  ARBITRUM = 90,

  /**
   * @generated from enum value: PROTOCOL_SOLANA = 100;
   */
  SOLANA = 100,
}

/**
 * Describes the enum ramp.v1.Protocol.
 */
export const ProtocolSchema: GenEnum<Protocol> = /*@__PURE__*/
  enumDesc(file_ramp_v1_public, 3);

/**
 * An AssetId helps the client to identify an exact token and customise the UI.
 * The AssetId is universal across all chains, in fact our responses always include the Network, and the AssetID.
 * So ASSET_ID_USDC will always be the official Circle USDC on any chain, be that Ethereum, or Avalanche, or Polygon.
 *
 * @generated from enum ramp.v1.AssetId
 */
export enum AssetId {
  /**
   * @generated from enum value: ASSET_ID_UNSPECIFIED = 0;
   */
  ASSET_ID_UNSPECIFIED = 0,

  /**
   * @generated from enum value: ASSET_ID_USDC = 10;
   */
  ASSET_ID_USDC = 10,

  /**
   * @generated from enum value: ASSET_ID_AXL_USDC = 20;
   */
  ASSET_ID_AXL_USDC = 20,

  /**
   * @generated from enum value: ASSET_ID_1USD = 30;
   */
  ASSET_ID_1USD = 30,

  /**
   * @generated from enum value: ASSET_ID_ETH = 40;
   */
  ASSET_ID_ETH = 40,

  /**
   * @generated from enum value: ASSET_ID_DOT = 50;
   */
  ASSET_ID_DOT = 50,

  /**
   * @generated from enum value: ASSET_ID_USDE = 60;
   */
  ASSET_ID_USDE = 60,
}

/**
 * Describes the enum ramp.v1.AssetId.
 */
export const AssetIdSchema: GenEnum<AssetId> = /*@__PURE__*/
  enumDesc(file_ramp_v1_public, 4);

/**
 * @generated from enum ramp.v1.CurrencyId
 */
export enum CurrencyId {
  /**
   * @generated from enum value: CURRENCY_ID_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CURRENCY_ID_EUR = 10;
   */
  EUR = 10,

  /**
   * @generated from enum value: CURRENCY_ID_GBP = 20;
   */
  GBP = 20,
}

/**
 * Describes the enum ramp.v1.CurrencyId.
 */
export const CurrencyIdSchema: GenEnum<CurrencyId> = /*@__PURE__*/
  enumDesc(file_ramp_v1_public, 5);

/**
 * @generated from enum ramp.v1.Network
 */
export enum Network {
  /**
   * @generated from enum value: NETWORK_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: NETWORK_ETHEREUM_MAINNET = 10;
   */
  ETHEREUM_MAINNET = 10,

  /**
   * @generated from enum value: NETWORK_ETHEREUM_SEPOLIA = 20;
   */
  ETHEREUM_SEPOLIA = 20,

  /**
   * @generated from enum value: NETWORK_AVAX_FUJI = 30;
   */
  AVAX_FUJI = 30,

  /**
   * @generated from enum value: NETWORK_AVAX_C_MAINNET = 40;
   */
  AVAX_C_MAINNET = 40,

  /**
   * @generated from enum value: NETWORK_TERRA2_MAINNET = 50;
   */
  TERRA2_MAINNET = 50,

  /**
   * @generated from enum value: NETWORK_POLYGON_MAINNET = 60;
   */
  POLYGON_MAINNET = 60,

  /**
   * @generated from enum value: NETWORK_POLYGON_AMOY = 70;
   */
  POLYGON_AMOY = 70,

  /**
   * @generated from enum value: NETWORK_ALEPH_ZERO_MAINNET = 80;
   */
  ALEPH_ZERO_MAINNET = 80,

  /**
   * @generated from enum value: NETWORK_ALEPH_ZERO_TESTNET = 90;
   */
  ALEPH_ZERO_TESTNET = 90,

  /**
   * @generated from enum value: NETWORK_ALEPH_ZERO_L2_MAINNET = 100;
   */
  ALEPH_ZERO_L2_MAINNET = 100,

  /**
   * @generated from enum value: NETWORK_ALEPH_ZERO_L2_TESTNET = 110;
   */
  ALEPH_ZERO_L2_TESTNET = 110,

  /**
   * @generated from enum value: NETWORK_POLKADOT_MAINNET = 120;
   */
  POLKADOT_MAINNET = 120,

  /**
   * @generated from enum value: NETWORK_POLKADOT_TESTNET = 130;
   */
  POLKADOT_TESTNET = 130,

  /**
   * @generated from enum value: NETWORK_NOBLE_MAINNET = 140;
   */
  NOBLE_MAINNET = 140,

  /**
   * @generated from enum value: NETWORK_NOBLE_TESTNET = 150;
   */
  NOBLE_TESTNET = 150,

  /**
   * @generated from enum value: NETWORK_ARBITRUM_MAINNET = 160;
   */
  ARBITRUM_MAINNET = 160,

  /**
   * @generated from enum value: NETWORK_ARBITRUM_SEPOLIA = 170;
   */
  ARBITRUM_SEPOLIA = 170,

  /**
   * @generated from enum value: NETWORK_SOLANA_MAINNET = 180;
   */
  SOLANA_MAINNET = 180,

  /**
   * @generated from enum value: NETWORK_SOLANA_DEVNET = 190;
   */
  SOLANA_DEVNET = 190,
}

/**
 * Describes the enum ramp.v1.Network.
 */
export const NetworkSchema: GenEnum<Network> = /*@__PURE__*/
  enumDesc(file_ramp_v1_public, 6);

/**
 * @generated from enum ramp.v1.PaymentMethod
 */
export enum PaymentMethod {
  /**
   * @generated from enum value: PAYMENT_METHOD_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PAYMENT_METHOD_SEPA = 10;
   */
  SEPA = 10,
}

/**
 * Describes the enum ramp.v1.PaymentMethod.
 */
export const PaymentMethodSchema: GenEnum<PaymentMethod> = /*@__PURE__*/
  enumDesc(file_ramp_v1_public, 7);

/**
 * @generated from service ramp.v1.PingService
 */
export const PingService: GenService<{
  /**
   * @generated from rpc ramp.v1.PingService.Ping
   */
  ping: {
    methodKind: "unary";
    input: typeof PingRequestSchema;
    output: typeof PingResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_ramp_v1_public, 0);

/**
 * All the RPCs in this service require the authentication headers, except the ones for estimating fees.
 *
 * @generated from service ramp.v1.RampService
 */
export const RampService: GenService<{
  /**
   * Returns account information. If result in the response is of type authentication then user should be
   * authenticated (onboarded or logged in). Authentication URL is provided in the result.
   *
   * @generated from rpc ramp.v1.RampService.GetAccountInfo
   */
  getAccountInfo: {
    methodKind: "unary";
    input: typeof GetAccountInfoRequestSchema;
    output: typeof GetAccountInfoResponseSchema;
  },
  /**
   * Whitelists address. Crypto assets can only be on-ramped to address which belongs to the user.
   * In order to proof address belongs to the user, address need to be signed with private key of this address.
   *
   * @generated from rpc ramp.v1.RampService.WhitelistAddress
   */
  whitelistAddress: {
    methodKind: "unary";
    input: typeof WhitelistAddressRequestSchema;
    output: typeof WhitelistAddressResponseSchema;
  },
  /**
   * @generated from rpc ramp.v1.RampService.WhitelistErc1271Address
   */
  whitelistErc1271Address: {
    methodKind: "unary";
    input: typeof WhitelistErc1271AddressRequestSchema;
    output: typeof WhitelistErc1271AddressResponseSchema;
  },
  /**
   *  Removes whitelisted address
   *
   * @generated from rpc ramp.v1.RampService.RemoveAddress
   */
  removeAddress: {
    methodKind: "unary";
    input: typeof RemoveAddressRequestSchema;
    output: typeof RemoveAddressResponseSchema;
  },
  /**
   * Sets a bank account for the off ramp
   *
   * @generated from rpc ramp.v1.RampService.SetBankAccount
   */
  setBankAccount: {
    methodKind: "unary";
    input: typeof SetBankAccountRequestSchema;
    output: typeof SetBankAccountResponseSchema;
  },
  /**
   * @generated from rpc ramp.v1.RampService.GetRamps
   */
  getRamps: {
    methodKind: "unary";
    input: typeof GetRampsRequestSchema;
    output: typeof GetRampsResponseSchema;
  },
  /**
   * @generated from rpc ramp.v1.RampService.RegisterReferralTransaction
   */
  registerReferralTransaction: {
    methodKind: "unary";
    input: typeof RegisterReferralTransactionRequestSchema;
    output: typeof RegisterReferralTransactionResponseSchema;
  },
  /**
   * Authentication headers are not required for these RPCs.
   *
   * @generated from rpc ramp.v1.RampService.EstimateOnRampFee
   */
  estimateOnRampFee: {
    methodKind: "unary";
    input: typeof EstimateOnRampFeeRequestSchema;
    output: typeof EstimateOnRampFeeResponseSchema;
  },
  /**
   * @generated from rpc ramp.v1.RampService.EstimateOffRampFee
   */
  estimateOffRampFee: {
    methodKind: "unary";
    input: typeof EstimateOffRampFeeRequestSchema;
    output: typeof EstimateOffRampFeeResponseSchema;
  },
  /**
   * @generated from rpc ramp.v1.RampService.GetAssets
   */
  getAssets: {
    methodKind: "unary";
    input: typeof GetAssetsRequestSchema;
    output: typeof GetAssetsResponseSchema;
  },
  /**
   * @generated from rpc ramp.v1.RampService.SetEmailAddress
   */
  setEmailAddress: {
    methodKind: "unary";
    input: typeof SetEmailAddressRequestSchema;
    output: typeof SetEmailAddressResponseSchema;
  },
  /**
   * @generated from rpc ramp.v1.RampService.GetCountries
   */
  getCountries: {
    methodKind: "unary";
    input: typeof GetCountriesRequestSchema;
    output: typeof GetCountriesResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_ramp_v1_public, 1);

