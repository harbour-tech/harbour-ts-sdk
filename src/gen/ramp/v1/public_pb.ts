// @generated by protoc-gen-es v1.6.0 with parameter "target=ts"
// @generated from file ramp/v1/public.proto (package ramp.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum ramp.v1.Ecosystem
 */
export enum Ecosystem {
  /**
   * @generated from enum value: ECOSYSTEM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * any EVM compatible chain - addresses are expected to be the right-most 160 bits of the keccak256 hash of the public key
   *
   * @generated from enum value: ECOSYSTEM_ETHEREUM = 10;
   */
  ETHEREUM = 10,

  /**
   * any Cosmos ecosystem chain - addresses are expected to be compatible with the Cosmos SDK (such as 160 bit BECH32)
   *
   * @generated from enum value: ECOSYSTEM_COSMOS = 20;
   */
  COSMOS = 20,
}
// Retrieve enum metadata with: proto3.getEnumType(Ecosystem)
proto3.util.setEnumType(Ecosystem, "ramp.v1.Ecosystem", [
  { no: 0, name: "ECOSYSTEM_UNSPECIFIED" },
  { no: 10, name: "ECOSYSTEM_ETHEREUM" },
  { no: 20, name: "ECOSYSTEM_COSMOS" },
]);

/**
 * An AssetId helps the client to identify an exact token and customise the UI.
 * The AssetId is universal across all chains, in fact our responses always include the Network, and the AssetID.
 * So ASSET_ID_USDC could either be the Ethereum, or Avalanche, or Polygon USDC token.
 *
 * @generated from enum ramp.v1.AssetId
 */
export enum AssetId {
  /**
   * @generated from enum value: ASSET_ID_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ASSET_ID_USDC = 10;
   */
  USDC = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(AssetId)
proto3.util.setEnumType(AssetId, "ramp.v1.AssetId", [
  { no: 0, name: "ASSET_ID_UNSPECIFIED" },
  { no: 10, name: "ASSET_ID_USDC" },
]);

/**
 * @generated from enum ramp.v1.Network
 */
export enum Network {
  /**
   * @generated from enum value: NETWORK_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: NETWORK_ETHEREUM_MAINNET = 10;
   */
  ETHEREUM_MAINNET = 10,

  /**
   * @generated from enum value: NETWORK_ETHEREUM_SEPOLIA = 20;
   */
  ETHEREUM_SEPOLIA = 20,

  /**
   * @generated from enum value: NETWORK_AVAX_FUJI = 30;
   */
  AVAX_FUJI = 30,

  /**
   * @generated from enum value: NETWORK_AVAX_C_MAINNET = 40;
   */
  AVAX_C_MAINNET = 40,
}
// Retrieve enum metadata with: proto3.getEnumType(Network)
proto3.util.setEnumType(Network, "ramp.v1.Network", [
  { no: 0, name: "NETWORK_UNSPECIFIED" },
  { no: 10, name: "NETWORK_ETHEREUM_MAINNET" },
  { no: 20, name: "NETWORK_ETHEREUM_SEPOLIA" },
  { no: 30, name: "NETWORK_AVAX_FUJI" },
  { no: 40, name: "NETWORK_AVAX_C_MAINNET" },
]);

/**
 * @generated from enum ramp.v1.SignatureType
 */
export enum SignatureType {
  /**
   * @generated from enum value: SIGNATURE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SIGNATURE_TYPE_RSA = 1;
   */
  RSA = 1,

  /**
   * @generated from enum value: SIGNATURE_TYPE_SECP256K1 = 2;
   */
  SECP256K1 = 2,

  /**
   * @generated from enum value: SIGNATURE_TYPE_SECP256R1 = 3;
   */
  SECP256R1 = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SignatureType)
proto3.util.setEnumType(SignatureType, "ramp.v1.SignatureType", [
  { no: 0, name: "SIGNATURE_TYPE_UNSPECIFIED" },
  { no: 1, name: "SIGNATURE_TYPE_RSA" },
  { no: 2, name: "SIGNATURE_TYPE_SECP256K1" },
  { no: 3, name: "SIGNATURE_TYPE_SECP256R1" },
]);

/**
 * @generated from message ramp.v1.PingRequest
 */
export class PingRequest extends Message<PingRequest> {
  constructor(data?: PartialMessage<PingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.PingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingRequest {
    return new PingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PingRequest | PlainMessage<PingRequest> | undefined, b: PingRequest | PlainMessage<PingRequest> | undefined): boolean {
    return proto3.util.equals(PingRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.PingResponse
 */
export class PingResponse extends Message<PingResponse> {
  /**
   * @generated from field: string message = 10;
   */
  message = "";

  constructor(data?: PartialMessage<PingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.PingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingResponse {
    return new PingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PingResponse | PlainMessage<PingResponse> | undefined, b: PingResponse | PlainMessage<PingResponse> | undefined): boolean {
    return proto3.util.equals(PingResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoRequest
 */
export class GetAccountInfoRequest extends Message<GetAccountInfoRequest> {
  constructor(data?: PartialMessage<GetAccountInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoRequest {
    return new GetAccountInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoRequest {
    return new GetAccountInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoRequest {
    return new GetAccountInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoRequest | PlainMessage<GetAccountInfoRequest> | undefined, b: GetAccountInfoRequest | PlainMessage<GetAccountInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse
 */
export class GetAccountInfoResponse extends Message<GetAccountInfoResponse> {
  /**
   * @generated from oneof ramp.v1.GetAccountInfoResponse.result
   */
  result: {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.Authentication authentication = 20;
     */
    value: GetAccountInfoResponse_Authentication;
    case: "authentication";
  } | {
    /**
     * @generated from field: ramp.v1.GetAccountInfoResponse.Account account = 30;
     */
    value: GetAccountInfoResponse_Account;
    case: "account";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetAccountInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 20, name: "authentication", kind: "message", T: GetAccountInfoResponse_Authentication, oneof: "result" },
    { no: 30, name: "account", kind: "message", T: GetAccountInfoResponse_Account, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse {
    return new GetAccountInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse {
    return new GetAccountInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse {
    return new GetAccountInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse | PlainMessage<GetAccountInfoResponse> | undefined, b: GetAccountInfoResponse | PlainMessage<GetAccountInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Authentication
 */
export class GetAccountInfoResponse_Authentication extends Message<GetAccountInfoResponse_Authentication> {
  /**
   * @generated from field: string authentication_url = 10;
   */
  authenticationUrl = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_Authentication>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Authentication";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "authentication_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Authentication {
    return new GetAccountInfoResponse_Authentication().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Authentication {
    return new GetAccountInfoResponse_Authentication().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Authentication {
    return new GetAccountInfoResponse_Authentication().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Authentication | PlainMessage<GetAccountInfoResponse_Authentication> | undefined, b: GetAccountInfoResponse_Authentication | PlainMessage<GetAccountInfoResponse_Authentication> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Authentication, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Account
 */
export class GetAccountInfoResponse_Account extends Message<GetAccountInfoResponse_Account> {
  /**
   * list of whitelisted addresses
   *
   * @generated from field: repeated ramp.v1.GetAccountInfoResponse.Wallet wallets = 10;
   */
  wallets: GetAccountInfoResponse_Wallet[] = [];

  /**
   * A bank account created by Harbour in the name of the user, where funds can be sent
   *
   * @generated from oneof ramp.v1.GetAccountInfoResponse.Account.onramp_bank_account
   */
  onrampBankAccount: {
    /**
     * only for scheme SCAN (UK payments)
     *
     * @generated from field: ramp.v1.ScanCoordinates onramp_scan = 100;
     */
    value: ScanCoordinates;
    case: "onrampScan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates onramp_iban = 110;
     */
    value: IbanCoordinates;
    case: "onrampIban";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * A bank account set by the user for off-ramping, see rpc SetBankAccount
   *
   * @generated from oneof ramp.v1.GetAccountInfoResponse.Account.offramp_bank_account
   */
  offrampBankAccount: {
    /**
     * only for scheme SCAN (UK payments)
     *
     * @generated from field: ramp.v1.ScanCoordinates offramp_scan = 200;
     */
    value: ScanCoordinates;
    case: "offrampScan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates offramp_iban = 210;
     */
    value: IbanCoordinates;
    case: "offrampIban";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * account holder name for on and off-ramping
   *
   * @generated from field: string account_holder = 20;
   */
  accountHolder = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_Account>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Account";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "wallets", kind: "message", T: GetAccountInfoResponse_Wallet, repeated: true },
    { no: 100, name: "onramp_scan", kind: "message", T: ScanCoordinates, oneof: "onramp_bank_account" },
    { no: 110, name: "onramp_iban", kind: "message", T: IbanCoordinates, oneof: "onramp_bank_account" },
    { no: 200, name: "offramp_scan", kind: "message", T: ScanCoordinates, oneof: "offramp_bank_account" },
    { no: 210, name: "offramp_iban", kind: "message", T: IbanCoordinates, oneof: "offramp_bank_account" },
    { no: 20, name: "account_holder", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Account {
    return new GetAccountInfoResponse_Account().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Account {
    return new GetAccountInfoResponse_Account().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Account {
    return new GetAccountInfoResponse_Account().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Account | PlainMessage<GetAccountInfoResponse_Account> | undefined, b: GetAccountInfoResponse_Account | PlainMessage<GetAccountInfoResponse_Account> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Account, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet
 */
export class GetAccountInfoResponse_Wallet extends Message<GetAccountInfoResponse_Wallet> {
  /**
   * user given name
   *
   * @generated from field: string name = 5;
   */
  name = "";

  /**
   * @generated from field: ramp.v1.Ecosystem ecosystem = 10;
   */
  ecosystem = Ecosystem.UNSPECIFIED;

  /**
   * @generated from field: string address = 20;
   */
  address = "";

  /**
   * @generated from field: repeated ramp.v1.GetAccountInfoResponse.Wallet.RampAsset assets = 30;
   */
  assets: GetAccountInfoResponse_Wallet_RampAsset[] = [];

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "ecosystem", kind: "enum", T: proto3.getEnumType(Ecosystem) },
    { no: 20, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "assets", kind: "message", T: GetAccountInfoResponse_Wallet_RampAsset, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet {
    return new GetAccountInfoResponse_Wallet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet {
    return new GetAccountInfoResponse_Wallet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet {
    return new GetAccountInfoResponse_Wallet().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet | PlainMessage<GetAccountInfoResponse_Wallet> | undefined, b: GetAccountInfoResponse_Wallet | PlainMessage<GetAccountInfoResponse_Wallet> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.RampAsset
 */
export class GetAccountInfoResponse_Wallet_RampAsset extends Message<GetAccountInfoResponse_Wallet_RampAsset> {
  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.RampAsset.Asset asset = 10;
   */
  asset?: GetAccountInfoResponse_Wallet_RampAsset_Asset;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.OnRamp on_ramp = 20;
   */
  onRamp?: GetAccountInfoResponse_Wallet_OnRamp;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.OffRamp off_ramp = 30;
   */
  offRamp?: GetAccountInfoResponse_Wallet_OffRamp;

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet_RampAsset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet.RampAsset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "asset", kind: "message", T: GetAccountInfoResponse_Wallet_RampAsset_Asset },
    { no: 20, name: "on_ramp", kind: "message", T: GetAccountInfoResponse_Wallet_OnRamp },
    { no: 30, name: "off_ramp", kind: "message", T: GetAccountInfoResponse_Wallet_OffRamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet_RampAsset {
    return new GetAccountInfoResponse_Wallet_RampAsset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_RampAsset {
    return new GetAccountInfoResponse_Wallet_RampAsset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_RampAsset {
    return new GetAccountInfoResponse_Wallet_RampAsset().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet_RampAsset | PlainMessage<GetAccountInfoResponse_Wallet_RampAsset> | undefined, b: GetAccountInfoResponse_Wallet_RampAsset | PlainMessage<GetAccountInfoResponse_Wallet_RampAsset> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet_RampAsset, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.RampAsset.Asset
 */
export class GetAccountInfoResponse_Wallet_RampAsset_Asset extends Message<GetAccountInfoResponse_Wallet_RampAsset_Asset> {
  /**
   * @generated from field: ramp.v1.Network network = 10;
   */
  network = Network.UNSPECIFIED;

  /**
   * the client can use this to match an asset with precision and display custom wording / icon
   *
   * @generated from field: ramp.v1.AssetId asset_id = 20;
   */
  assetId = AssetId.UNSPECIFIED;

  /**
   * to be used as a fallback if the client doesn't recognise the asset_id (eg: out of date proto definitions)
   *
   * @generated from field: string short_name = 30;
   */
  shortName = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet_RampAsset_Asset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet.RampAsset.Asset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "network", kind: "enum", T: proto3.getEnumType(Network) },
    { no: 20, name: "asset_id", kind: "enum", T: proto3.getEnumType(AssetId) },
    { no: 30, name: "short_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet_RampAsset_Asset {
    return new GetAccountInfoResponse_Wallet_RampAsset_Asset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_RampAsset_Asset {
    return new GetAccountInfoResponse_Wallet_RampAsset_Asset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_RampAsset_Asset {
    return new GetAccountInfoResponse_Wallet_RampAsset_Asset().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet_RampAsset_Asset | PlainMessage<GetAccountInfoResponse_Wallet_RampAsset_Asset> | undefined, b: GetAccountInfoResponse_Wallet_RampAsset_Asset | PlainMessage<GetAccountInfoResponse_Wallet_RampAsset_Asset> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet_RampAsset_Asset, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.OnRamp
 */
export class GetAccountInfoResponse_Wallet_OnRamp extends Message<GetAccountInfoResponse_Wallet_OnRamp> {
  /**
   * e.g. "ETH USDC 1" or ETU1
   *
   * @generated from field: string payment_reference = 10;
   */
  paymentReference = "";

  /**
   * can be slightly different as rate is taken at the moment funds hit Harbour wallet / bank account
   *
   * @generated from field: float estimated_rate = 30;
   */
  estimatedRate = 0;

  /**
   * can be slightly different as rate is taken at the moment funds hit Harbour wallet / bank account
   *
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.Fee estimated_network_fee = 40;
   */
  estimatedNetworkFee?: GetAccountInfoResponse_Wallet_Fee;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.Fee processing_fee = 50;
   */
  processingFee?: GetAccountInfoResponse_Wallet_Fee;

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet_OnRamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet.OnRamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "payment_reference", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "estimated_rate", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 40, name: "estimated_network_fee", kind: "message", T: GetAccountInfoResponse_Wallet_Fee },
    { no: 50, name: "processing_fee", kind: "message", T: GetAccountInfoResponse_Wallet_Fee },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet_OnRamp {
    return new GetAccountInfoResponse_Wallet_OnRamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OnRamp {
    return new GetAccountInfoResponse_Wallet_OnRamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OnRamp {
    return new GetAccountInfoResponse_Wallet_OnRamp().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet_OnRamp | PlainMessage<GetAccountInfoResponse_Wallet_OnRamp> | undefined, b: GetAccountInfoResponse_Wallet_OnRamp | PlainMessage<GetAccountInfoResponse_Wallet_OnRamp> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet_OnRamp, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.OffRamp
 */
export class GetAccountInfoResponse_Wallet_OffRamp extends Message<GetAccountInfoResponse_Wallet_OffRamp> {
  /**
   * @generated from field: string address = 10;
   */
  address = "";

  /**
   * can be slightly different as rate is taken at the moment funds hit Harbour wallet / bank account
   *
   * @generated from field: float estimated_rate = 30;
   */
  estimatedRate = 0;

  /**
   * can be slightly different as rate is taken at the moment funds hit Harbour wallet / bank account
   *
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.Fee estimated_network_fee = 40;
   */
  estimatedNetworkFee?: GetAccountInfoResponse_Wallet_Fee;

  /**
   * @generated from field: ramp.v1.GetAccountInfoResponse.Wallet.Fee processing_fee = 50;
   */
  processingFee?: GetAccountInfoResponse_Wallet_Fee;

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet_OffRamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet.OffRamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "estimated_rate", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 40, name: "estimated_network_fee", kind: "message", T: GetAccountInfoResponse_Wallet_Fee },
    { no: 50, name: "processing_fee", kind: "message", T: GetAccountInfoResponse_Wallet_Fee },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet_OffRamp {
    return new GetAccountInfoResponse_Wallet_OffRamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OffRamp {
    return new GetAccountInfoResponse_Wallet_OffRamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_OffRamp {
    return new GetAccountInfoResponse_Wallet_OffRamp().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet_OffRamp | PlainMessage<GetAccountInfoResponse_Wallet_OffRamp> | undefined, b: GetAccountInfoResponse_Wallet_OffRamp | PlainMessage<GetAccountInfoResponse_Wallet_OffRamp> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet_OffRamp, a, b);
  }
}

/**
 * @generated from message ramp.v1.GetAccountInfoResponse.Wallet.Fee
 */
export class GetAccountInfoResponse_Wallet_Fee extends Message<GetAccountInfoResponse_Wallet_Fee> {
  /**
   * denominated in the currency of bank account (EUR, GBP)
   *
   * @generated from field: string fix = 10;
   */
  fix = "";

  /**
   * @generated from field: string percent = 20;
   */
  percent = "";

  constructor(data?: PartialMessage<GetAccountInfoResponse_Wallet_Fee>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.GetAccountInfoResponse.Wallet.Fee";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "fix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "percent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountInfoResponse_Wallet_Fee {
    return new GetAccountInfoResponse_Wallet_Fee().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_Fee {
    return new GetAccountInfoResponse_Wallet_Fee().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountInfoResponse_Wallet_Fee {
    return new GetAccountInfoResponse_Wallet_Fee().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountInfoResponse_Wallet_Fee | PlainMessage<GetAccountInfoResponse_Wallet_Fee> | undefined, b: GetAccountInfoResponse_Wallet_Fee | PlainMessage<GetAccountInfoResponse_Wallet_Fee> | undefined): boolean {
    return proto3.util.equals(GetAccountInfoResponse_Wallet_Fee, a, b);
  }
}

/**
 * @generated from message ramp.v1.WhitelistAddressRequest
 */
export class WhitelistAddressRequest extends Message<WhitelistAddressRequest> {
  /**
   * user given name, could be same name as in the Self Custody wallet if supported by wallet vendor
   * (the maximum length of the name is 100 symbols)
   *
   * @generated from field: string name = 10;
   */
  name = "";

  /**
   * @generated from field: ramp.v1.Ecosystem ecosystem = 20;
   */
  ecosystem = Ecosystem.UNSPECIFIED;

  /**
   * @generated from field: string address = 30;
   */
  address = "";

  /**
   * for the Ethereum: the address filed should be signed with https://docs.metamask.io/wallet/reference/personal_sign/ using
   * private key of this address
   *
   * @generated from field: string address_signature = 40;
   */
  addressSignature = "";

  constructor(data?: PartialMessage<WhitelistAddressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.WhitelistAddressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "ecosystem", kind: "enum", T: proto3.getEnumType(Ecosystem) },
    { no: 30, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 40, name: "address_signature", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WhitelistAddressRequest {
    return new WhitelistAddressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WhitelistAddressRequest {
    return new WhitelistAddressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WhitelistAddressRequest {
    return new WhitelistAddressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WhitelistAddressRequest | PlainMessage<WhitelistAddressRequest> | undefined, b: WhitelistAddressRequest | PlainMessage<WhitelistAddressRequest> | undefined): boolean {
    return proto3.util.equals(WhitelistAddressRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.WhitelistAddressResponse
 */
export class WhitelistAddressResponse extends Message<WhitelistAddressResponse> {
  constructor(data?: PartialMessage<WhitelistAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.WhitelistAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WhitelistAddressResponse {
    return new WhitelistAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WhitelistAddressResponse {
    return new WhitelistAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WhitelistAddressResponse {
    return new WhitelistAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WhitelistAddressResponse | PlainMessage<WhitelistAddressResponse> | undefined, b: WhitelistAddressResponse | PlainMessage<WhitelistAddressResponse> | undefined): boolean {
    return proto3.util.equals(WhitelistAddressResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.RemoveAddressRequest
 */
export class RemoveAddressRequest extends Message<RemoveAddressRequest> {
  /**
   * @generated from field: ramp.v1.Ecosystem ecosystem = 20;
   */
  ecosystem = Ecosystem.UNSPECIFIED;

  /**
   * @generated from field: string address = 30;
   */
  address = "";

  constructor(data?: PartialMessage<RemoveAddressRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.RemoveAddressRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 20, name: "ecosystem", kind: "enum", T: proto3.getEnumType(Ecosystem) },
    { no: 30, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveAddressRequest {
    return new RemoveAddressRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveAddressRequest {
    return new RemoveAddressRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveAddressRequest {
    return new RemoveAddressRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveAddressRequest | PlainMessage<RemoveAddressRequest> | undefined, b: RemoveAddressRequest | PlainMessage<RemoveAddressRequest> | undefined): boolean {
    return proto3.util.equals(RemoveAddressRequest, a, b);
  }
}

/**
 * @generated from message ramp.v1.RemoveAddressResponse
 */
export class RemoveAddressResponse extends Message<RemoveAddressResponse> {
  constructor(data?: PartialMessage<RemoveAddressResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.RemoveAddressResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveAddressResponse {
    return new RemoveAddressResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveAddressResponse {
    return new RemoveAddressResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveAddressResponse {
    return new RemoveAddressResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveAddressResponse | PlainMessage<RemoveAddressResponse> | undefined, b: RemoveAddressResponse | PlainMessage<RemoveAddressResponse> | undefined): boolean {
    return proto3.util.equals(RemoveAddressResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.SetBankAccountRequest
 */
export class SetBankAccountRequest extends Message<SetBankAccountRequest> {
  /**
   * first and last beneficiary name is not required. KYC info will be used as beneficiary name
   *
   * @generated from oneof ramp.v1.SetBankAccountRequest.bank_account
   */
  bankAccount: {
    /**
     * only for scheme SCAN
     *
     * @generated from field: ramp.v1.ScanCoordinates scan = 10;
     */
    value: ScanCoordinates;
    case: "scan";
  } | {
    /**
     * for both SEPA and SWIFT schemes
     *
     * @generated from field: ramp.v1.IbanCoordinates iban = 20;
     */
    value: IbanCoordinates;
    case: "iban";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SetBankAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.SetBankAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "scan", kind: "message", T: ScanCoordinates, oneof: "bank_account" },
    { no: 20, name: "iban", kind: "message", T: IbanCoordinates, oneof: "bank_account" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetBankAccountRequest {
    return new SetBankAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetBankAccountRequest {
    return new SetBankAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetBankAccountRequest {
    return new SetBankAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetBankAccountRequest | PlainMessage<SetBankAccountRequest> | undefined, b: SetBankAccountRequest | PlainMessage<SetBankAccountRequest> | undefined): boolean {
    return proto3.util.equals(SetBankAccountRequest, a, b);
  }
}

/**
 * TODO the client should be able to comply to basic validation rules such as min/max length for ibans, sort codes and account numbers
 * however complex validation such as IBAN or SCAN checksums and sort code directory should be performed by us
 * thus we need to define proper error responses
 *
 * @generated from message ramp.v1.SetBankAccountResponse
 */
export class SetBankAccountResponse extends Message<SetBankAccountResponse> {
  constructor(data?: PartialMessage<SetBankAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.SetBankAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetBankAccountResponse {
    return new SetBankAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetBankAccountResponse {
    return new SetBankAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetBankAccountResponse {
    return new SetBankAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetBankAccountResponse | PlainMessage<SetBankAccountResponse> | undefined, b: SetBankAccountResponse | PlainMessage<SetBankAccountResponse> | undefined): boolean {
    return proto3.util.equals(SetBankAccountResponse, a, b);
  }
}

/**
 * @generated from message ramp.v1.ScanCoordinates
 */
export class ScanCoordinates extends Message<ScanCoordinates> {
  /**
   * always 8 digits
   *
   * @generated from field: string account_number = 10;
   */
  accountNumber = "";

  /**
   * always 6 digits (if using an input mask such as ##-##-##, remove the dashes before submitting)
   *
   * @generated from field: string sort_code = 20;
   */
  sortCode = "";

  constructor(data?: PartialMessage<ScanCoordinates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.ScanCoordinates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "account_number", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "sort_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScanCoordinates {
    return new ScanCoordinates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScanCoordinates {
    return new ScanCoordinates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScanCoordinates {
    return new ScanCoordinates().fromJsonString(jsonString, options);
  }

  static equals(a: ScanCoordinates | PlainMessage<ScanCoordinates> | undefined, b: ScanCoordinates | PlainMessage<ScanCoordinates> | undefined): boolean {
    return proto3.util.equals(ScanCoordinates, a, b);
  }
}

/**
 * @generated from message ramp.v1.IbanCoordinates
 */
export class IbanCoordinates extends Message<IbanCoordinates> {
  /**
   * up to 34 characters (please submit them all uppercase) and numbers
   *
   * @generated from field: string iban = 10;
   */
  iban = "";

  constructor(data?: PartialMessage<IbanCoordinates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ramp.v1.IbanCoordinates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "iban", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IbanCoordinates {
    return new IbanCoordinates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IbanCoordinates {
    return new IbanCoordinates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IbanCoordinates {
    return new IbanCoordinates().fromJsonString(jsonString, options);
  }

  static equals(a: IbanCoordinates | PlainMessage<IbanCoordinates> | undefined, b: IbanCoordinates | PlainMessage<IbanCoordinates> | undefined): boolean {
    return proto3.util.equals(IbanCoordinates, a, b);
  }
}

