// @generated by protoc-gen-es v1.8.0 with parameter "target=ts"
// @generated from file auth/v1/public.proto (package auth.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message auth.v1.AuthenticateWalletRequest
 */
export class AuthenticateWalletRequest extends Message<AuthenticateWalletRequest> {
  /**
   * @generated from field: bytes public_key = 10;
   */
  publicKey = new Uint8Array(0);

  /**
   * @generated from field: auth.v1.AuthenticateWalletRequest.PublicKeyType public_key_type = 20;
   */
  publicKeyType = AuthenticateWalletRequest_PublicKeyType.UNSPECIFIED;

  /**
   * @generated from field: auth.v1.AuthenticateWalletRequest.HashingAlgo hashing_algo = 25;
   */
  hashingAlgo = AuthenticateWalletRequest_HashingAlgo.UNSPECIFIED;

  /**
   * @generated from field: bytes signature = 30;
   */
  signature = new Uint8Array(0);

  constructor(data?: PartialMessage<AuthenticateWalletRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.AuthenticateWalletRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 20, name: "public_key_type", kind: "enum", T: proto3.getEnumType(AuthenticateWalletRequest_PublicKeyType) },
    { no: 25, name: "hashing_algo", kind: "enum", T: proto3.getEnumType(AuthenticateWalletRequest_HashingAlgo) },
    { no: 30, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticateWalletRequest {
    return new AuthenticateWalletRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticateWalletRequest {
    return new AuthenticateWalletRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticateWalletRequest {
    return new AuthenticateWalletRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticateWalletRequest | PlainMessage<AuthenticateWalletRequest> | undefined, b: AuthenticateWalletRequest | PlainMessage<AuthenticateWalletRequest> | undefined): boolean {
    return proto3.util.equals(AuthenticateWalletRequest, a, b);
  }
}

/**
 * @generated from enum auth.v1.AuthenticateWalletRequest.PublicKeyType
 */
export enum AuthenticateWalletRequest_PublicKeyType {
  /**
   * @generated from enum value: PUBLIC_KEY_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PUBLIC_KEY_TYPE_SECP256K1 = 1;
   */
  SECP256K1 = 1,

  /**
   * @generated from enum value: PUBLIC_KEY_TYPE_SR25519 = 2;
   */
  SR25519 = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AuthenticateWalletRequest_PublicKeyType)
proto3.util.setEnumType(AuthenticateWalletRequest_PublicKeyType, "auth.v1.AuthenticateWalletRequest.PublicKeyType", [
  { no: 0, name: "PUBLIC_KEY_TYPE_UNSPECIFIED" },
  { no: 1, name: "PUBLIC_KEY_TYPE_SECP256K1" },
  { no: 2, name: "PUBLIC_KEY_TYPE_SR25519" },
]);

/**
 * @generated from enum auth.v1.AuthenticateWalletRequest.HashingAlgo
 */
export enum AuthenticateWalletRequest_HashingAlgo {
  /**
   * @generated from enum value: HASHING_ALGO_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: HASHING_ALGO_SHA256 = 1;
   */
  SHA256 = 1,

  /**
   * @generated from enum value: HASHING_ALGO_KECCAK256 = 2;
   */
  KECCAK256 = 2,

  /**
   * @generated from enum value: HASHING_ALGO_ETHEREUM = 3;
   */
  ETHEREUM = 3,

  /**
   * @generated from enum value: HASHING_ALGO_BLAKE2B = 4;
   */
  BLAKE2B = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(AuthenticateWalletRequest_HashingAlgo)
proto3.util.setEnumType(AuthenticateWalletRequest_HashingAlgo, "auth.v1.AuthenticateWalletRequest.HashingAlgo", [
  { no: 0, name: "HASHING_ALGO_UNSPECIFIED" },
  { no: 1, name: "HASHING_ALGO_SHA256" },
  { no: 2, name: "HASHING_ALGO_KECCAK256" },
  { no: 3, name: "HASHING_ALGO_ETHEREUM" },
  { no: 4, name: "HASHING_ALGO_BLAKE2B" },
]);

/**
 * @generated from message auth.v1.AuthenticateWalletResponse
 */
export class AuthenticateWalletResponse extends Message<AuthenticateWalletResponse> {
  /**
   * @generated from oneof auth.v1.AuthenticateWalletResponse.result
   */
  result: {
    /**
     * @generated from field: auth.v1.AuthenticateWalletResponse.Error error = 10;
     */
    value: AuthenticateWalletResponse_Error;
    case: "error";
  } | {
    /**
     * @generated from field: auth.v1.PublicKeyToken public_key_token = 20;
     */
    value: PublicKeyToken;
    case: "publicKeyToken";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AuthenticateWalletResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.AuthenticateWalletResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "error", kind: "enum", T: proto3.getEnumType(AuthenticateWalletResponse_Error), oneof: "result" },
    { no: 20, name: "public_key_token", kind: "message", T: PublicKeyToken, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthenticateWalletResponse {
    return new AuthenticateWalletResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthenticateWalletResponse {
    return new AuthenticateWalletResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthenticateWalletResponse {
    return new AuthenticateWalletResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AuthenticateWalletResponse | PlainMessage<AuthenticateWalletResponse> | undefined, b: AuthenticateWalletResponse | PlainMessage<AuthenticateWalletResponse> | undefined): boolean {
    return proto3.util.equals(AuthenticateWalletResponse, a, b);
  }
}

/**
 * @generated from enum auth.v1.AuthenticateWalletResponse.Error
 */
export enum AuthenticateWalletResponse_Error {
  /**
   * @generated from enum value: ERROR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ERROR_UNSUPPORTED_PUBLIC_KEY_TYPE = 1;
   */
  UNSUPPORTED_PUBLIC_KEY_TYPE = 1,

  /**
   * @generated from enum value: ERROR_UNSUPPORTED_HASHING_ALGO = 2;
   */
  UNSUPPORTED_HASHING_ALGO = 2,

  /**
   * @generated from enum value: ERROR_INVALID_SIGNATURE = 3;
   */
  INVALID_SIGNATURE = 3,

  /**
   * @generated from enum value: ERROR_INVALID_PUBLIC_KEY = 4;
   */
  INVALID_PUBLIC_KEY = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(AuthenticateWalletResponse_Error)
proto3.util.setEnumType(AuthenticateWalletResponse_Error, "auth.v1.AuthenticateWalletResponse.Error", [
  { no: 0, name: "ERROR_UNSPECIFIED" },
  { no: 1, name: "ERROR_UNSUPPORTED_PUBLIC_KEY_TYPE" },
  { no: 2, name: "ERROR_UNSUPPORTED_HASHING_ALGO" },
  { no: 3, name: "ERROR_INVALID_SIGNATURE" },
  { no: 4, name: "ERROR_INVALID_PUBLIC_KEY" },
]);

/**
 * @generated from message auth.v1.PublicKeyToken
 */
export class PublicKeyToken extends Message<PublicKeyToken> {
  /**
   * @generated from field: string token = 10;
   */
  token = "";

  /**
   * @generated from field: google.protobuf.Timestamp expires_at = 20;
   */
  expiresAt?: Timestamp;

  constructor(data?: PartialMessage<PublicKeyToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "auth.v1.PublicKeyToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 10, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "expires_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicKeyToken {
    return new PublicKeyToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicKeyToken {
    return new PublicKeyToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicKeyToken {
    return new PublicKeyToken().fromJsonString(jsonString, options);
  }

  static equals(a: PublicKeyToken | PlainMessage<PublicKeyToken> | undefined, b: PublicKeyToken | PlainMessage<PublicKeyToken> | undefined): boolean {
    return proto3.util.equals(PublicKeyToken, a, b);
  }
}

