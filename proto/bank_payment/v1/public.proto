syntax = "proto3";
package bank_payment.v1;

service PingService {
  rpc Ping (PingRequest) returns (PingResponse) {}
}

message PingRequest {
}

message PingResponse {
  string message = 10;
}

service BeneficiaryService {
  // Returns all of a user's beneficiaries for a certain bank scheme. Requires an authenticated user.
  rpc GetBeneficiaries (GetBeneficiariesRequest) returns (GetBeneficiariesResponse) {}

  // Adding a beneficiary consist of the two steps: adding a beneficiary and then confirming via OTP.
  // Note: there is no restriction on creating duplicate beneficiaries, but the backend will generate a UUID for each.
  // Returns a code invalid argument in case of missing mandatory fields, or invalid char length.
  // Returns an error enum for validations to be shown to the user.
  // Requires an authenticated user.
  rpc AddBeneficiary (AddBeneficiaryRequest) returns (AddBeneficiaryResponse) {}

  // To be invoked after AddBeneficiary with a valid OTP.
  // Requires an authenticated user.
  rpc AddBeneficiaryConfirm (AddBeneficiaryConfirmRequest) returns (AddBeneficiaryConfirmResponse) {}
}

service PaymentService {
  // Single RPC for executing any bank payment for any of the supported schemes.
  // Please note that the payment processing is asynchronous: after basic validation, the backend will run a workflow
  // made of several steps to process it. The first step consists in persisting the payment as "INITIALISED" in the user
  // bank wallet. It will then be processed through different stages such as "PENDING" and then finally either CLEARED
  // or FAILED/REJECTED.
  // Before showing a success screen to the user, after a successful MakePaymentResponse, the client should poll the
  // wallet service every few seconds to check whether the payment is present in the wallet (regardless of its status).
  // The transaction can be identified as its ID is precisely the submitted idempotency key.
  // After 12 seconds, the client should give up and tell the user that something went wrong and please try later.
  // Note for backend engineers: the backend will set a 10-second expiry on the payment, so there's no risk of
  // processing the payment after having shown a failure message to the customer.

  // The whole point of this complex mechanism is to solve a typical eventual consistency problem in distributed systems.
  // If we show a success message to the user upon a successful response, there is no guarantee that the workflow will
  // ever start processing it. Example: a bug in interpreting an event, or a mis-configuration of a queue, or our
  // workflow software being down. So the user might come back to the wallet screen and be confused as they see no payment
  // even after receiving a success message. The risk is not just confusion, but also the user attempting to send the
  // same payment again. If the messages are eventually picked up, they might result in several duplicate payments,
  // which is why we need a timeout on the message, and which is why the client needs to look for signs of the message
  // being processed by polling the wallet for at least 10 seconds + 2 seconds buffer.
  // This ensures that the user will only ever see a success message if a transaction has already been stored on the wallet,
  // and also ensures that no payment gets processed if the user can't see the transaction on the wallet within 10 seconds.
  //
  // Final note: by "success" here we mean that we successfully started processing the payment.
  // It is not a guarantee of the payment leaving our system and reaching the intended destination.
  // In most cases a payment will be cleared within a few seconds and the client will receive a push notification.
  // In some cases, the payment might fail because of invalid coordinates, or because of potential fraud detection.
  // In other causes, the payment might remain PENDING for a long time, for fraud checks on our end.
  // Finally, in some cases the payment might be CLEARED, only to bounce a few days later as an entirely new inbound
  // payment, which happens when the destination bank rejects the payment. Typically because the account number does not
  // exist or the payee name does not match, or fraud is suspected. It is important to note that in this case the user
  // will see a successful payment (eg: -100 EUR) and a few days later an inbound payment of opposite amount (100 EUR).
  rpc MakePayment (MakePaymentRequest) returns (MakePaymentResponse) {}
}

enum Scheme {
  SCHEME_UNSPECIFIED = 0;
  SCHEME_SCAN = 1; // use for UK domestic payments
  SCHEME_SEPA = 2; // use for EUR international and domestic payments
  SCHEME_SWIFT = 3; // use for non-EUR international payments
}

message GetBeneficiariesRequest {
  string user_id = 10;
  // scheme - optional parameter, if specified, the endpoint returns only the beneficiaries for a certain scheme
  optional Scheme scheme = 20;
}

message GetBeneficiariesResponse {
  // beneficiaries are sorted by last name, created_at
  repeated Beneficiary entries = 10;
}

message Beneficiary {
  string id = 10; // server-generated UUID, omit when requesting beneficiary addition
  Scheme scheme = 20; // mandatory
  string alias = 30; // mandatory max length 50 chars, should be used as beneficiary name when showing in a list, if customer chooses no alias it's recommended submit the beneficiary name

  oneof beneficiary {
    IndividualBeneficiary individual = 40;
    BusinessBeneficiary business = 50;
  }

  oneof coordinates {
    ScanCoordinates scan_coord = 60; // only for scheme SCAN
    IbanCoordinates iban_coord = 70; // for both SEPA and SWIFT schemes
  }
}

message IndividualBeneficiary {
  // note: all fields must contain just A-Z a-z 0-9 - . / (and spaces)
  // you can use the following regexp: ^[A-Za-z0-9&\-./ ]+$
  string first_name = 10; // mandatory max length 30 chars
  string last_name = 20; // mandatory max length 30 chars
}

message BusinessBeneficiary {
  // note: all fields must contain just A-Z a-z 0-9 - . / (and spaces)
  string business_name = 10; // mandatory max length 50 chars
}

message ScanCoordinates {
  string account_number = 10; // always 8 digits
  string sort_code = 20; // always 6 digits (if using an input mask such as ##-##-##, remove the dashes before submitting)
}

message IbanCoordinates {
  string iban = 10; // up to 34 characters (please submit them all uppercase) and numbers
  // not required (only for international payments),
  // either 8 or 11 characters (please submit them all uppercase) and numbers
  string bic = 20;
}

message AddBeneficiaryRequest {
  string user_id = 10;
  // Only in non-prod environments, certain beneficiaries will impact the lifecycle of any payment sent to them,
  // to facilitate testing frontend logic, based on the beneficiary first and last name.
  // Lord Sauron: the payment will be accepted, but will time out without ever appearing on the transaction list
  // Lord Saruman: the payment will be accepted, only to fail a few instants later with insufficient funds
  // Lord Voldemort: the payment will be accepted, only to fail a few instants later with a limit exceeded error
  // Lord Thanos: the payment will be accepted, only to fail a few instants later with a server error
  // Note: make sure the account number / sort code combination is still valid, to pass beneficiary validation
  Beneficiary beneficiary = 20;
  // Set dry run to true to invoke the RPC without actually creating the beneficiary.
  // Useful to perform validation on input parameters.
  bool dry_run = 30;
}

message AddBeneficiaryResponse {
  oneof result {
    Error error = 1;
    string token = 2;
  }
  enum Error {
    ERROR_UNSPECIFIED = 0;

    // Returned when the routing code is wrong (eg: sort code for UK and BIC for ibans).
    // Note: the client still needs to perform basic validation, such as guaranteeing that the sort code is exactly 6 digits,
    // else it won't even get this response and just get a code invalid argument.
    // However, the backend will perform more advanced validation, such as checking that the sort code exists, in which
    // case it will return this error.
    ERROR_BANK_CODE_INVALID = 1;

    // Same as above, but for the account number (eg: account number for UK and IBAN for ibans).
    // In case of UK account numbers, the account number is validated against the sort code, to determine whether it's
    // valid according to the destination bank.
    // In case of IBAN, basic mathematical checks will be performed, according to the IBAN standard, to verify its validity.
    ERROR_BANK_NUMBER_INVALID = 2;

    // Note: format errors such as submitting the wrong number of characters, or missing fields,
    // will result in a code invalid argument response error

    // Returned when the combination of bank code and bank number is invalid.
    ERROR_CODE_AND_NUMBER_INVALID = 3;
  }
}

message AddBeneficiaryConfirmRequest {
  string user_id = 10;
  string otp = 20;
  string token = 30;
}

message AddBeneficiaryConfirmResponse {
  oneof result {
    Error error = 10;
    string beneficiary_id = 20; // server-generated UUID for this beneficiary
  }

  enum Error {
    ERROR_UNSPECIFIED = 0;
    ERROR_OTP_INVALID = 1;
    ERROR_OTP_EXPIRED = 2;
    ERROR_OTP_ALREADY_USED = 3;
    ERROR_TOKEN_INVALID = 4;
  }
}

message MakePaymentRequest {
  // Mandatory, user executing the payment
  string user_id = 10;

  // Mandatory, account from which to take the payment - also determines payment currency
  string account_id = 20;

  // Mandatory, beneficiary to which to send the payment.
  // The payment scheme is inferred by the beneficiary.
  string beneficiary_id = 30;

  // Mandatory, how much the beneficiary should receive, represented as a floating point decimal in the currency's main
  // unit. Eg: 100.20 for 100 euros and 20 cent. Must be a positive number.
  // There is no fee at the moment, but can easily be added later
  // Min-max amount per scheme:
  // SCAN: 0.01 - 1M
  string net_amount = 40;

  // Mandatory reference for the payment (eg: "pay energy bill")
  // Min-max length per scheme (after trimming any leading/trailing whitespace):
  // SCAN: 6-18
  // Allowed characters per scheme (spaces are always allowed, but any leading/trailing will be trimmed by backend):
  // SCAN: A-Z a-z 0-9 - . / (and spaces)
  string reference = 50;

  // This flag can be used to validate all the parameters without actually making any payment.
  // At the moment all field validation can be performed by the client, so there's no use for this flag.
  // The client can simply validate all the fields, invoke the RPC, and see if there's a non-zero error enum.
  bool dry_run = 60;

  // Idempotency key to avoid double spend. It has to be a UUID (36 chars). It's recommended to generate a v4 UUID.
  // This serves as protection in case the request times out, and the user taps the send button again.
  // However, the UUID should be re-generated if the user changes any of the input parameters, as it is effectively a
  // different payment. Required.
  string idempotency_key = 70;

  // Standard jwt with vendor_device_id claim and strict expiry, same as when authenticating
  // note: if this is built incorrectly you'll get a grpc code invalid argument
  string signature = 80;
}

message MakePaymentResponse {
  oneof result {
    Error error = 10;
    Payment payment = 20;
  }
  enum Error {
    // Request is valid, no error
    ERROR_UNSPECIFIED = 0;

    // Invalid beneficiary ID. In theory the client should pick a valid beneficiary, but in extremely unlikely and
    // purely theoretical cases, another device might have deleted the beneficiary in the meantime, so it's best to handle
    // this error on the client and display a meaningful error message to the user.
    ERROR_INVALID_BENEFICIARY_ID = 1;

    // Insufficient funds on the account to withdraw.
    ERROR_INSUFFICIENT_BALANCE = 2;

    // Every user might have different limits per single transaction, or daily/monthly.
    // These might be unknown to the client, so the backend will perform this check and the client should display
    // a meaningful error message to the user.
    ERROR_LIMITS_EXCEED = 3;

    // Account is blocked (possibly temporarily) from sending assets out of Harbor.
    ERROR_BLOCKED = 4;

    // Other kind of errors which the client code is responsible to prevent:
    // - ensure that the amount is a positive number
    // - ensure that it complies with the min/max amount per payment scheme
    // - use currency libraries (or hardcode per supported currency) to ensure that the precision is not exceeded
    //   (eg: 10.02 EUR is valid, 10.021 is not)
    // - ensure that the reference complies with the min/max length and valid characters per payment scheme
    // Note: any violation will cause a code invalid argument
  }
  message Payment {
    string payment_id = 10;
  }
}
