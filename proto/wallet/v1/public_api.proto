syntax = "proto3";

package wallet.v1;

import "google/protobuf/timestamp.proto";
import "wallet/v1/public_data_crypto.proto";
import "wallet/v1/public_data_bank.proto";


// IMPORTANT NOTE:
// Amounts are always formatted as floating-point strings in our API, to avoid being constrained by float64 or int64 limits.
// Eg: 124.01
// Note: the client is responsible for parsing the amount into a big decimal library of their choice.
// You cannot show the amount as a string to the user, as it then needs to be converted to local device settings.
// Eg: should display 1,200.01 in UK and USA, and display 1.200,01 in Italy and France.

// ALSO:
// Normally enums with 0 value indicate some kind of communication error in the protocol
// Keep in mind that in some scenarios we might genuinely not know or be able to map a payment or transaction type
// So treat the enums in here as "we don't really know".

service PingService {
  rpc Ping (PingRequest) returns (PingResponse) {}
}

message PingRequest {
}

message PingResponse {
  string message = 10;
}

service WalletService {
  // Get all bank accounts to which a user has access.
  // Returns an empty list if user has no accounts (such as before identity check), does not check user existence.
  // Returns a PERMISSION_DENIED code if the user_id param does not match the authenticated user
  rpc GetBankAccounts(GetBankAccountsRequest) returns (GetBankAccountsResponse) {}

  // Get a bank account by ID to which a user has access.
  // Returns a not found error code in case user has no such account with provided ID, does not check user existence.
  // Returns a PERMISSION_DENIED code if the user_id param does not match the authenticated user
  rpc GetBankAccount(GetBankAccountRequest) returns (GetBankAccountResponse) {}

  // Get all crypto accounts to which a user has access.
  // Returns an empty list if user has no balances, does not check user existence.
  // Keep in mind that a balance is an entity, so there's a difference between not having a crypto balance and having a zero balance.
  // Crypto balances need to be initialised before users can interact with the respective blockchain, which is why
  // for certain crypto currencies there might be a missing (non-initialised) balance.
  // Returns an UNAUTHENTICATED code if the user_id param does not match the authenticated user
  rpc GetCryptoAccounts(GetCryptoAccountsRequest) returns (GetCryptoAccountsResponse) {}

  // Get a crypto account by ID to which a user has access.
  // Returns a not found error in case user has no such account, does not check user existence.
  // Returns an UNAUTHENTICATED code if the user_id param does not match the authenticated user
  rpc GetCryptoAccount(GetCryptoAccountRequest) returns (GetCryptoAccountResponse) {}
  
  // Creates a new crypto wallet for the user, and returns it.
  rpc CreateCryptoAccount(CreateCryptoAccountRequest) returns (CreateCryptoAccountResponse) {}

  // Get all crypto transactions across all wallets a user has access to.
  // Returns a PERMISSION_DENIED code if the authenticated user has no access to the specified account,
  // or if the authenticated user does not match the user id.
  // This returns a timeline of crypto transactions from the most recent to the oldest.
  // Use case: infinite scroll in a UI from most recent crypto transactions in reverse order until some point in the past.
  rpc GetCryptoTransactionTimeline(GetCryptoTransactionTimelineRequest) returns (GetCryptoTransactionTimelineResponse) {}

  // Get all bank transactions across all accounts a user has access to.
  // Returns a PERMISSION_DENIED code if the authenticated user has no access to the specified account,
  // or if the authenticated user does not match the user id.
  // This returns a timeline of bank transactions from the most recent to the oldest.
  // Use case: infinite scroll in a UI from most recent transactions in reverse order until some point in the past.
  rpc GetBankTransactionTimeline(GetBankTransactionTimelineRequest) returns (GetBankTransactionTimelineResponse) {}

  // Get all bank transactions across all or a specific account a user has access to.
  // Returns a PERMISSION_DENIED code if the authenticated user has no access to the specified account,
  // or if the authenticated user does not match the user id.
  // This returns bank transactions from the most recent to the oldest, results can be filtered using from/to params.
  // Use case: openbanking service needs to be able to fetch all transactions for a given account.
  // WARNING: if you use from/to and you dont provide microsecond precision, you might get duplicate records.
  rpc GetBankTransactions(GetBankTransactionsRequest) returns (GetBankTransactionsResponse) {}

  // Get all crypto transaction events that happened on all wallets a user has access to.
  // Returns a PERMISSION_DENIED code if the authenticated user has no access to the specified account,
  // or if the authenticated user does not match the user id.
  // Events are returned from oldest to most recent, since a given anchor event.
  // Use case: synchronize a client with all new crypto events since the last one it received, or since the most recent timeline entry.
  rpc GetCryptoTransactionEvents(GetCryptoTransactionEventsRequest) returns (GetCryptoTransactionEventsResponse) {}

  // Get all bank transaction events that happened on all accounts a user has access to.
  // Returns a PERMISSION_DENIED code if the authenticated user has no access to the specified account,
  // or if the authenticated user does not match the user id.
  // Events are returned from oldest to most recent, since a given anchor event.
  // Use case: synchronize a client with all new bank account events since the last one it received, or since the most recent timeline entry.
  rpc GetBankTransactionEvents(GetBankTransactionEventsRequest) returns (GetBankTransactionEventsResponse) {}
}

message CreateCryptoAccountRequest {
    string user_id = 10; // mandatory
    string asset_id = 20; // mandatory
}

message CreateCryptoAccountResponse {
  CryptoAccount account = 10;
}

// Get N bank transactions in reverse postedTime order, either starting from the most recent or,
// if `before_id` is present, starting from the transaction immediately before the specified id.
// The timeline ends whenever a request returns less than N, or 0 transactions.
message GetBankTransactionsRequest {
  string user_id = 10; // mandatory
  string account_id = 20; // mandatory
  google.protobuf.Timestamp from = 40;
  google.protobuf.Timestamp to = 50;
  int32 limit = 60; // max 100
}

message GetBankTransactionsResponse {
  repeated BankTransaction transactions = 10;
}

message GetBankAccountsRequest {
  string user_id = 10;
}

// At the moment, you can expect a user to have a single account per currency.
// However, it is important to store data on the client based on the id of the BankAccount, not the currency,
// as in the future we might break the above rule.
message GetBankAccountsResponse {
  repeated BankAccount accounts = 10;
}

message GetBankAccountRequest {
  string user_id = 10;
  string account_id = 20;
}

message GetBankAccountResponse {
  BankAccount account = 10;
}

message GetCryptoAccountsRequest {
  string user_id = 10;
}

// No error returned here, however keep in mind that an unauthorized code is returned
// if the request's user id does not match the auth token holder.
// At the moment, we keep a single balance per cryptocurrency.
// However, it is important to store data on the client based on the id of the CryptoAccount, not the currency,
// as in the future we might break the above rule.
message GetCryptoAccountsResponse {
  repeated CryptoAccount accounts = 10;
}

message GetCryptoAccountRequest {
  string user_id = 10;
  string account_id = 20;
}

message GetCryptoAccountResponse {
  CryptoAccount account = 10;
}

// Get N crypto transactions in reverse postedTime order, either starting from the most recent or,
// if `before_id` is present, starting from the transaction immediately before the specified id.
// Eg: first response for N=3 is txId100, txId99, txId98. To keep scrolling in the past, the next request
// should be with before_id = "txId98" and will return txId97, txId96, txId95.
// The timeline ends whenever a request returns less than N, or 0 transactions.
message GetCryptoTransactionTimelineRequest {
  string user_id = 10; // mandatory
  string account_id = 20; // mandatory
  string before_id = 40;
  int32 limit = 50; // max 100
}

message GetCryptoTransactionTimelineResponse {
  repeated CryptoTransaction transactions = 10;
}

// Get N bank transactions in reverse postedTime order, either starting from the most recent or,
// if `before_id` is present, starting from the transaction immediately before the specified id.
// The timeline ends whenever a request returns less than N, or 0 transactions.
message GetBankTransactionTimelineRequest {
  string user_id = 10; // mandatory
  string account_id = 20; // mandatory
  string before_id = 40;
  int32 limit = 50; // max 100
}

message GetBankTransactionTimelineResponse {
  repeated BankTransaction transactions = 10;
}

// Get N transaction updates in the order they were processed in our backend.
// Or queues do not have any ordering guarantees, to ensure maximum performance.
// This means that, occasionally, a transaction event will be out of order.
// For any given transaction, there might be multiple events, such as multiple state transitions.
// When updating your local transaction data, don't forget to use the updatedTime to determine
// whether the information you already have is newer and should not be overwritten.
// Transactions carry a lot of information, typically only state and amount will change, but we thought it's
// best if each event carries the whole snapshot of a transaction, rather than just a diff, so clients
// only need to overwrite their records.
//
// If after_id is empty, it will return up to N events from when the account was created, or at least the oldest data
// we keep on record. From that point, the client can keep iterating through events until present time, by passing
// the after_id parameter. When starting from a fresh app install, it's advisable to make a timeline call first,
// populate your local database with some recent transactions, and then start consuming events from the most recent
// transaction's event ID. And only consume older timelines if the user scrolls down.
//
// Example of how this works: first request with N=3 returns txEvt01, txEvt02, txEvt03.
// Second request should have after_id="txEvt03" and will return txEvt04, txEvt05, txEvt06.
// An empty response means there has been no event since the last on the client synced.
message GetCryptoTransactionEventsRequest {
  string user_id = 10; // mandatory

  // optional, fetch events after the given event id
  string after_id = 20;
  int32 limit = 30; // max 1000
}

message GetCryptoTransactionEventsResponse {
  repeated CryptoTransaction transactions = 10;
}


// An empty response means there has been no event since the last on the client synced.
message GetBankTransactionEventsRequest {
  string user_id = 10; // mandatory

  // optional, fetch events after the given event id
  string after_id = 20;

  // max 1000
  int32 limit = 30; 
}

message GetBankTransactionEventsResponse {
  repeated BankTransaction transactions = 10;
}

