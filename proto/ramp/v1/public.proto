syntax = "proto3";

package ramp.v1;

service PingService {
  rpc Ping (PingRequest) returns (PingResponse) {}
}

message PingRequest {
}

message PingResponse {
  string message = 10;
}

// signature_type is supplied with every request in the header
// public_key is supplied with every request in the header
// timestamp is supplied with every request in the header and timestamp is validated as (+-1 minute from now) and used as a salt
// signature is supplied with every request in the header as sing(request body + timestamp, private_key) and validated as verify(request body + timestamp, public_key)
service RampService {
  rpc GetAccountInfo (GetAccountInfoRequest) returns (GetAccountInfoResponse) {}

  rpc WhitelistAddress (WhitelistAddressRequest) returns (WhitelistAddressResponse) {}
  rpc RemoveAddress (RemoveAddressRequest) returns (RemoveAddressResponse) {}

  // Set a bank account for the off ramp
  rpc SetBankAccount (SetBankAccountRequest) returns (SetBankAccountResponse) {}
}

message GetAccountInfoRequest {}

message GetAccountInfoResponse {
  oneof result {
    Authentication authentication = 20;
    Account account = 30;
  }

  message Authentication {
    string authentication_url = 10;
  }

  message Account {
    // list of whitelisted addresses
    repeated Wallet wallets = 10;

    // A bank account created by Harbour in the name of the user, where funds can be sent
    oneof onramp_bank_account {
      ScanCoordinates onramp_scan = 100; // only for scheme SCAN (UK payments)
      IbanCoordinates onramp_iban = 110; // for both SEPA and SWIFT schemes
    }

    // A bank account set by the user for off-ramping, see rpc SetBankAccount
    oneof offramp_bank_account {
      ScanCoordinates offramp_scan = 200; // only for scheme SCAN (UK payments)
      IbanCoordinates offramp_iban = 210; // for both SEPA and SWIFT schemes
    }

    string account_holder = 20; // account holder name for on and off-ramping
  }

  message Wallet {
    string name = 5; // user given name
    Ecosystem ecosystem = 10;
    string address = 20;
    repeated RampAsset assets = 30;

    message RampAsset {
      Asset asset = 10;
      OnRamp on_ramp = 20;
      OffRamp off_ramp = 30;

      message Asset {
        Network network = 10;
        AssetId asset_id = 20; // the client can use this to match an asset with precision and display custom wording / icon
        string short_name = 30; // to be used as a fallback if the client doesn't recognise the asset_id (eg: out of date proto definitions)
        // TBD: smart contract address, long name...
      }
    }

    message OnRamp {
      string payment_reference = 10; // e.g. "ETH USDC 1" or ETU1
      float estimated_rate = 30; // can be slightly different as rate is taken at the moment funds hit Harbour wallet / bank account
      Fee estimated_network_fee = 40; // can be slightly different as rate is taken at the moment funds hit Harbour wallet / bank account
      Fee processing_fee = 50;
    }

    message OffRamp {
      string address = 10;
      float estimated_rate = 30; // can be slightly different as rate is taken at the moment funds hit Harbour wallet / bank account
      Fee estimated_network_fee = 40; // can be slightly different as rate is taken at the moment funds hit Harbour wallet / bank account
      Fee processing_fee = 50;
    }

    message Fee {
      string fix = 10; // denominated in the currency of bank account (EUR, GBP)
      string percent = 20;
    }
  }
}

message WhitelistAddressRequest {
  // user given name, could be same name as in the Self Custody wallet if supported by wallet vendor
  // (the maximum length of the name is 100 symbols)
  string name = 10;
  Ecosystem ecosystem = 20;
  string address = 30;
  // for the Ethereum: the address filed should be signed with https://docs.metamask.io/wallet/reference/personal_sign/ using
  // private key of this address
  string address_signature = 40;
}

message WhitelistAddressResponse {}

message RemoveAddressRequest {
  Ecosystem ecosystem = 20;
  string address = 30;
}

message RemoveAddressResponse {}

message SetBankAccountRequest {
  // first and last beneficiary name is not required. KYC info will be used as beneficiary name
  oneof bank_account {
    ScanCoordinates scan = 10; // only for scheme SCAN
    IbanCoordinates iban = 20; // for both SEPA and SWIFT schemes
  }
}

// TODO the client should be able to comply to basic validation rules such as min/max length for ibans, sort codes and account numbers
// however complex validation such as IBAN or SCAN checksums and sort code directory should be performed by us
// thus we need to define proper error responses
message SetBankAccountResponse {

}

message ScanCoordinates {
  string account_number = 10; // always 8 digits
  string sort_code = 20; // always 6 digits (if using an input mask such as ##-##-##, remove the dashes before submitting)
}

message IbanCoordinates {
  string iban = 10; // up to 34 characters (please submit them all uppercase) and numbers
}

enum Ecosystem {
  ECOSYSTEM_UNSPECIFIED = 0;
  ECOSYSTEM_ETHEREUM = 10; // any EVM compatible chain - addresses are expected to be the right-most 160 bits of the keccak256 hash of the public key
  ECOSYSTEM_COSMOS = 20; // any Cosmos ecosystem chain - addresses are expected to be compatible with the Cosmos SDK (such as 160 bit BECH32)
}

// An AssetId helps the client to identify an exact token and customise the UI.
// The AssetId is universal across all chains, in fact our responses always include the Network, and the AssetID.
// So ASSET_ID_USDC could either be the Ethereum, or Avalanche, or Polygon USDC token.
enum AssetId {
  ASSET_ID_UNSPECIFIED = 0;
  ASSET_ID_USDC = 10;
}

enum Network {
  NETWORK_UNSPECIFIED = 0;
  NETWORK_ETHEREUM_MAINNET = 10;
  NETWORK_ETHEREUM_SEPOLIA = 20;
  NETWORK_AVAX_FUJI = 30;
  NETWORK_AVAX_C_MAINNET = 40;
}

enum SignatureType {
  SIGNATURE_TYPE_UNSPECIFIED = 0;
  SIGNATURE_TYPE_RSA = 1;
  SIGNATURE_TYPE_SECP256K1 = 2;
  SIGNATURE_TYPE_SECP256R1 = 3;
}