syntax = "proto3";
package exchange.v1;

import "google/protobuf/timestamp.proto";

service PingService {
  rpc Ping (PingRequest) returns (PingResponse) {}
}

message PingRequest {
}

message PingResponse {
  string message = 10;
}

service ExchangeService {
  rpc GetExchangeRate (GetExchangeRateRequest) returns (GetExchangeRateResponse) {}
  rpc Exchange (ExchangeRequest) returns (ExchangeResponse) {}
}

enum CurrencyType {
  CURRENCY_TYPE_UNSPECIFIED = 0;
  CURRENCY_TYPE_FIAT = 10;
  CURRENCY_TYPE_CRYPTO = 20;
}

message Asset {
  CurrencyType type = 10;
  string id = 20;
}

message Account {
  CurrencyType type = 10;
  string account_id = 20;
}

message GetExchangeRateRequest {
  Asset from = 10;
  Asset to = 20;
  string user_id = 30;
}

message GetExchangeRateResponse {
  oneof result {
    Error error = 20;
    Quote quote = 30;
  }
  enum Error {
    ERROR_UNSPECIFIED = 0;
    ERROR_UNSUPPORTED_ASSET_PAIR = 10;
    // the FX service is unavailable due to operational reasons
    // (eg: we are dealing with a liquidity issue or halting FX temporarily for other reasons)
    ERROR_SERVICE_UNAVAILABLE = 20;
  }
  message Quote {
    // rate is from/to (eg: GBP/USDC when exchanging from GBP to USDC)
    string rate = 10;

    // the expiry is also in the JWT, but we added as an extra field so that the client doesn't need to parse the token
    google.protobuf.Timestamp expires_at = 20;

    // a signed JWT containing claims (from, to, expires_at and rate)
    // client app can just treat as a string
    string token = 30;

    // the minimum amount that can be converted (eg: 1 GBP), note: might be different for each asset
    string min_amount = 40;
    // the maximum amount that can be converted (eg: 1000 GBP)
    string max_amount = 50;
  }
}

message ExchangeRequest {
  // a non-expired JWT from GetExchangeRateResponse
  // (the backend will allow a few seconds slack on expired quotes to factor in network latency)
  string token = 10;

  string user_id = 20;

  // the account that will be debited (eg: GBP if converting from GBP to USDC)
  Account from = 30;
  // the account that will be credited (eg: USDC if converting from GBP to USDC)
  Account to = 40;

  // amount to exchange of the "from" Account
  // note: for fiat currencies, the max precision is defined by the ISO 4217 standard, eg: 2 decimal digits for GBP
  // for crypto currencies, the max precision is the same as for with withdrawal API
  string amount = 50;

  // mandatory UUID to prevent duplicate requests
  // should be generated by the client when landing on the exchange screen
  string idempotency_key = 60;

  // if true, all validation is performed but no exchange is actually performed
  // an ok response is still returned
  bool dry_run = 70;
}

message ExchangeResponse {
  oneof result {
    Error error = 20;
  }
  enum Error {
    ERROR_UNSPECIFIED = 0;
    ERROR_TOKEN_EXPIRED = 10;
    ERROR_TOKEN_INVALID = 20;
    ERROR_INSUFFICIENT_BALANCE = 30;
    ERROR_MIN_AMOUNT = 40; // amount is less than the min_amount in the quote
    ERROR_MAX_AMOUNT = 50; // amount is greater than the max_amount in the quote
    ERROR_PRECISION_EXCEEDED = 60;
    // amount is within max_amount, however daily or monthly limit has been exceeded
    ERROR_LIMIT_EXCEEDED = 70;
    ERROR_SERVICE_UNAVAILABLE = 80;
  }
}