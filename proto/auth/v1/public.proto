syntax = "proto3";
package auth.v1;

import "auth/v1/common.proto";
import "google/protobuf/timestamp.proto";

// Simple utility to verify that the API can be reached successfully.
service PingService {
  rpc Ping (PingRequest) returns (PingResponse) {}
}

message PingRequest {}

message PingResponse {
  string message = 10;
}

// Note: this API was initially designed for a time when we only expected a single use case: a Harbour app installed
// on a smart phone. So the main entity that is registered with the backend is a "device", which contains additional
// information such as the app version. A new API is under way to support a broader spectrum of different apps,
// potentially running on the same or different devices.
service DeviceService {
  // When a device has no local data (fresh install) or outdated device id (data recovered from different device backup),
  // it has to generate a new keypair and register itself.
  // It is vital to store the private key securely on the device (eg: pin or biometrics protection to access).
  // After correct device registration, user should be presented with the SignIn/SignUp screen.
  // A registered device is only linked to a user after a new user is created (sign up), or when signing back in.
  rpc RegisterDevice(RegisterDeviceRequest) returns (RegisterDeviceResponse) {}
}

service UserService {
  // Initiate user sign in by providing a valid phone number associated with the given user.
  rpc SignIn(SignInRequest) returns (SignInResponse) {}

  // Confirm identity by entering the OTP sent to the user via SMS.
  // On success, the device is linked to the user account and can perform all user operations.
  rpc SignInConfirm(SignInConfirmRequest) returns (SignInConfirmResponse) {}

  // There's no need to "log out" of the application, as the user is supposed to be always logged in, as long as they
  // can authenticate with pin/biometrics to retrieve a valid access token.
  // However, one might want to unlink the device from their account, in which case this RPC can be used.
  // Note that this is an authenticated endpoint, thus requiring a valid access token in the request headers.
  rpc SignOut(SignOutRequest) returns (SignOutResponse) {}

  // TODO add sign up RPC
}

service AuthService {
  // Active devices can use this rpc to obtain access and refresh token.
  // The access token has a strict expiry (minutes), and should be refreshed before expiry.
  // The refresh token has a longer expiry time (fraction of an hour).
  // The app can keep store those somewhat securely, but pin/biometrics should not be required to fetch them,
  // as it would be terrible user experience to have to insert the PIN while using the app.
  // However, user inactivity must be detected in the app and these credentials deleted if so,
  // in order to force biometrics/pin use when the user comes back.
  // The obtained token can be used for any authenticated RPCs, by adding an "Authorization" header to the request,
  // in the format "Bearer xxx" (without quotes), where xxx is the access token.
  rpc Authenticate(AuthenticateRequest) returns (AuthenticateResponse) {}

  // Exchange the refresh token for a new access and refresh token.
  // Once exchanged, the previous refresh token gets invalidated and can not be re used.
  // Refresh tokens have a fixed lifespan and every new refresh token inherits this lifespan.
  // Eg: access token is 5 minutes, refresh token is 15 minutes.
  // After 5 minutes the client refreshes: the new refresh token has 10 minutes expiry.
  // After another 5 minutes, another refresh: the new refresh token has a 5 minute expiry.
  // So essentially the session can be prolonged to almost 20 minutes worth of access tokens, more than enough to
  // support a user navigating the app for an extended period of time.
  // Upon inactivity, the app should delete the stored tokens and force the user to authenticate again via pin/biometrics.
  // The refresh token is limited in time to mitigate potential attackers gaining prolonged access.
  rpc Refresh(RefreshRequest) returns (RefreshResponse) {}
}


message GetUserDetailsRequest{}

message GetUserDetailsResponse{
  string id = 10;
  string first_name = 20;
  string middle_names = 30;
  string last_name = 40;
  PhoneNumber phone_number = 50;
  google.protobuf.Timestamp created_at = 60;
  string email = 70;
  string date_of_birth = 80;
  Address address = 90;

  message Address{
    string address_line1 = 10;
    string address_line2 = 20;
    string city = 30;
    string state = 40;
    string post_code = 50;
    string country = 60;
  }
}

message SignInRequest {
  // The device ID returned by the backend when registering, mandatory.
  // Submitting a wrong device id will produce an invalid_argument error response
  string device_id = 10;

  // Mandatory, the vendor device ID used when registering
  string vendor_device_id = 20;

  // Required
  PhoneNumber phone_num = 30;

  // A JWT with a `vendor_device_id` claim and an expiry not further than 10 seconds from now
  string signature = 70;
}

message SignInResponse {
  oneof result {
    Error error = 10;
    string token = 20; // A token to be used to confirm the user along with the OTP
  }
  enum Error {
    ERROR_UNSPECIFIED = 0;
    ERROR_USER_NOT_FOUND = 1; // user associated with the device is not found
    ERROR_DEVICE_NOT_FOUND = 2; // wrong device_id, likely a client bug
    ERROR_INVALID_PHONE_NUMBER = 3; // phone number is not valid
  }
}

message SignInConfirmRequest {
  // The OTP that was send to user.
  string value = 10;

  // Returned by SignIn RPC. Contains user/device data and the OTP ID.
  string token = 20;
}

message SignInConfirmResponse {
  oneof result {
    Error error = 10;
  }
  enum Error {
    ERROR_UNSPECIFIED = 0; // OTP value does not match with the OTP provided by the user.
    ERROR_INVALID_OTP = 1;
    ERROR_ALREADY_USED_OTP = 2;
    ERROR_EXPIRED_OTP = 3; // OTP is correct but expired
  }
}

message AuthenticateRequest {
  // Device-specific data.
  // If server does not recognise the vendor device id or vendor id, it is likely that this is a new device
  // on which a backup from a previous device was restored.
  // If that's the case, the mobile app should go back to DeviceService.Register and then present the user with the SignIn/SignUp screen
  string vendor_device_id = 10;
  string vendor_id = 20;

  // These fields are allowed to change over time.
  // The device will often authenticate, so as soon as there is a change in os or app version,
  // our backend will update its records, just for the purpose of keeping track.
  // Knowing the os and app version is useful for debugging and to force updates.
  string os = 30;
  string os_version = 40;
  string app_version = 50;
  string name = 60;

  // Server side device id that allows our backend to identify this device
  string device_id = 70;

  // Signature is generated as following:
  // - create a json web token with one claim vendor_device_id and an expiry no further than 10s from now
  // - sign the jwt with the device's RSA key
  // - jwt libraries will output the jwt as base64 encoded: this will be the value of the signature field
  // The reason why the expiry is required and time-sensitive is to avoid man-in-the-middle attacks.
  // Every AuthRequest should have a different signature as it should pick the current time + 10s for expiry.
  // Sending the same signature twice (ie, with the same expiry time), will be rejected.
  // Note: for the sake of testing, the max expiry is configurable in the backend, on non-prod environments,
  // so this RPC might accept an expiry greater than 10s.
  string signature = 90;
}

message AuthenticateResponse {
  oneof result {
    Error error = 10;
    AuthCredentials credentials = 11;
  }
  enum Error {
    ERROR_UNSPECIFIED = 0;

    // Token is invalid, or does not contain the right claims, or is expired,
    // or the signature does not match the device pubkey registered on the server,
    // or it has already been used.
    ERROR_INVALID = 1;

    // App version is too old and user should be forced to update in their app store
    ERROR_DEPRECATED = 2;

    // Either the device_id doesn't exist in our database, or it has been inactivated,
    // or the vendor_device_id and vendor_id do not correspond.
    // Either way, the device needs to be registered again (DeviceService.Register())
    ERROR_INACTIVE = 3;
  }
}

message AuthCredentials {
  string access_token = 10;
  string refresh_token = 20;
  int64 access_token_expiry_sec = 30;
  int64 refresh_token_expiry_sec = 40;
}

message RefreshRequest {
  string refresh_token = 10;
  string device_id = 20;
}

message RefreshResponse {
  oneof result {
    Error error = 10;
    AuthCredentials credentials = 11;
  }
  enum Error {
    ERROR_UNSPECIFIED = 0;

    // The refresh token is valid but in the meantime the device has been unlinked from the user
    // and needs to register again.
    ERROR_INACTIVE = 2;

    // Refresh cannot be used to generate new tokens as it's either invalid or expired.
    // App should bring user back to pin/biometrics screen and go through auth again.
    ERROR_INVALID_REFRESH_TOKEN = 4;
  }
}

message RegisterDeviceRequest {
  // Required device id. Typically each smartphone vendor assigns some sort of unique id to each device,
  // which can be retrieved via the OS API for any app running.
  string vendor_device_id = 10;

  // Required identifier for vendor. Can be retrieved by OS API and then mapped to values such as:
  // Apple, Samsung, Google, etc.
  string vendor_id = 20;

  // Required identifier for OS (eg: iOS, Android, etc)
  string os = 30; // required

  // Required OS version (eg: 17.1)
  string os_version = 40;

  // Required app version
  string app_version = 50;

  // Required device name (eg: Martin's iPhone)
  string name = 60;

  // RSA 4096 public key base64 encoded, if correctly generated should be 736 chars
  string public_key = 70;

  // In order to verify that the public key and signing algorithm is correct,
  // generate a signature as following:
  // - create a json web token with one string fields: vendor_device_id
  // - sign the jwt with the device's RSA key
  // - jwt libraries will output the jwt as base64 encoded: this will be the value of the signature field
  string signature = 80;
}

message RegisterDeviceResponse {
  // server-side device id, this is a UUID different than the vendor_device_id
  // devices must persist it for later usage, however this is not sensitive data
  string device_id = 10;
}

message SignOutRequest {
}

message SignOutResponse {
}
